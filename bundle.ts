/* Generated from Java with JSweet 2.2.0-SNAPSHOT - http://www.jsweet.org */
namespace io.nem {
    /**
     * Callback for asynchronous API call.
     * 
     * @param <T> The return type
     * @class
     */
    export interface ApiCallback<T> {
        /**
         * This is called when the API call fails.
         * 
         * @param {io.nem.xpx.exceptions.ApiException} e The exception causing the failure
         * @param {number} statusCode Status code of the response if available, otherwise it would be 0
         * @param {*} responseHeaders Headers of the response if available, otherwise it would be null
         */
        onFailure(e : io.nem.xpx.exceptions.ApiException, statusCode : number, responseHeaders : any);

        /**
         * This is called when the API call succeeded.
         * 
         * @param {*} result The result deserialized from response
         * @param {number} statusCode Status code of the response
         * @param {*} responseHeaders Headers of the response
         */
        onSuccess(result : T, statusCode : number, responseHeaders : any);

        /**
         * This is called when the API upload processing.
         * 
         * @param {number} bytesWritten bytes Written
         * @param {number} contentLength content length of request body
         * @param {boolean} done write end
         */
        onUploadProgress(bytesWritten : number, contentLength : number, done : boolean);

        /**
         * This is called when the API downlond processing.
         * 
         * @param {number} bytesRead bytes Read
         * @param {number} contentLength content lenngth of the response
         * @param {boolean} done Read end
         */
        onDownloadProgress(bytesRead : number, contentLength : number, done : boolean);
    }
}
namespace io.nem {
    /**
     * Instantiates a new api client.
     * @class
     */
    export class ApiClient {
        static __static_initialized : boolean = false;
        static __static_initialize() { if(!ApiClient.__static_initialized) { ApiClient.__static_initialized = true; ApiClient.__static_initializer_0(); } }

        /**
         * The Constant JAVA_VERSION.
         */
        public static JAVA_VERSION : number; public static JAVA_VERSION_$LI$() : number { ApiClient.__static_initialize(); return ApiClient.JAVA_VERSION; };

        /**
         * The Constant IS_ANDROID.
         */
        public static IS_ANDROID : boolean; public static IS_ANDROID_$LI$() : boolean { ApiClient.__static_initialize(); return ApiClient.IS_ANDROID; };

        /**
         * The Constant ANDROID_SDK_VERSION.
         */
        public static ANDROID_SDK_VERSION : number; public static ANDROID_SDK_VERSION_$LI$() : number { ApiClient.__static_initialize(); return ApiClient.ANDROID_SDK_VERSION; };

        static __static_initializer_0() {
            ApiClient.JAVA_VERSION = /* parseDouble */parseFloat(java.lang.System.getProperty("java.specification.version"));
            let isAndroid : boolean;
            try {
                /* forName */eval("android.app.Activity");
                isAndroid = true;
            } catch(e) {
                isAndroid = false;
            };
            ApiClient.IS_ANDROID = isAndroid;
            let sdkVersion : number = 0;
            if(ApiClient.IS_ANDROID_$LI$()) {
                try {
                    sdkVersion = /* getField */((c,p) => { return {owner:c,name:p}; })(/* forName */eval("android.os.Build$VERSION"),"SDK_INT").getInt(null);
                } catch(e) {
                    try {
                        sdkVersion = /* parseInt */parseInt(<string>/* get */null[/* getField */((c,p) => { return {owner:c,name:p}; })(/* forName */eval("android.os.Build$VERSION"),"SDK").name]);
                    } catch(e2) {
                    };
                };
            }
            ApiClient.ANDROID_SDK_VERSION = sdkVersion;
        }

        /**
         * The datetime format to be used when <code>lenientDatetimeFormat</code> is enabled.
         */
        public static LENIENT_DATETIME_FORMAT : string = "yyyy-MM-dd\'T\'HH:mm:ss.SSSZ";

        /**
         * The base path.
         */
        /*private*/ basePath : string = "http://localhost:8881";

        /**
         * The lenient on json.
         */
        /*private*/ lenientOnJson : boolean = false;

        /**
         * The debugging.
         */
        /*private*/ debugging : boolean = false;

        /**
         * The default header map.
         */
        /*private*/ defaultHeaderMap : any = <any>({});

        /**
         * The temp folder path.
         */
        /*private*/ tempFolderPath : string = null;

        /**
         * The authentications.
         */
        /*private*/ authentications : any;

        /**
         * The date format.
         */
        /*private*/ dateFormat : java.text.DateFormat;

        /**
         * The datetime format.
         */
        /*private*/ datetimeFormat : java.text.DateFormat;

        /**
         * The lenient datetime format.
         */
        /*private*/ lenientDatetimeFormat : boolean;

        /**
         * The date length.
         */
        /*private*/ dateLength : number;

        /**
         * The ssl ca cert.
         */
        /*private*/ sslCaCert : { str: string, cursor: number };

        /**
         * The verifying ssl.
         */
        /*private*/ verifyingSsl : boolean;

        /**
         * The key managers.
         */
        /*private*/ keyManagers : javax.net.ssl.KeyManager[];

        /**
         * The http client.
         */
        /*private*/ httpClient : com.squareup.okhttp.OkHttpClient;

        /**
         * The json.
         */
        /*private*/ json : io.nem.JSON;

        /**
         * The logging interceptor.
         */
        /*private*/ loggingInterceptor : com.squareup.okhttp.logging.HttpLoggingInterceptor;

        public constructor() {
            if(this.authentications===undefined) this.authentications = null;
            if(this.dateFormat===undefined) this.dateFormat = null;
            if(this.datetimeFormat===undefined) this.datetimeFormat = null;
            if(this.lenientDatetimeFormat===undefined) this.lenientDatetimeFormat = false;
            if(this.dateLength===undefined) this.dateLength = 0;
            if(this.sslCaCert===undefined) this.sslCaCert = null;
            if(this.verifyingSsl===undefined) this.verifyingSsl = false;
            if(this.keyManagers===undefined) this.keyManagers = null;
            if(this.httpClient===undefined) this.httpClient = null;
            if(this.json===undefined) this.json = null;
            if(this.loggingInterceptor===undefined) this.loggingInterceptor = null;
            this.httpClient = new com.squareup.okhttp.OkHttpClient();
            this.httpClient.setWriteTimeout(30, java.util.concurrent.TimeUnit.MINUTES);
            this.httpClient.setReadTimeout(30, java.util.concurrent.TimeUnit.MINUTES);
            this.httpClient.setConnectTimeout(30, java.util.concurrent.TimeUnit.MINUTES);
            this.verifyingSsl = true;
            this.json = new io.nem.JSON(this);
            this.dateFormat = new java.text.SimpleDateFormat("yyyy-MM-dd");
            this.dateFormat.setTimeZone(/* getTimeZone */"UTC");
            this.initDatetimeFormat();
            this.lenientDatetimeFormat = true;
            this.setUserAgent("Swagger-Codegen/1.0.0/java");
            this.authentications = <any>({});
            this.authentications = java.util.Collections.unmodifiableMap<any, any>(this.authentications);
        }

        /**
         * Get base path.
         * 
         * @return {string} Baes path
         */
        public getBasePath() : string {
            return this.basePath;
        }

        /**
         * Set base path.
         * 
         * @param {string} basePath Base path of the URL (e.g http://localhost:8881
         * @return {io.nem.ApiClient} An instance of OkHttpClient
         */
        public setBasePath(basePath : string) : ApiClient {
            this.basePath = basePath;
            return this;
        }

        /**
         * Get HTTP client.
         * 
         * @return {com.squareup.okhttp.OkHttpClient} An instance of OkHttpClient
         */
        public getHttpClient() : com.squareup.okhttp.OkHttpClient {
            return this.httpClient;
        }

        /**
         * Set HTTP client.
         * 
         * @param {com.squareup.okhttp.OkHttpClient} httpClient An instance of OkHttpClient
         * @return {io.nem.ApiClient} Api Client
         */
        public setHttpClient(httpClient : com.squareup.okhttp.OkHttpClient) : ApiClient {
            this.httpClient = httpClient;
            return this;
        }

        /**
         * Get JSON.
         * 
         * @return {io.nem.JSON} JSON object
         */
        public getJSON() : io.nem.JSON {
            return this.json;
        }

        /**
         * Set JSON.
         * 
         * @param {io.nem.JSON} json JSON object
         * @return {io.nem.ApiClient} Api client
         */
        public setJSON(json : io.nem.JSON) : ApiClient {
            this.json = json;
            return this;
        }

        /**
         * True if isVerifyingSsl flag is on.
         * 
         * @return {boolean} True if isVerifySsl flag is on
         */
        public isVerifyingSsl() : boolean {
            return this.verifyingSsl;
        }

        /**
         * Configure whether to verify certificate and hostname when making https requests.
         * Default to true.
         * NOTE: Do NOT set to false in production code, otherwise you would face multiple types of cryptographic attacks.
         * 
         * @param {boolean} verifyingSsl True to verify TLS/SSL connection
         * @return {io.nem.ApiClient} ApiClient
         */
        public setVerifyingSsl(verifyingSsl : boolean) : ApiClient {
            this.verifyingSsl = verifyingSsl;
            this.applySslSettings();
            return this;
        }

        /**
         * Get SSL CA cert.
         * 
         * @return {{ str: string, cursor: number }} Input stream to the SSL CA cert
         */
        public getSslCaCert() : { str: string, cursor: number } {
            return this.sslCaCert;
        }

        /**
         * Configure the CA certificate to be trusted when making https requests.
         * Use null to reset to default.
         * 
         * @param {{ str: string, cursor: number }} sslCaCert input stream for SSL CA cert
         * @return {io.nem.ApiClient} ApiClient
         */
        public setSslCaCert(sslCaCert : { str: string, cursor: number }) : ApiClient {
            this.sslCaCert = sslCaCert;
            this.applySslSettings();
            return this;
        }

        /**
         * Gets the key managers.
         * 
         * @return {Array} the key managers
         */
        public getKeyManagers() : javax.net.ssl.KeyManager[] {
            return this.keyManagers;
        }

        /**
         * Configure client keys to use for authorization in an SSL session.
         * Use null to reset to default.
         * 
         * @param {Array} managers The KeyManagers to use
         * @return {io.nem.ApiClient} ApiClient
         */
        public setKeyManagers(managers : javax.net.ssl.KeyManager[]) : ApiClient {
            this.keyManagers = managers;
            this.applySslSettings();
            return this;
        }

        /**
         * Gets the date format.
         * 
         * @return {java.text.DateFormat} the date format
         */
        public getDateFormat() : java.text.DateFormat {
            return this.dateFormat;
        }

        /**
         * Sets the date format.
         * 
         * @param {java.text.DateFormat} dateFormat the date format
         * @return {io.nem.ApiClient} the api client
         */
        public setDateFormat(dateFormat : java.text.DateFormat) : ApiClient {
            this.dateFormat = dateFormat;
            this.dateLength = this.dateFormat.format(new Date()).length;
            return this;
        }

        /**
         * Gets the datetime format.
         * 
         * @return {java.text.DateFormat} the datetime format
         */
        public getDatetimeFormat() : java.text.DateFormat {
            return this.datetimeFormat;
        }

        /**
         * Sets the datetime format.
         * 
         * @param {java.text.DateFormat} datetimeFormat the datetime format
         * @return {io.nem.ApiClient} the api client
         */
        public setDatetimeFormat(datetimeFormat : java.text.DateFormat) : ApiClient {
            this.datetimeFormat = datetimeFormat;
            return this;
        }

        /**
         * Whether to allow various ISO 8601 datetime formats when parsing a datetime string.
         * 
         * @return {boolean} True if lenientDatetimeFormat flag is set to true
         * @see #parseDatetime(String)
         */
        public isLenientDatetimeFormat() : boolean {
            return this.lenientDatetimeFormat;
        }

        /**
         * Sets the lenient datetime format.
         * 
         * @param {boolean} lenientDatetimeFormat the lenient datetime format
         * @return {io.nem.ApiClient} the api client
         */
        public setLenientDatetimeFormat(lenientDatetimeFormat : boolean) : ApiClient {
            this.lenientDatetimeFormat = lenientDatetimeFormat;
            return this;
        }

        /**
         * Parse the given date string into Date object.
         * The default <code>dateFormat</code> supports these ISO 8601 date formats:
         * 2015-08-16
         * 2015-8-16
         * @param {string} str String to be parsed
         * @return {java.util.Date} Date
         */
        public parseDate(str : string) : Date {
            if(str == null) return null;
            try {
                return this.dateFormat.parse(str);
            } catch(e) {
                throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
            };
        }

        /**
         * Parse the given datetime string into Date object.
         * When lenientDatetimeFormat is enabled, the following ISO 8601 datetime formats are supported:
         * 2015-08-16T08:20:05Z
         * 2015-8-16T8:20:05Z
         * 2015-08-16T08:20:05+00:00
         * 2015-08-16T08:20:05+0000
         * 2015-08-16T08:20:05.376Z
         * 2015-08-16T08:20:05.376+00:00
         * 2015-08-16T08:20:05.376+00
         * Note: The 3-digit milli-seconds is optional. Time zone is required and can be in one of
         * these formats:
         * Z (same with +0000)
         * +08:00 (same with +0800)
         * -02 (same with -0200)
         * -0200
         * 
         * @param {string} str Date time string to be parsed
         * @return {java.util.Date} Date representation of the string
         * @see <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>
         */
        public parseDatetime(str : string) : Date {
            if(str == null) return null;
            let format : java.text.DateFormat;
            if(this.lenientDatetimeFormat) {
                str = /* replaceAll */str.replace(new RegExp("[zZ]\\z", 'g'),"+0000");
                str = /* replaceAll */str.replace(new RegExp("([+-]\\d{2}):(\\d{2})\\z", 'g'),"$1$2");
                str = /* replaceAll */str.replace(new RegExp("([+-]\\d{2})\\z", 'g'),"$100");
                str = /* replaceAll */str.replace(new RegExp("(:\\d{1,2})([+-]\\d{4})\\z", 'g'),"$1.000$2");
                format = new java.text.SimpleDateFormat(ApiClient.LENIENT_DATETIME_FORMAT);
            } else {
                format = this.datetimeFormat;
            }
            try {
                return format.parse(str);
            } catch(e) {
                throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
            };
        }

        /**
         * Parses the date or datetime.
         * 
         * @param {string} str the str
         * @return {java.util.Date} the date
         */
        public parseDateOrDatetime(str : string) : Date {
            if(str == null) return null; else if(str.length <= this.dateLength) return this.parseDate(str); else return this.parseDatetime(str);
        }

        /**
         * Format the given Date object into string (Date format).
         * 
         * @param {java.util.Date} date Date object
         * @return {string} Formatted date in string representation
         */
        public formatDate(date : Date) : string {
            return this.dateFormat.format(date);
        }

        /**
         * Format the given Date object into string (Datetime format).
         * 
         * @param {java.util.Date} date Date object
         * @return {string} Formatted datetime in string representation
         */
        public formatDatetime(date : Date) : string {
            return this.datetimeFormat.format(date);
        }

        /**
         * Get authentications (key: authentication name, value: authentication).
         * 
         * @return {*} Map of authentication objects
         */
        public getAuthentications() : any {
            return this.authentications;
        }

        /**
         * Get authentication for the given name.
         * 
         * @param {string} authName The authentication name
         * @return {*} The authentication, null if not found
         */
        public getAuthentication(authName : string) : io.nem.auth.Authentication {
            return /* get */((m,k) => m[k]===undefined?null:m[k])(this.authentications, authName);
        }

        /**
         * Helper method to set username for the first HTTP basic authentication.
         * 
         * @param {string} username Username
         */
        public setUsername(username : string) {
            {
                let array122 = /* values */(obj => Object.keys(obj).map(key => obj[key]))(this.authentications);
                for(let index121=0; index121 < array122.length; index121++) {
                    let auth = array122[index121];
                    {
                        if(auth != null && auth instanceof <any>io.nem.auth.HttpBasicAuth) {
                            (<io.nem.auth.HttpBasicAuth><any>auth).setUsername(username);
                            return;
                        }
                    }
                }
            }
            throw Object.defineProperty(new Error("No HTTP basic authentication configured!"), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
        }

        /**
         * Helper method to set password for the first HTTP basic authentication.
         * 
         * @param {string} password Password
         */
        public setPassword(password : string) {
            {
                let array124 = /* values */(obj => Object.keys(obj).map(key => obj[key]))(this.authentications);
                for(let index123=0; index123 < array124.length; index123++) {
                    let auth = array124[index123];
                    {
                        if(auth != null && auth instanceof <any>io.nem.auth.HttpBasicAuth) {
                            (<io.nem.auth.HttpBasicAuth><any>auth).setPassword(password);
                            return;
                        }
                    }
                }
            }
            throw Object.defineProperty(new Error("No HTTP basic authentication configured!"), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
        }

        /**
         * Helper method to set API key value for the first API key authentication.
         * 
         * @param {string} apiKey API key
         */
        public setApiKey(apiKey : string) {
            {
                let array126 = /* values */(obj => Object.keys(obj).map(key => obj[key]))(this.authentications);
                for(let index125=0; index125 < array126.length; index125++) {
                    let auth = array126[index125];
                    {
                        if(auth != null && auth instanceof <any>io.nem.auth.ApiKeyAuth) {
                            (<io.nem.auth.ApiKeyAuth><any>auth).setApiKey(apiKey);
                            return;
                        }
                    }
                }
            }
            throw Object.defineProperty(new Error("No API key authentication configured!"), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
        }

        /**
         * Helper method to set API key prefix for the first API key authentication.
         * 
         * @param {string} apiKeyPrefix API key prefix
         */
        public setApiKeyPrefix(apiKeyPrefix : string) {
            {
                let array128 = /* values */(obj => Object.keys(obj).map(key => obj[key]))(this.authentications);
                for(let index127=0; index127 < array128.length; index127++) {
                    let auth = array128[index127];
                    {
                        if(auth != null && auth instanceof <any>io.nem.auth.ApiKeyAuth) {
                            (<io.nem.auth.ApiKeyAuth><any>auth).setApiKeyPrefix(apiKeyPrefix);
                            return;
                        }
                    }
                }
            }
            throw Object.defineProperty(new Error("No API key authentication configured!"), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
        }

        /**
         * Helper method to set access token for the first OAuth2 authentication.
         * 
         * @param {string} accessToken Access token
         */
        public setAccessToken(accessToken : string) {
            {
                let array130 = /* values */(obj => Object.keys(obj).map(key => obj[key]))(this.authentications);
                for(let index129=0; index129 < array130.length; index129++) {
                    let auth = array130[index129];
                    {
                        if(auth != null && auth instanceof <any>io.nem.auth.OAuth) {
                            (<io.nem.auth.OAuth><any>auth).setAccessToken(accessToken);
                            return;
                        }
                    }
                }
            }
            throw Object.defineProperty(new Error("No OAuth2 authentication configured!"), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
        }

        /**
         * Set the User-Agent header's value (by adding to the default header map).
         * 
         * @param {string} userAgent HTTP request's user agent
         * @return {io.nem.ApiClient} ApiClient
         */
        public setUserAgent(userAgent : string) : ApiClient {
            this.addDefaultHeader("User-Agent", userAgent);
            return this;
        }

        /**
         * Add a default header.
         * 
         * @param {string} key The header's key
         * @param {string} value The header's value
         * @return {io.nem.ApiClient} ApiClient
         */
        public addDefaultHeader(key : string, value : string) : ApiClient {
            /* put */(this.defaultHeaderMap[key] = value);
            return this;
        }

        /**
         * Checks if is lenient on json.
         * 
         * @return {boolean} True if lenientOnJson is enabled, false otherwise.
         * @see <a href="https://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/stream/JsonReader.html#setLenient(boolean)">setLenient</a>
         */
        public isLenientOnJson() : boolean {
            return this.lenientOnJson;
        }

        /**
         * Set LenientOnJson.
         * 
         * @param {boolean} lenient True to enable lenientOnJson
         * @return {io.nem.ApiClient} ApiClient
         */
        public setLenientOnJson(lenient : boolean) : ApiClient {
            this.lenientOnJson = lenient;
            return this;
        }

        /**
         * Check that whether debugging is enabled for this API client.
         * 
         * @return {boolean} True if debugging is enabled, false otherwise.
         */
        public isDebugging() : boolean {
            return this.debugging;
        }

        /**
         * Enable/disable debugging for this API client.
         * 
         * @param {boolean} debugging To enable (true) or disable (false) debugging
         * @return {io.nem.ApiClient} ApiClient
         */
        public setDebugging(debugging : boolean) : ApiClient {
            if(debugging !== this.debugging) {
                if(debugging) {
                    this.loggingInterceptor = new com.squareup.okhttp.logging.HttpLoggingInterceptor();
                    this.loggingInterceptor.setLevel(com.squareup.okhttp.logging.HttpLoggingInterceptor.Level.BODY);
                    /* add */(this.httpClient.interceptors().push(this.loggingInterceptor)>0);
                } else {
                    /* remove */(a => { let index = a.indexOf(this.loggingInterceptor); if(index>=0) { a.splice(index, 1); return true; } else { return false; }})(this.httpClient.interceptors());
                    this.loggingInterceptor = null;
                }
            }
            this.debugging = debugging;
            return this;
        }

        /**
         * The path of temporary folder used to store downloaded files from endpoints
         * with file response. The default value is <code>null</code>, i.e. using
         * the system's default tempopary folder.
         * 
         * @return {string} Temporary folder path
         * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/io/File.html#createTempFile">createTempFile</a>
         */
        public getTempFolderPath() : string {
            return this.tempFolderPath;
        }

        /**
         * Set the tempoaray folder path (for downloading files).
         * 
         * @param {string} tempFolderPath Temporary folder path
         * @return {io.nem.ApiClient} ApiClient
         */
        public setTempFolderPath(tempFolderPath : string) : ApiClient {
            this.tempFolderPath = tempFolderPath;
            return this;
        }

        /**
         * Get connection timeout (in milliseconds).
         * 
         * @return {number} Timeout in milliseconds
         */
        public getConnectTimeout() : number {
            return this.httpClient.getConnectTimeout();
        }

        /**
         * Sets the connect timeout (in milliseconds).
         * A value of 0 means no timeout, otherwise values must be between 1 and
         * 
         * @param {number} connectionTimeout connection timeout in milliseconds
         * @return {io.nem.ApiClient} Api client
         */
        public setConnectTimeout(connectionTimeout : number) : ApiClient {
            this.httpClient.setConnectTimeout(connectionTimeout, java.util.concurrent.TimeUnit.MILLISECONDS);
            return this;
        }

        /**
         * Format the given parameter object into string.
         * 
         * @param {*} param Parameter
         * @return {string} String representation of the parameter
         */
        public parameterToString(param : any) : string {
            if(param == null) {
                return "";
            } else if(param != null && param instanceof <any>Date) {
                return this.formatDatetime(<Date>param);
            } else if(param != null && (param instanceof Array)) {
                let b : { str: string } = { str: "", toString: function() { return this.str; } };
                {
                    let array132 = <Array<any>><any>param;
                    for(let index131=0; index131 < array132.length; index131++) {
                        let o = array132[index131];
                        {
                            if(/* length */b.str.length > 0) {
                                /* append */(sb => { sb.str = sb.str.concat(<any>","); return sb; })(b);
                            }
                            /* append */(sb => { sb.str = sb.str.concat(<any>/* valueOf */new String(o).toString()); return sb; })(b);
                        }
                    }
                }
                return /* toString */b.str;
            } else {
                return /* valueOf */new String(param).toString();
            }
        }

        /**
         * Format to {@code Pair} objects.
         * 
         * @param {string} collectionFormat collection format (e.g. csv, tsv)
         * @param {string} name Name
         * @param {*} value Value
         * @return {io.nem.Pair[]} A list of Pair objects
         */
        public parameterToPairs(collectionFormat : string, name : string, value : any) : Array<io.nem.Pair> {
            let params : Array<io.nem.Pair> = <any>([]);
            if(name == null || /* isEmpty */(name.length === 0) || value == null) return params;
            let valueCollection : Array<any> = null;
            if(value != null && (value instanceof Array)) {
                valueCollection = <Array<any>><any>value;
            } else {
                /* add */(params.push(new io.nem.Pair(name, this.parameterToString(value)))>0);
                return params;
            }
            if(/* isEmpty */(valueCollection.length == 0)) {
                return params;
            }
            collectionFormat = (collectionFormat == null || /* isEmpty */(collectionFormat.length === 0)?"csv":collectionFormat);
            if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(collectionFormat,"multi"))) {
                for(let index133=0; index133 < valueCollection.length; index133++) {
                    let item = valueCollection[index133];
                    {
                        /* add */(params.push(new io.nem.Pair(name, this.parameterToString(item)))>0);
                    }
                }
                return params;
            }
            let delimiter : string = ",";
            if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(collectionFormat,"csv"))) {
                delimiter = ",";
            } else if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(collectionFormat,"ssv"))) {
                delimiter = " ";
            } else if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(collectionFormat,"tsv"))) {
                delimiter = "\t";
            } else if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(collectionFormat,"pipes"))) {
                delimiter = "|";
            }
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            for(let index134=0; index134 < valueCollection.length; index134++) {
                let item = valueCollection[index134];
                {
                    /* append */(sb => { sb.str = sb.str.concat(<any>delimiter); return sb; })(sb);
                    /* append */(sb => { sb.str = sb.str.concat(<any>this.parameterToString(item)); return sb; })(sb);
                }
            }
            /* add */(params.push(new io.nem.Pair(name, sb.substring(1)))>0);
            return params;
        }

        /**
         * Sanitize filename by removing path.
         * e.g. ../../sun.gif becomes sun.gif
         * 
         * @param {string} filename The filename to be sanitized
         * @return {string} The sanitized filename
         */
        public sanitizeFilename(filename : string) : string {
            return /* replaceAll */filename.replace(new RegExp(".*[/\\\\]", 'g'),"");
        }

        /**
         * Check if the given MIME is a JSON MIME.
         * JSON MIME examples:
         * application/json
         * application/json; charset=UTF8
         * APPLICATION/JSON
         * application/vnd.company+json
         * @param {string} mime MIME (Multipurpose Internet Mail Extensions)
         * @return {boolean} True if the given MIME is JSON, false otherwise.
         */
        public isJsonMime(mime : string) : boolean {
            let jsonMime : string = "(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$";
            return mime != null && (mime.matches(jsonMime) || /* equalsIgnoreCase */((o1, o2) => o1.toUpperCase() === (o2===null?o2:o2.toUpperCase()))(mime, "application/json-patch+json"));
        }

        /**
         * Select the Accept header's value from the given accepts array:
         * if JSON exists in the given array, use it;
         * otherwise use all of them (joining into a string).
         * 
         * @param {Array} accepts The accepts array to select from
         * @return {string} The Accept header to use. If the given array is empty,
         * null will be returned (not to set the Accept header explicitly).
         */
        public selectHeaderAccept(accepts : string[]) : string {
            if(accepts.length === 0) {
                return null;
            }
            for(let index135=0; index135 < accepts.length; index135++) {
                let accept = accepts[index135];
                {
                    if(this.isJsonMime(accept)) {
                        return accept;
                    }
                }
            }
            return io.nem.StringUtil.join(accepts, ",");
        }

        /**
         * Select the Content-Type header's value from the given array:
         * if JSON exists in the given array, use it;
         * otherwise use the first one of the array.
         * 
         * @param {Array} contentTypes The Content-Type array to select from
         * @return {string} The Content-Type header to use. If the given array is empty,
         * JSON will be used.
         */
        public selectHeaderContentType(contentTypes : string[]) : string {
            if(contentTypes.length === 0) {
                return "application/json";
            }
            for(let index136=0; index136 < contentTypes.length; index136++) {
                let contentType = contentTypes[index136];
                {
                    if(this.isJsonMime(contentType)) {
                        return contentType;
                    }
                }
            }
            return contentTypes[0];
        }

        /**
         * Escape the given string to be used as URL query value.
         * 
         * @param {string} str String to be escaped
         * @return {string} Escaped string
         */
        public escapeString(str : string) : string {
            try {
                return /* replaceAll */java.net.URLEncoder.encode(str, "utf8").replace(new RegExp("\\+", 'g'),"%20");
            } catch(e) {
                return str;
            };
        }

        /**
         * Deserialize response body to Java object, according to the return type and
         * the Content-Type response header.
         * 
         * @param <T> Type
         * @param {com.squareup.okhttp.Response} response HTTP response
         * @param {*} returnType The type of the Java object
         * @return {*} The deserialized Java object
         * @throws ApiException If fail to deserialize response body, i.e. cannot read response body
         * or the Content-Type of the response is not supported.
         */
        public deserialize<T>(response : com.squareup.okhttp.Response, returnType : java.lang.reflect.Type) : T {
            if(response == null || returnType == null) {
                return null;
            }
            if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })("byte[]",returnType.toString())) || (/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(returnType,Object)))) {
                try {
                    return <T><any>response.body().bytes();
                } catch(e) {
                    throw new io.nem.xpx.exceptions.ApiException(e);
                };
            } else if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(returnType,java.io.File))) {
                return <T><any>this.downloadFileFromResponse(response);
            }
            let respBody : string;
            try {
                if(response.body() != null) respBody = response.body().string(); else respBody = null;
            } catch(e) {
                throw new io.nem.xpx.exceptions.ApiException(e);
            };
            if(respBody == null || /* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })("",respBody))) {
                return null;
            }
            let contentType : string = response.headers().get("Content-Type");
            if(contentType == null) {
                contentType = "application/json";
            }
            if(this.isJsonMime(contentType)) {
                return <any>(this.json.deserialize<any>(respBody, returnType));
            } else if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(returnType,String))) {
                return <T><any>respBody;
            } else {
                throw new io.nem.xpx.exceptions.ApiException("Content type \"" + contentType + "\" is not supported for type: " + returnType, response.code(), response.headers().toMultimap(), respBody);
            }
        }

        /**
         * Serialize the given Java object into request body according to the object's
         * class and the request Content-Type.
         * 
         * @param {*} obj The Java object
         * @param {string} contentType The request Content-Type
         * @return {com.squareup.okhttp.RequestBody} The serialized request body
         * @throws ApiException If fail to serialize the given object
         */
        public serialize(obj : any, contentType : string) : com.squareup.okhttp.RequestBody {
            if(obj != null && obj instanceof <any>Array && (obj.length==0 || obj[0] == null ||typeof obj[0] === 'number')) {
                return com.squareup.okhttp.RequestBody.create(com.squareup.okhttp.MediaType.parse(contentType), <number[]>obj);
            } else if(obj != null && obj instanceof <any>java.io.File) {
                return com.squareup.okhttp.RequestBody.create(com.squareup.okhttp.MediaType.parse(contentType), <java.io.File>obj);
            } else if(this.isJsonMime(contentType)) {
                let content : string;
                if(obj != null) {
                    content = this.json.serialize(obj);
                } else {
                    content = null;
                }
                return com.squareup.okhttp.RequestBody.create(com.squareup.okhttp.MediaType.parse(contentType), content);
            } else {
                throw new io.nem.xpx.exceptions.ApiException("Content type \"" + contentType + "\" is not supported");
            }
        }

        /**
         * Download file from the given response.
         * 
         * @param {com.squareup.okhttp.Response} response An instance of the Response object
         * @return {java.io.File} Downloaded file
         * @throws ApiException If fail to read file content from response and write to disk
         */
        public downloadFileFromResponse(response : com.squareup.okhttp.Response) : java.io.File {
            try {
                let file : java.io.File = this.prepareDownloadFile(response);
                let sink : okio.BufferedSink = okio.Okio.buffer(okio.Okio.sink(file));
                sink.writeAll(response.body().source());
                sink.close();
                return file;
            } catch(e) {
                throw new io.nem.xpx.exceptions.ApiException(e);
            };
        }

        /**
         * Prepare file for download.
         * 
         * @param {com.squareup.okhttp.Response} response An instance of the Response object
         * @return {java.io.File} Prepared file for the download
         * @throws IOException If fail to prepare file for download
         */
        public prepareDownloadFile(response : com.squareup.okhttp.Response) : java.io.File {
            let filename : string = null;
            let contentDisposition : string = response.header("Content-Disposition");
            if(contentDisposition != null && !/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })("",contentDisposition))) {
                let pattern : java.util.regex.Pattern = java.util.regex.Pattern.compile("filename=[\'\"]?([^\'\"\\s]+)[\'\"]?");
                let matcher : java.util.regex.Matcher = pattern.matcher(contentDisposition);
                if(matcher.find()) {
                    filename = this.sanitizeFilename(matcher.group(1));
                }
            }
            let prefix : string = null;
            let suffix : string = null;
            if(filename == null) {
                prefix = "download-";
                suffix = "";
            } else {
                let pos : number = filename.lastIndexOf(".");
                if(pos === -1) {
                    prefix = filename + "-";
                } else {
                    prefix = filename.substring(0, pos) + "-";
                    suffix = filename.substring(pos);
                }
                if(prefix.length < 3) prefix = "download-";
            }
            if(this.tempFolderPath == null) return java.io.File.createTempFile(prefix, suffix); else return java.io.File.createTempFile(prefix, suffix, new java.io.File(this.tempFolderPath));
        }

        public execute<T>(call : com.squareup.okhttp.Call, returnType : java.lang.reflect.Type = null) : io.nem.ApiResponse<T> {
            try {
                let response : com.squareup.okhttp.Response = call.execute();
                let data : T = <any>(this.handleResponse<any>(response, returnType));
                return <any>(new io.nem.ApiResponse<T>(response.code(), response.headers().toMultimap(), data));
            } catch(e) {
                throw new io.nem.xpx.exceptions.ApiException(e);
            };
        }

        public executeAsync$com_squareup_okhttp_Call$io_nem_ApiCallback<T>(call : com.squareup.okhttp.Call, callback : io.nem.ApiCallback<T>) {
            this.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, null, callback);
        }

        public executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback<T>(call : com.squareup.okhttp.Call, returnType : java.lang.reflect.Type, callback : io.nem.ApiCallback<T>) {
            call.enqueue(new ApiClient.ApiClient$0(this, callback, returnType));
        }

        /**
         * Execute HTTP call asynchronously.
         * 
         * @param <T> Type
         * @param {com.squareup.okhttp.Call} call The callback to be executed when the API call finishes
         * @param {*} returnType Return type
         * @param {*} callback ApiCallback
         * @see #execute(Call, Type)
         */
        public executeAsync<T>(call? : any, returnType? : any, callback? : any) : any {
            if(((call != null && call instanceof <any>com.squareup.okhttp.Call) || call === null) && ((returnType != null && (returnType["__interfaces"] != null && returnType["__interfaces"].indexOf("java.lang.reflect.Type") >= 0 || returnType.constructor != null && returnType.constructor["__interfaces"] != null && returnType.constructor["__interfaces"].indexOf("java.lang.reflect.Type") >= 0)) || returnType === null) && ((callback != null && (callback["__interfaces"] != null && callback["__interfaces"].indexOf("io.nem.ApiCallback") >= 0 || callback.constructor != null && callback.constructor["__interfaces"] != null && callback.constructor["__interfaces"].indexOf("io.nem.ApiCallback") >= 0)) || callback === null)) {
                return <any>this.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, returnType, callback);
            } else if(((call != null && call instanceof <any>com.squareup.okhttp.Call) || call === null) && ((returnType != null && (returnType["__interfaces"] != null && returnType["__interfaces"].indexOf("io.nem.ApiCallback") >= 0 || returnType.constructor != null && returnType.constructor["__interfaces"] != null && returnType.constructor["__interfaces"].indexOf("io.nem.ApiCallback") >= 0)) || returnType === null) && callback === undefined) {
                return <any>this.executeAsync$com_squareup_okhttp_Call$io_nem_ApiCallback(call, returnType);
            } else throw new Error('invalid overload');
        }

        /**
         * Handle the given response, return the deserialized object when the response is successful.
         * 
         * @param <T> Type
         * @param {com.squareup.okhttp.Response} response Response
         * @param {*} returnType Return type
         * @return {*} Type
         * @throws ApiException If the response has a unsuccessful status code or
         * fail to deserialize the response body
         */
        public handleResponse<T>(response : com.squareup.okhttp.Response, returnType : java.lang.reflect.Type) : T {
            if(response.isSuccessful()) {
                if(returnType == null || response.code() === 204) {
                    if(response.body() != null) {
                        try {
                            response.body().close();
                        } catch(e) {
                            throw new io.nem.xpx.exceptions.ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                        };
                    }
                    return null;
                } else {
                    return <any>(this.deserialize<any>(response, returnType));
                }
            } else {
                let respBody : string = null;
                if(response.body() != null) {
                    try {
                        respBody = response.body().string();
                    } catch(e) {
                        throw new io.nem.xpx.exceptions.ApiException(response.message(), e, response.code(), response.headers().toMultimap());
                    };
                }
                throw new io.nem.xpx.exceptions.ApiException(response.message(), response.code(), response.headers().toMultimap(), respBody);
            }
        }

        /**
         * Build HTTP call with the given options.
         * 
         * @param {string} path The sub-path of the HTTP URL
         * @param {string} method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
         * @param {io.nem.Pair[]} queryParams The query parameters
         * @param {*} body The request body object
         * @param {*} headerParams The header parameters
         * @param {*} formParams The form parameters
         * @param {Array} authNames The authentications to apply
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} The HTTP call
         * @throws ApiException If fail to serialize the request body object
         */
        public buildCall(path : string, method : string, queryParams : Array<io.nem.Pair>, body : any, headerParams : any, formParams : any, authNames : string[], progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let request : com.squareup.okhttp.Request = this.buildRequest(path, method, queryParams, body, headerParams, formParams, authNames, progressRequestListener);
            return this.httpClient.newCall(request);
        }

        /**
         * Build an HTTP request with the given options.
         * 
         * @param {string} path The sub-path of the HTTP URL
         * @param {string} method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
         * @param {io.nem.Pair[]} queryParams The query parameters
         * @param {*} body The request body object
         * @param {*} headerParams The header parameters
         * @param {*} formParams The form parameters
         * @param {Array} authNames The authentications to apply
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Request} The HTTP request
         * @throws ApiException If fail to serialize the request body object
         */
        public buildRequest(path : string, method : string, queryParams : Array<io.nem.Pair>, body : any, headerParams : any, formParams : any, authNames : string[], progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Request {
            this.updateParamsForAuth(authNames, queryParams, headerParams);
            let url : string = this.buildUrl(path, queryParams);
            let reqBuilder : com.squareup.okhttp.Request.Builder = new com.squareup.okhttp.Request.Builder().url(url);
            this.processHeaderParams(headerParams, reqBuilder);
            let contentType : string = <string>/* get */((m,k) => m[k]===undefined?null:m[k])(headerParams, "Content-Type");
            if(contentType == null) {
                contentType = "application/json";
            }
            let reqBody : com.squareup.okhttp.RequestBody;
            if(!com.squareup.okhttp.internal.http.HttpMethod.permitsRequestBody(method)) {
                reqBody = null;
            } else if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })("application/x-www-form-urlencoded",contentType))) {
                reqBody = this.buildRequestBodyFormEncoding(formParams);
            } else if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })("multipart/form-data",contentType))) {
                reqBody = this.buildRequestBodyMultipart(formParams);
            } else if(body == null) {
                if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })("DELETE",method))) {
                    reqBody = null;
                } else {
                    reqBody = com.squareup.okhttp.RequestBody.create(com.squareup.okhttp.MediaType.parse(contentType), "");
                }
            } else {
                reqBody = this.serialize(body, contentType);
            }
            let request : com.squareup.okhttp.Request = null;
            if(progressRequestListener != null && reqBody != null) {
                let progressRequestBody : io.nem.ProgressRequestBody = new io.nem.ProgressRequestBody(reqBody, progressRequestListener);
                request = reqBuilder.method(method, progressRequestBody).build();
            } else {
                request = reqBuilder.method(method, reqBody).build();
            }
            return request;
        }

        /**
         * Build full URL by concatenating base path, the given sub path and query parameters.
         * 
         * @param {string} path The sub path
         * @param {io.nem.Pair[]} queryParams The query parameters
         * @return {string} The full URL
         */
        public buildUrl(path : string, queryParams : Array<io.nem.Pair>) : string {
            let url : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>path); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.basePath); return sb; })(url));
            if(queryParams != null && !/* isEmpty */(queryParams.length == 0)) {
                let prefix : string = /* contains */(path.indexOf("?") != -1)?"&":"?";
                for(let index137=0; index137 < queryParams.length; index137++) {
                    let param = queryParams[index137];
                    {
                        if(param.getValue() != null) {
                            if(prefix != null) {
                                /* append */(sb => { sb.str = sb.str.concat(<any>prefix); return sb; })(url);
                                prefix = null;
                            } else {
                                /* append */(sb => { sb.str = sb.str.concat(<any>"&"); return sb; })(url);
                            }
                            let value : string = this.parameterToString(param.getValue());
                            /* append */(sb => { sb.str = sb.str.concat(<any>this.escapeString(value)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"="); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.escapeString(param.getName())); return sb; })(url)));
                        }
                    }
                }
            }
            return /* toString */url.str;
        }

        /**
         * Set header parameters to the request builder, including default headers.
         * 
         * @param {*} headerParams Header parameters in the ofrm of Map
         * @param {com.squareup.okhttp.Request.Builder} reqBuilder Reqeust.Builder
         */
        public processHeaderParams(headerParams : any, reqBuilder : com.squareup.okhttp.Request.Builder) {
            {
                let array139 = /* entrySet */(o => { let s = []; for (let e in o) s.push({ k: e, v: o[e], getKey: function() { return this.k }, getValue: function() { return this.v } }); return s; })(headerParams);
                for(let index138=0; index138 < array139.length; index138++) {
                    let param = array139[index138];
                    {
                        reqBuilder.header(param.getKey(), this.parameterToString(param.getValue()));
                    }
                }
            }
            {
                let array141 = /* entrySet */(o => { let s = []; for (let e in o) s.push({ k: e, v: o[e], getKey: function() { return this.k }, getValue: function() { return this.v } }); return s; })(this.defaultHeaderMap);
                for(let index140=0; index140 < array141.length; index140++) {
                    let header = array141[index140];
                    {
                        if(!/* containsKey */headerParams.hasOwnProperty(header.getKey())) {
                            reqBuilder.header(header.getKey(), this.parameterToString(header.getValue()));
                        }
                    }
                }
            }
        }

        /**
         * Update query and header parameters based on authentication settings.
         * 
         * @param {Array} authNames The authentications to apply
         * @param {io.nem.Pair[]} queryParams  List of query parameters
         * @param {*} headerParams  Map of header parameters
         */
        public updateParamsForAuth(authNames : string[], queryParams : Array<io.nem.Pair>, headerParams : any) {
            for(let index142=0; index142 < authNames.length; index142++) {
                let authName = authNames[index142];
                {
                    let auth : io.nem.auth.Authentication = /* get */((m,k) => m[k]===undefined?null:m[k])(this.authentications, authName);
                    if(auth == null) throw Object.defineProperty(new Error("Authentication undefined: " + authName), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                    auth.applyToParams(queryParams, headerParams);
                }
            }
        }

        /**
         * Build a form-encoding request body with the given form parameters.
         * 
         * @param {*} formParams Form parameters in the form of Map
         * @return {com.squareup.okhttp.RequestBody} RequestBody
         */
        public buildRequestBodyFormEncoding(formParams : any) : com.squareup.okhttp.RequestBody {
            let formBuilder : com.squareup.okhttp.FormEncodingBuilder = new com.squareup.okhttp.FormEncodingBuilder();
            {
                let array144 = /* entrySet */(o => { let s = []; for (let e in o) s.push({ k: e, v: o[e], getKey: function() { return this.k }, getValue: function() { return this.v } }); return s; })(formParams);
                for(let index143=0; index143 < array144.length; index143++) {
                    let param = array144[index143];
                    {
                        formBuilder.add(param.getKey(), this.parameterToString(param.getValue()));
                    }
                }
            }
            return formBuilder.build();
        }

        /**
         * Build a multipart (file uploading) request body with the given form parameters,
         * which could contain text fields and file fields.
         * 
         * @param {*} formParams Form parameters in the form of Map
         * @return {com.squareup.okhttp.RequestBody} RequestBody
         */
        public buildRequestBodyMultipart(formParams : any) : com.squareup.okhttp.RequestBody {
            let mpBuilder : com.squareup.okhttp.MultipartBuilder = new com.squareup.okhttp.MultipartBuilder().type(com.squareup.okhttp.MultipartBuilder.FORM);
            {
                let array146 = /* entrySet */(o => { let s = []; for (let e in o) s.push({ k: e, v: o[e], getKey: function() { return this.k }, getValue: function() { return this.v } }); return s; })(formParams);
                for(let index145=0; index145 < array146.length; index145++) {
                    let param = array146[index145];
                    {
                        if(param.getValue() != null && param.getValue() instanceof <any>java.io.File) {
                            let file : java.io.File = <java.io.File>param.getValue();
                            let partHeaders : com.squareup.okhttp.Headers = com.squareup.okhttp.Headers.of("Content-Disposition", "form-data; name=\"" + param.getKey() + "\"; filename=\"" + file.getName() + "\"");
                            let mediaType : com.squareup.okhttp.MediaType = com.squareup.okhttp.MediaType.parse(this.guessContentTypeFromFile(file));
                            mpBuilder.addPart(partHeaders, com.squareup.okhttp.RequestBody.create(mediaType, file));
                        } else {
                            let partHeaders : com.squareup.okhttp.Headers = com.squareup.okhttp.Headers.of("Content-Disposition", "form-data; name=\"" + param.getKey() + "\"");
                            mpBuilder.addPart(partHeaders, com.squareup.okhttp.RequestBody.create(null, this.parameterToString(param.getValue())));
                        }
                    }
                }
            }
            return mpBuilder.build();
        }

        /**
         * Guess Content-Type header from the given file (defaults to "application/octet-stream").
         * 
         * @param {java.io.File} file The given file
         * @return {string} The guessed Content-Type
         */
        public guessContentTypeFromFile(file : java.io.File) : string {
            let contentType : string = java.net.URLConnection.guessContentTypeFromName(file.getName());
            if(contentType == null) {
                return "application/octet-stream";
            } else {
                return contentType;
            }
        }

        /**
         * Initialize datetime format according to the current environment, e.g. Java 1.7 and Android.
         * @private
         */
        /*private*/ initDatetimeFormat() {
            let formatWithTimeZone : string = null;
            if(ApiClient.IS_ANDROID_$LI$()) {
                if(ApiClient.ANDROID_SDK_VERSION_$LI$() >= 18) {
                    formatWithTimeZone = "yyyy-MM-dd\'T\'HH:mm:ss.SSSZZZZZ";
                }
            } else if(ApiClient.JAVA_VERSION_$LI$() >= 1.7) {
                formatWithTimeZone = "yyyy-MM-dd\'T\'HH:mm:ss.SSSXXX";
            }
            if(formatWithTimeZone != null) {
                this.datetimeFormat = new java.text.SimpleDateFormat(formatWithTimeZone);
            } else {
                this.datetimeFormat = new java.text.SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'");
                this.datetimeFormat.setTimeZone(/* getTimeZone */"UTC");
            }
        }

        /**
         * Apply SSL related settings to httpClient according to the current values of
         * verifyingSsl and sslCaCert.
         * @private
         */
        /*private*/ applySslSettings() {
            try {
                let trustManagers : javax.net.ssl.TrustManager[] = null;
                let hostnameVerifier : javax.net.ssl.HostnameVerifier = null;
                if(!this.verifyingSsl) {
                    let trustAll : javax.net.ssl.TrustManager = new ApiClient.ApiClient$1(this);
                    let sslContext : javax.net.ssl.SSLContext = javax.net.ssl.SSLContext.getInstance("TLS");
                    trustManagers = [trustAll];
                    hostnameVerifier = new ApiClient.ApiClient$2(this);
                } else if(this.sslCaCert != null) {
                    let password : string[] = null;
                    let certificateFactory : java.security.cert.CertificateFactory = java.security.cert.CertificateFactory.getInstance("X.509");
                    let certificates : Array<any> = certificateFactory.generateCertificates(this.sslCaCert);
                    if(/* isEmpty */(certificates.length == 0)) {
                        throw Object.defineProperty(new Error("expected non-empty set of trusted certificates"), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.IllegalArgumentException','java.lang.Exception'] });
                    }
                    let caKeyStore : java.security.KeyStore = this.newEmptyKeyStore(password);
                    let index : number = 0;
                    for(let index147=0; index147 < certificates.length; index147++) {
                        let certificate = certificates[index147];
                        {
                            let certificateAlias : string = "ca" + /* toString */(''+(index++));
                            caKeyStore.setCertificateEntry(certificateAlias, certificate);
                        }
                    }
                    let trustManagerFactory : javax.net.ssl.TrustManagerFactory = javax.net.ssl.TrustManagerFactory.getInstance(javax.net.ssl.TrustManagerFactory.getDefaultAlgorithm());
                    trustManagerFactory.init(caKeyStore);
                    trustManagers = trustManagerFactory.getTrustManagers();
                }
                if(this.keyManagers != null || trustManagers != null) {
                    let sslContext : javax.net.ssl.SSLContext = javax.net.ssl.SSLContext.getInstance("TLS");
                    sslContext.init(this.keyManagers, trustManagers, new java.security.SecureRandom());
                    this.httpClient.setSslSocketFactory(sslContext.getSocketFactory());
                } else {
                    this.httpClient.setSslSocketFactory(null);
                }
                this.httpClient.setHostnameVerifier(hostnameVerifier);
            } catch(e) {
                throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
            };
        }

        /**
         * New empty key store.
         * 
         * @param {Array} password the password
         * @return {java.security.KeyStore} the key store
         * @throws GeneralSecurityException the general security exception
         * @private
         */
        /*private*/ newEmptyKeyStore(password : string[]) : java.security.KeyStore {
            try {
                let keyStore : java.security.KeyStore = java.security.KeyStore.getInstance(java.security.KeyStore.getDefaultType());
                keyStore.load(null, password);
                return keyStore;
            } catch(e) {
                throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Error','java.lang.Object','java.lang.AssertionError'] });
            };
        }
    }
    ApiClient["__class"] = "io.nem.ApiClient";


    export namespace ApiClient {

        export class ApiClient$0 implements com.squareup.okhttp.Callback {
            public __parent: any;
            /**
             * 
             * @param {com.squareup.okhttp.Request} request
             * @param {Error} e
             */
            public onFailure(request : com.squareup.okhttp.Request, e : Error) {
                this.callback.onFailure(new io.nem.xpx.exceptions.ApiException(e), 0, null);
            }

            /**
             * 
             * @param {com.squareup.okhttp.Response} response
             */
            public onResponse(response : com.squareup.okhttp.Response) {
                let result : T;
                try {
                    result = <any>(this.__parent.handleResponse(response, this.returnType));
                } catch(e) {
                    this.callback.onFailure(e, response.code(), response.headers().toMultimap());
                    return;
                };
                this.callback.onSuccess(result, response.code(), response.headers().toMultimap());
            }

            constructor(__parent: any, private callback: any, private returnType: any) {
                this.__parent = __parent;
            }
        }
        ApiClient$0["__interfaces"] = ["com.squareup.okhttp.Callback"];



        export class ApiClient$1 implements javax.net.ssl.X509TrustManager {
            public __parent: any;
            /**
             * 
             * @param {Array} chain
             * @param {string} authType
             */
            public checkClientTrusted(chain : java.security.cert.X509Certificate[], authType : string) {
            }

            /**
             * 
             * @param {Array} chain
             * @param {string} authType
             */
            public checkServerTrusted(chain : java.security.cert.X509Certificate[], authType : string) {
            }

            /**
             * 
             * @return {Array}
             */
            public getAcceptedIssuers() : java.security.cert.X509Certificate[] {
                return null;
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }
        ApiClient$1["__interfaces"] = ["javax.net.ssl.X509TrustManager","javax.net.ssl.TrustManager"];



        export class ApiClient$2 implements javax.net.ssl.HostnameVerifier {
            public __parent: any;
            /**
             * 
             * @param {string} hostname
             * @param {*} session
             * @return {boolean}
             */
            public verify(hostname : string, session : javax.net.ssl.SSLSession) : boolean {
                return true;
            }

            constructor(__parent: any) {
                this.__parent = __parent;
            }
        }
        ApiClient$2["__interfaces"] = ["javax.net.ssl.HostnameVerifier"];


    }

}
namespace io.nem {
    /**
     * Instantiates a new api response.
     * 
     * @param {number} statusCode The status code of HTTP response
     * @param {*} headers The headers of HTTP response
     * @param {*} data The object deserialized from response bod
     * @class
     */
    export class ApiResponse<T> {
        /**
         * The status code.
         */
        /*private*/ statusCode : number;

        /**
         * The headers.
         */
        /*private*/ headers : any;

        /**
         * The data.
         */
        /*private*/ data : T;

        public constructor(statusCode? : any, headers? : any, data? : any) {
            if(((typeof statusCode === 'number') || statusCode === null) && ((headers != null && (headers instanceof Object)) || headers === null) && ((data != null) || data === null)) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.statusCode===undefined) this.statusCode = 0;
                if(this.headers===undefined) this.headers = null;
                if(this.data===undefined) this.data = null;
                if(this.statusCode===undefined) this.statusCode = 0;
                if(this.headers===undefined) this.headers = null;
                if(this.data===undefined) this.data = null;
                (() => {
                    this.statusCode = statusCode;
                    this.headers = headers;
                    this.data = data;
                })();
            } else if(((typeof statusCode === 'number') || statusCode === null) && ((headers != null && (headers instanceof Object)) || headers === null) && data === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                {
                    let __args = Array.prototype.slice.call(arguments);
                    let data : any = null;
                    if(this.statusCode===undefined) this.statusCode = 0;
                    if(this.headers===undefined) this.headers = null;
                    if(this.data===undefined) this.data = null;
                    if(this.statusCode===undefined) this.statusCode = 0;
                    if(this.headers===undefined) this.headers = null;
                    if(this.data===undefined) this.data = null;
                    (() => {
                        this.statusCode = statusCode;
                        this.headers = headers;
                        this.data = data;
                    })();
                }
            } else throw new Error('invalid overload');
        }

        /**
         * Gets the status code.
         * 
         * @return {number} the status code
         */
        public getStatusCode() : number {
            return this.statusCode;
        }

        /**
         * Gets the headers.
         * 
         * @return {*} the headers
         */
        public getHeaders() : any {
            return this.headers;
        }

        /**
         * Gets the data.
         * 
         * @return {*} the data
         */
        public getData() : T {
            return this.data;
        }
    }
    ApiResponse["__class"] = "io.nem.ApiResponse";

}
namespace io.nem.auth {
    /**
     * Instantiates a new api key auth.
     * 
     * @param {string} location the location
     * @param {string} paramName the param name
     * @class
     */
    export class ApiKeyAuth implements io.nem.auth.Authentication {
        /**
         * The location.
         */
        /*private*/ location : string;

        /**
         * The param name.
         */
        /*private*/ paramName : string;

        /**
         * The api key.
         */
        /*private*/ apiKey : string;

        /**
         * The api key prefix.
         */
        /*private*/ apiKeyPrefix : string;

        public constructor(location : string, paramName : string) {
            if(this.location===undefined) this.location = null;
            if(this.paramName===undefined) this.paramName = null;
            if(this.apiKey===undefined) this.apiKey = null;
            if(this.apiKeyPrefix===undefined) this.apiKeyPrefix = null;
            this.location = location;
            this.paramName = paramName;
        }

        /**
         * Gets the location.
         * 
         * @return {string} the location
         */
        public getLocation() : string {
            return this.location;
        }

        /**
         * Gets the param name.
         * 
         * @return {string} the param name
         */
        public getParamName() : string {
            return this.paramName;
        }

        /**
         * Gets the api key.
         * 
         * @return {string} the api key
         */
        public getApiKey() : string {
            return this.apiKey;
        }

        /**
         * Sets the api key.
         * 
         * @param {string} apiKey the new api key
         */
        public setApiKey(apiKey : string) {
            this.apiKey = apiKey;
        }

        /**
         * Gets the api key prefix.
         * 
         * @return {string} the api key prefix
         */
        public getApiKeyPrefix() : string {
            return this.apiKeyPrefix;
        }

        /**
         * Sets the api key prefix.
         * 
         * @param {string} apiKeyPrefix the new api key prefix
         */
        public setApiKeyPrefix(apiKeyPrefix : string) {
            this.apiKeyPrefix = apiKeyPrefix;
        }

        /**
         * 
         * @param {io.nem.Pair[]} queryParams
         * @param {*} headerParams
         */
        public applyToParams(queryParams : Array<io.nem.Pair>, headerParams : any) {
            if(this.apiKey == null) {
                return;
            }
            let value : string;
            if(this.apiKeyPrefix != null) {
                value = this.apiKeyPrefix + " " + this.apiKey;
            } else {
                value = this.apiKey;
            }
            if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })("query",this.location))) {
                /* add */(queryParams.push(new io.nem.Pair(this.paramName, value))>0);
            } else if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })("header",this.location))) {
                /* put */(headerParams[this.paramName] = value);
            }
        }
    }
    ApiKeyAuth["__class"] = "io.nem.auth.ApiKeyAuth";
    ApiKeyAuth["__interfaces"] = ["io.nem.auth.Authentication"];


}
namespace io.nem.auth {
    /**
     * The Interface Authentication.
     * @class
     */
    export interface Authentication {
        /**
         * Apply authentication settings to header and query params.
         * 
         * @param {io.nem.Pair[]} queryParams List of query parameters
         * @param {*} headerParams Map of header parameters
         */
        applyToParams(queryParams : Array<io.nem.Pair>, headerParams : any);
    }
}
namespace io.nem.auth {
    /**
     * The Class HttpBasicAuth.
     * @class
     */
    export class HttpBasicAuth implements io.nem.auth.Authentication {
        /**
         * The username.
         */
        /*private*/ username : string;

        /**
         * The password.
         */
        /*private*/ password : string;

        /**
         * Gets the username.
         * 
         * @return {string} the username
         */
        public getUsername() : string {
            return this.username;
        }

        /**
         * Sets the username.
         * 
         * @param {string} username the new username
         */
        public setUsername(username : string) {
            this.username = username;
        }

        /**
         * Gets the password.
         * 
         * @return {string} the password
         */
        public getPassword() : string {
            return this.password;
        }

        /**
         * Sets the password.
         * 
         * @param {string} password the new password
         */
        public setPassword(password : string) {
            this.password = password;
        }

        /**
         * 
         * @param {io.nem.Pair[]} queryParams
         * @param {*} headerParams
         */
        public applyToParams(queryParams : Array<io.nem.Pair>, headerParams : any) {
            if(this.username == null && this.password == null) {
                return;
            }
            /* put */(headerParams["Authorization"] = com.squareup.okhttp.Credentials.basic(this.username == null?"":this.username, this.password == null?"":this.password));
        }

        constructor() {
            if(this.username===undefined) this.username = null;
            if(this.password===undefined) this.password = null;
        }
    }
    HttpBasicAuth["__class"] = "io.nem.auth.HttpBasicAuth";
    HttpBasicAuth["__interfaces"] = ["io.nem.auth.Authentication"];


}
namespace io.nem.auth {
    /**
     * The Class OAuth.
     * @class
     */
    export class OAuth implements io.nem.auth.Authentication {
        /**
         * The access token.
         */
        /*private*/ accessToken : string;

        /**
         * Gets the access token.
         * 
         * @return {string} the access token
         */
        public getAccessToken() : string {
            return this.accessToken;
        }

        /**
         * Sets the access token.
         * 
         * @param {string} accessToken the new access token
         */
        public setAccessToken(accessToken : string) {
            this.accessToken = accessToken;
        }

        /**
         * 
         * @param {io.nem.Pair[]} queryParams
         * @param {*} headerParams
         */
        public applyToParams(queryParams : Array<io.nem.Pair>, headerParams : any) {
            if(this.accessToken != null) {
                /* put */(headerParams["Authorization"] = "Bearer " + this.accessToken);
            }
        }

        constructor() {
            if(this.accessToken===undefined) this.accessToken = null;
        }
    }
    OAuth["__class"] = "io.nem.auth.OAuth";
    OAuth["__interfaces"] = ["io.nem.auth.Authentication"];


}
namespace io.nem.auth {
    /**
     * The Enum OAuthFlow.
     * @enum
     * @property {io.nem.auth.OAuthFlow} accessCode
     * The access code.
     * @property {io.nem.auth.OAuthFlow} implicit
     * The implicit.
     * @property {io.nem.auth.OAuthFlow} password
     * The password.
     * @property {io.nem.auth.OAuthFlow} application
     * The application.
     * @class
     */
    export enum OAuthFlow {
        
        /**
         * The access code.
         */
        accessCode, 
        /**
         * The implicit.
         */
        implicit, 
        /**
         * The password.
         */
        password, 
        /**
         * The application.
         */
        application
    }
}
namespace io.nem {
    /**
     * Encodes request bodies using gzip.
     * 
     * Taken from https://github.com/square/okhttp/issues/350
     * @class
     */
    export class GzipRequestInterceptor implements com.squareup.okhttp.Interceptor {
        /**
         * 
         * @param {*} chain
         * @return {com.squareup.okhttp.Response}
         */
        public intercept(chain : Interceptor.Chain) : com.squareup.okhttp.Response {
            let originalRequest : com.squareup.okhttp.Request = chain.request();
            if(originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
                return chain.proceed(originalRequest);
            }
            let compressedRequest : com.squareup.okhttp.Request = originalRequest.newBuilder().header("Content-Encoding", "gzip").method(originalRequest.method(), this.forceContentLength(this.gzip(originalRequest.body()))).build();
            return chain.proceed(compressedRequest);
        }

        /**
         * Force content length.
         * 
         * @param {com.squareup.okhttp.RequestBody} requestBody the request body
         * @return {com.squareup.okhttp.RequestBody} the request body
         * @throws IOException Signals that an I/O exception has occurred.
         * @private
         */
        /*private*/ forceContentLength(requestBody : com.squareup.okhttp.RequestBody) : com.squareup.okhttp.RequestBody {
            let buffer : okio.Buffer = new okio.Buffer();
            requestBody.writeTo(buffer);
            return new GzipRequestInterceptor.GzipRequestInterceptor$0(this, requestBody, buffer);
        }

        /**
         * Gzip.
         * 
         * @param {com.squareup.okhttp.RequestBody} body the body
         * @return {com.squareup.okhttp.RequestBody} the request body
         * @private
         */
        /*private*/ gzip(body : com.squareup.okhttp.RequestBody) : com.squareup.okhttp.RequestBody {
            return new GzipRequestInterceptor.GzipRequestInterceptor$1(this, body);
        }

        constructor() {
        }
    }
    GzipRequestInterceptor["__class"] = "io.nem.GzipRequestInterceptor";
    GzipRequestInterceptor["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



    export namespace GzipRequestInterceptor {

        export class GzipRequestInterceptor$0 extends com.squareup.okhttp.RequestBody {
            public __parent: any;
            /**
             * 
             * @return {com.squareup.okhttp.MediaType}
             */
            public contentType() : com.squareup.okhttp.MediaType {
                return this.requestBody.contentType();
            }

            /**
             * 
             * @return {number}
             */
            public contentLength() : number {
                return this.buffer.size();
            }

            /**
             * 
             * @param {*} sink
             */
            public writeTo(sink : okio.BufferedSink) {
                sink.write(this.buffer.snapshot());
            }

            constructor(__parent: any, private requestBody: any, private buffer: any) {
                super();
                this.__parent = __parent;
            }
        }


        export class GzipRequestInterceptor$1 extends com.squareup.okhttp.RequestBody {
            public __parent: any;
            /**
             * 
             * @return {com.squareup.okhttp.MediaType}
             */
            public contentType() : com.squareup.okhttp.MediaType {
                return this.body.contentType();
            }

            /**
             * 
             * @return {number}
             */
            public contentLength() : number {
                return -1;
            }

            /**
             * 
             * @param {*} sink
             */
            public writeTo(sink : okio.BufferedSink) {
                let gzipSink : okio.BufferedSink = okio.Okio.buffer(new okio.GzipSink(sink));
                this.body.writeTo(gzipSink);
                gzipSink.close();
            }

            constructor(__parent: any, private body: any) {
                super();
                this.__parent = __parent;
            }
        }

    }

}
namespace io.nem {
    /**
     * JSON constructor.
     * 
     * @param {io.nem.ApiClient} apiClient An instance of ApiClient
     * @class
     */
    export class JSON {
        /**
         * The api client.
         */
        /*private*/ apiClient : io.nem.ApiClient;

        /**
         * The gson.
         */
        /*private*/ gson : com.google.gson.Gson;

        public constructor(apiClient : io.nem.ApiClient) {
            if(this.apiClient===undefined) this.apiClient = null;
            if(this.gson===undefined) this.gson = null;
            this.apiClient = apiClient;
            this.gson = new com.google.gson.GsonBuilder().registerTypeAdapter(Date, new io.nem.DateAdapter(apiClient)).registerTypeAdapter(org.joda.time.DateTime, new io.nem.DateTimeTypeAdapter()).registerTypeAdapter(org.joda.time.LocalDate, new io.nem.LocalDateTypeAdapter()).create();
        }

        /**
         * Get Gson.
         * 
         * @return {com.google.gson.Gson} Gson
         */
        public getGson() : com.google.gson.Gson {
            return this.gson;
        }

        /**
         * Set Gson.
         * 
         * @param {com.google.gson.Gson} gson Gson
         */
        public setGson(gson : com.google.gson.Gson) {
            this.gson = gson;
        }

        /**
         * Serialize the given Java object into JSON string.
         * 
         * @param {*} obj Object
         * @return {string} String representation of the JSON
         */
        public serialize(obj : any) : string {
            return this.gson.toJson(obj);
        }

        /**
         * Deserialize the given JSON string to Java object.
         * 
         * @param <T> Type
         * @param {string} body The JSON string
         * @param {*} returnType The type to deserialize into
         * @return {*} The deserialized Java object
         */
        public deserialize<T>(body : string, returnType : java.lang.reflect.Type) : T {
            try {
                if(this.apiClient.isLenientOnJson()) {
                    let jsonReader : com.google.gson.stream.JsonReader = new com.google.gson.stream.JsonReader({ str: body, cursor: 0 });
                    jsonReader.setLenient(true);
                    return <any>(this.gson.fromJson<any>(jsonReader, returnType));
                } else {
                    return <any>(this.gson.fromJson<any>(body, returnType));
                }
            } catch(e) {
                if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(returnType,String))) return <T><any>body; else if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(returnType,Date))) return <T><any>this.apiClient.parseDateOrDatetime(body); else throw (e);
            };
        }
    }
    JSON["__class"] = "io.nem.JSON";


    /**
     * Constructor for DateAdapter
     * 
     * @param {io.nem.ApiClient} apiClient Api client
     * @class
     */
    export class DateAdapter implements com.google.gson.JsonSerializer<Date>, com.google.gson.JsonDeserializer<Date> {
        /*private*/ apiClient : io.nem.ApiClient;

        public constructor(apiClient : io.nem.ApiClient) {
            if(this.apiClient===undefined) this.apiClient = null;
            this.apiClient = apiClient;
        }

        /**
         * Serialize
         * 
         * @param {java.util.Date} src Date
         * @param {*} typeOfSrc Type
         * @param {*} context Json Serialization Context
         * @return {com.google.gson.JsonElement} Json Element
         */
        public serialize(src : Date, typeOfSrc : java.lang.reflect.Type, context : com.google.gson.JsonSerializationContext) : com.google.gson.JsonElement {
            if(src == null) {
                return com.google.gson.JsonNull.INSTANCE;
            } else {
                return new com.google.gson.JsonPrimitive(this.apiClient.formatDatetime(src));
            }
        }

        /**
         * Deserialize
         * 
         * @param {com.google.gson.JsonElement} json Json element
         * @param {*} date Type
         * @param {*} context Json Serialization Context
         * @return {java.util.Date} Date
         * @throws JsonParseException if fail to parse
         */
        public deserialize(json : com.google.gson.JsonElement, date : java.lang.reflect.Type, context : com.google.gson.JsonDeserializationContext) : Date {
            let str : string = json.getAsJsonPrimitive().getAsString();
            try {
                return this.apiClient.parseDateOrDatetime(str);
            } catch(e) {
                throw new com.google.gson.JsonParseException(e);
            };
        }
    }
    DateAdapter["__class"] = "io.nem.DateAdapter";
    DateAdapter["__interfaces"] = ["com.google.gson.JsonDeserializer","com.google.gson.JsonSerializer"];



    /**
     * Gson TypeAdapter for Joda DateTime type
     * @extends com.google.gson.TypeAdapter
     * @class
     */
    export class DateTimeTypeAdapter extends com.google.gson.TypeAdapter<org.joda.time.DateTime> {
        /*private*/ parseFormatter : org.joda.time.format.DateTimeFormatter = org.joda.time.format.ISODateTimeFormat.dateOptionalTimeParser();

        /*private*/ printFormatter : org.joda.time.format.DateTimeFormatter = org.joda.time.format.ISODateTimeFormat.dateTime();

        /**
         * 
         * @param {com.google.gson.stream.JsonWriter} out
         * @param {org.joda.time.DateTime} date
         */
        public write(out : com.google.gson.stream.JsonWriter, date : org.joda.time.DateTime) {
            if(date == null) {
                out.nullValue();
            } else {
                out.value(this.printFormatter.print(date));
            }
        }

        /**
         * 
         * @param {com.google.gson.stream.JsonReader} in
         * @return {org.joda.time.DateTime}
         */
        public read(__in : com.google.gson.stream.JsonReader) : org.joda.time.DateTime {
            switch((__in.peek())) {
            case com.google.gson.stream.JsonToken.NULL:
                __in.nextNull();
                return null;
            default:
                let date : string = __in.nextString();
                return this.parseFormatter.parseDateTime(date);
            }
        }
    }
    DateTimeTypeAdapter["__class"] = "io.nem.DateTimeTypeAdapter";


    /**
     * Gson TypeAdapter for Joda LocalDate type
     * @extends com.google.gson.TypeAdapter
     * @class
     */
    export class LocalDateTypeAdapter extends com.google.gson.TypeAdapter<org.joda.time.LocalDate> {
        /*private*/ formatter : org.joda.time.format.DateTimeFormatter = org.joda.time.format.ISODateTimeFormat.date();

        /**
         * 
         * @param {com.google.gson.stream.JsonWriter} out
         * @param {org.joda.time.LocalDate} date
         */
        public write(out : com.google.gson.stream.JsonWriter, date : org.joda.time.LocalDate) {
            if(date == null) {
                out.nullValue();
            } else {
                out.value(this.formatter.print(date));
            }
        }

        /**
         * 
         * @param {com.google.gson.stream.JsonReader} in
         * @return {org.joda.time.LocalDate}
         */
        public read(__in : com.google.gson.stream.JsonReader) : org.joda.time.LocalDate {
            switch((__in.peek())) {
            case com.google.gson.stream.JsonToken.NULL:
                __in.nextNull();
                return null;
            default:
                let date : string = __in.nextString();
                return this.formatter.parseLocalDate(date);
            }
        }
    }
    LocalDateTypeAdapter["__class"] = "io.nem.LocalDateTypeAdapter";

}
namespace io.nem {
    /**
     * Instantiates a new pair.
     * 
     * @param {string} name the name
     * @param {string} value the value
     * @class
     */
    export class Pair {
        /**
         * The name.
         */
        /*private*/ name : string = "";

        /**
         * The value.
         */
        /*private*/ value : string = "";

        public constructor(name : string, value : string) {
            this.setName(name);
            this.setValue(value);
        }

        /**
         * Sets the name.
         * 
         * @param {string} name the new name
         * @private
         */
        /*private*/ setName(name : string) {
            if(!this.isValidString(name)) return;
            this.name = name;
        }

        /**
         * Sets the value.
         * 
         * @param {string} value the new value
         * @private
         */
        /*private*/ setValue(value : string) {
            if(!this.isValidString(value)) return;
            this.value = value;
        }

        /**
         * Gets the name.
         * 
         * @return {string} the name
         */
        public getName() : string {
            return this.name;
        }

        /**
         * Gets the value.
         * 
         * @return {string} the value
         */
        public getValue() : string {
            return this.value;
        }

        /**
         * Checks if is valid string.
         * 
         * @param {string} arg the arg
         * @return {boolean} true, if is valid string
         * @private
         */
        /*private*/ isValidString(arg : string) : boolean {
            if(arg == null) return false;
            if(/* isEmpty */(arg.trim().length === 0)) return false;
            return true;
        }
    }
    Pair["__class"] = "io.nem.Pair";

}
namespace io.nem {
    /**
     * Instantiates a new progress request body.
     * 
     * @param {com.squareup.okhttp.RequestBody} requestBody the request body
     * @param {*} progressListener the progress listener
     * @class
     * @extends com.squareup.okhttp.RequestBody
     */
    export class ProgressRequestBody extends com.squareup.okhttp.RequestBody {
        /**
         * The request body.
         */
        /*private*/ requestBody : com.squareup.okhttp.RequestBody;

        /**
         * The progress listener.
         */
        /*private*/ progressListener : ProgressRequestBody.ProgressRequestListener;

        public constructor(requestBody : com.squareup.okhttp.RequestBody, progressListener : ProgressRequestBody.ProgressRequestListener) {
            super();
            if(this.requestBody===undefined) this.requestBody = null;
            if(this.progressListener===undefined) this.progressListener = null;
            this.requestBody = requestBody;
            this.progressListener = progressListener;
        }

        /**
         * 
         * @return {com.squareup.okhttp.MediaType}
         */
        public contentType() : com.squareup.okhttp.MediaType {
            return this.requestBody.contentType();
        }

        /**
         * 
         * @return {number}
         */
        public contentLength() : number {
            return this.requestBody.contentLength();
        }

        /**
         * 
         * @param {*} sink
         */
        public writeTo(sink : okio.BufferedSink) {
            let bufferedSink : okio.BufferedSink = okio.Okio.buffer(this.sink(sink));
            this.requestBody.writeTo(bufferedSink);
            bufferedSink.flush();
        }

        /**
         * Sink.
         * 
         * @param {*} sink the sink
         * @return {*} the sink
         * @private
         */
        sink(sink : okio.Sink) : okio.Sink {
            return new ProgressRequestBody.ProgressRequestBody$0(this, sink);
        }
    }
    ProgressRequestBody["__class"] = "io.nem.ProgressRequestBody";


    export namespace ProgressRequestBody {

        /**
         * The listener interface for receiving progressRequest events.
         * The class that is interested in processing a progressRequest
         * event implements this interface, and the object created
         * with that class is registered with a component using the
         * component's <code>addProgressRequestListener</code> method. When
         * the progressRequest event occurs, that object's appropriate
         * method is invoked.
         * @class
         */
        export interface ProgressRequestListener {
            /**
             * On request progress.
             * 
             * @param {number} bytesWritten the bytes written
             * @param {number} contentLength the content length
             * @param {boolean} done the done
             */
            onRequestProgress(bytesWritten : number, contentLength : number, done : boolean);
        }

        export class ProgressRequestBody$0 extends okio.ForwardingSink {
            public __parent: any;
            bytesWritten : number;

            contentLength : number;

            /**
             * 
             * @param {okio.Buffer} source
             * @param {number} byteCount
             */
            public write(source : okio.Buffer, byteCount : number) {
                super.write(source, byteCount);
                if(this.contentLength === 0) {
                    this.contentLength = this.__parent.contentLength();
                }
                this.bytesWritten += byteCount;
                this.__parent.progressListener.onRequestProgress(this.bytesWritten, this.contentLength, this.bytesWritten === this.contentLength);
            }

            constructor(__parent: any, __arg0: any) {
                super(__arg0);
                this.__parent = __parent;
                this.bytesWritten = 0;
                this.contentLength = 0;
            }
        }
        ProgressRequestBody$0["__interfaces"] = ["java.io.Closeable","java.lang.AutoCloseable","okio.Sink","java.io.Flushable"];


    }

}
namespace io.nem {
    /**
     * Instantiates a new progress response body.
     * 
     * @param {com.squareup.okhttp.ResponseBody} responseBody the response body
     * @param {*} progressListener the progress listener
     * @class
     * @extends com.squareup.okhttp.ResponseBody
     */
    export class ProgressResponseBody extends com.squareup.okhttp.ResponseBody {
        /**
         * The response body.
         */
        /*private*/ responseBody : com.squareup.okhttp.ResponseBody;

        /**
         * The progress listener.
         */
        /*private*/ progressListener : ProgressResponseBody.ProgressListener;

        /**
         * The buffered source.
         */
        /*private*/ bufferedSource : okio.BufferedSource;

        public constructor(responseBody : com.squareup.okhttp.ResponseBody, progressListener : ProgressResponseBody.ProgressListener) {
            super();
            if(this.responseBody===undefined) this.responseBody = null;
            if(this.progressListener===undefined) this.progressListener = null;
            if(this.bufferedSource===undefined) this.bufferedSource = null;
            this.responseBody = responseBody;
            this.progressListener = progressListener;
        }

        /**
         * 
         * @return {com.squareup.okhttp.MediaType}
         */
        public contentType() : com.squareup.okhttp.MediaType {
            return this.responseBody.contentType();
        }

        /**
         * 
         * @return {number}
         */
        public contentLength() : number {
            return this.responseBody.contentLength();
        }

        public source$() : okio.BufferedSource {
            if(this.bufferedSource == null) {
                this.bufferedSource = okio.Okio.buffer(this.source$okio_Source(this.responseBody.source()));
            }
            return this.bufferedSource;
        }

        public source$okio_Source(source : okio.Source) : okio.Source {
            return new ProgressResponseBody.ProgressResponseBody$0(this, source);
        }

        /**
         * Source.
         * 
         * @param {*} source the source
         * @return {*} the source
         * @private
         */
        public source(source? : any) : any {
            if(((source != null && (source["__interfaces"] != null && source["__interfaces"].indexOf("okio.Source") >= 0 || source.constructor != null && source.constructor["__interfaces"] != null && source.constructor["__interfaces"].indexOf("okio.Source") >= 0)) || source === null)) {
                return <any>this.source$okio_Source(source);
            } else if(source === undefined) {
                return <any>this.source$();
            } else throw new Error('invalid overload');
        }
    }
    ProgressResponseBody["__class"] = "io.nem.ProgressResponseBody";
    ProgressResponseBody["__interfaces"] = ["java.io.Closeable","java.lang.AutoCloseable"];



    export namespace ProgressResponseBody {

        /**
         * The listener interface for receiving progress events.
         * The class that is interested in processing a progress
         * event implements this interface, and the object created
         * with that class is registered with a component using the
         * component's <code>addProgressListener</code> method. When
         * the progress event occurs, that object's appropriate
         * method is invoked.
         * @class
         */
        export interface ProgressListener {
            /**
             * Update.
             * 
             * @param {number} bytesRead the bytes read
             * @param {number} contentLength the content length
             * @param {boolean} done the done
             */
            update(bytesRead : number, contentLength : number, done : boolean);
        }

        export class ProgressResponseBody$0 extends okio.ForwardingSource {
            public __parent: any;
            totalBytesRead : number;

            /**
             * 
             * @param {okio.Buffer} sink
             * @param {number} byteCount
             * @return {number}
             */
            public read(sink : okio.Buffer, byteCount : number) : number {
                let bytesRead : number = super.read(sink, byteCount);
                this.totalBytesRead += bytesRead !== -1?bytesRead:0;
                this.__parent.progressListener.update(this.totalBytesRead, this.__parent.responseBody.contentLength(), bytesRead === -1);
                return bytesRead;
            }

            constructor(__parent: any, __arg0: any) {
                super(__arg0);
                this.__parent = __parent;
                this.totalBytesRead = 0;
            }
        }
        ProgressResponseBody$0["__interfaces"] = ["okio.Source","java.io.Closeable","java.lang.AutoCloseable"];


    }

}
namespace io.nem {
    /**
     * The Class StringUtil.
     * @class
     */
    export class StringUtil {
        /**
         * Check if the given array contains the given value (with case-insensitive comparison).
         * 
         * @param {Array} array The array
         * @param {string} value The value to search
         * @return {boolean} true if the array contains the value
         */
        public static containsIgnoreCase(array : string[], value : string) : boolean {
            for(let index148=0; index148 < array.length; index148++) {
                let str = array[index148];
                {
                    if(value == null && str == null) return true;
                    if(value != null && /* equalsIgnoreCase */((o1, o2) => o1.toUpperCase() === (o2===null?o2:o2.toUpperCase()))(value, str)) return true;
                }
            }
            return false;
        }

        /**
         * Join an array of strings with the given separator.
         * <p>
         * Note: This might be replaced by utility method from commons-lang or guava someday
         * if one of those libraries is added as dependency.
         * </p>
         * 
         * @param {Array} array     The array of strings
         * @param {string} separator The separator
         * @return {string} the resulting string
         */
        public static join(array : string[], separator : string) : string {
            let len : number = array.length;
            if(len === 0) return "";
            let out : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>array[0]); return sb; })(out);
            for(let i : number = 1; i < len; i++) {
                /* append */(sb => { sb.str = sb.str.concat(<any>array[i]); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>separator); return sb; })(out));
            };
            return /* toString */out.str;
        }
    }
    StringUtil["__class"] = "io.nem.StringUtil";

}
namespace io.nem.xpx.adapters.cipher {
    /**
     * The Interface CustomEncryption.
     * @class
     */
    export interface CustomEncryption {    }
}
namespace io.nem.xpx.adapters.cipher {
    /**
     * The Class SymmetricKeyEncryption.
     * @class
     */
    export abstract class SymmetricKeyEncryption implements io.nem.xpx.adapters.cipher.CustomEncryption {
        /**
         * Encrypt.
         * 
         * @param {Array} data the data
         * @param {Array} key the key
         * @return {Array} the byte[]
         * @throws InvalidKeySpecException the invalid key spec exception
         * @throws NoSuchAlgorithmException the no such algorithm exception
         * @throws NoSuchPaddingException the no such padding exception
         * @throws InvalidKeyException the invalid key exception
         * @throws InvalidAlgorithmParameterException the invalid algorithm parameter exception
         * @throws IllegalBlockSizeException the illegal block size exception
         * @throws BadPaddingException the bad padding exception
         */
        public abstract encrypt(data : number[], key : string[]) : number[];

        /**
         * Decrypt.
         * 
         * @param {Array} data the data
         * @param {Array} key the key
         * @return {Array} the byte[]
         * @throws InvalidKeyException the invalid key exception
         * @throws InvalidAlgorithmParameterException the invalid algorithm parameter exception
         * @throws IllegalBlockSizeException the illegal block size exception
         * @throws BadPaddingException the bad padding exception
         * @throws InvalidKeySpecException the invalid key spec exception
         * @throws NoSuchAlgorithmException the no such algorithm exception
         * @throws NoSuchPaddingException the no such padding exception
         */
        public abstract decrypt(data : number[], key : string[]) : number[];

        constructor() {
        }
    }
    SymmetricKeyEncryption["__class"] = "io.nem.xpx.adapters.cipher.SymmetricKeyEncryption";
    SymmetricKeyEncryption["__interfaces"] = ["io.nem.xpx.adapters.cipher.CustomEncryption"];


}
namespace io.nem.xpx.builder {
    /**
     * The Class MultisigTransactionBuilder.
     * @class
     */
    export class MultisigSignatureTransactionBuilder {
        constructor() {
        }

        /**
         * PeerConnection.
         * 
         * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection
         * the peer connection
         * @return {*} the i peer connection
         */
        public static peerConnection(peerConnection : io.nem.xpx.facade.connection.PeerConnection) : MultisigSignatureTransactionBuilder.IPeerConnection {
            return new MultisigSignatureTransactionBuilder.Builder(peerConnection);
        }
    }
    MultisigSignatureTransactionBuilder["__class"] = "io.nem.xpx.builder.MultisigSignatureTransactionBuilder";


    export namespace MultisigSignatureTransactionBuilder {

        /**
         * The Interface ISender.
         * @class
         */
        export interface IPeerConnection {
            /**
             * Sender.
             * 
             * @param {org.nem.core.model.Account} multisig
             * the sender
             * @return {*} the i sender
             */
            multisig(multisig : org.nem.core.model.Account) : MultisigSignatureTransactionBuilder.ISigner;
        }

        /**
         * The Interface ISigner.
         * @class
         */
        export interface ISigner {
            /**
             * Signer.
             * 
             * @param {org.nem.core.model.Account} signer
             * the signer
             * @return {*} the i transaction
             */
            signer(signer : org.nem.core.model.Account) : MultisigSignatureTransactionBuilder.ITransaction;

            /**
             * Start assign signers.
             * 
             * @return {*} the i signer
             */
            startAssignSigners() : MultisigSignatureTransactionBuilder.ISigner;

            /**
             * Adds the signer.
             * 
             * @param {org.nem.core.model.Account} signer
             * the signer
             * @return {*} the i signer
             */
            addSigner(signer : org.nem.core.model.Account) : MultisigSignatureTransactionBuilder.ISigner;

            /**
             * Adds the signers.
             * 
             * @param {org.nem.core.model.Account[]} signers
             * the signers
             * @return {*} the i signer
             */
            addSigners(signers : Array<org.nem.core.model.Account>) : MultisigSignatureTransactionBuilder.ITransaction;

            /**
             * End assign signers.
             * 
             * @return {*} the i transaction
             */
            endAssignSigners() : MultisigSignatureTransactionBuilder.ITransaction;
        }

        /**
         * The Interface ITransaction.
         * @class
         */
        export interface ITransaction {
            /**
             * Other transaction.
             * 
             * @param {org.nem.core.model.Transaction} transaction
             * the transaction
             * @return {*} the i build
             */
            otherTransaction(transaction? : any) : any;
        }

        /**
         * The Interface IBuild.
         * @class
         */
        export interface IBuild {
            /**
             * Time stamp.
             * 
             * @param {org.nem.core.time.TimeInstant} timeInstance
             * the time instance
             * @return {*} the i build
             */
            timeStamp(timeInstance : org.nem.core.time.TimeInstant) : MultisigSignatureTransactionBuilder.IBuild;

            /**
             * Sign by.
             * 
             * @param {org.nem.core.model.Account} account
             * the account
             * @return {*} the i build
             */
            signBy(account : org.nem.core.model.Account) : MultisigSignatureTransactionBuilder.IBuild;

            /**
             * Fee.
             * 
             * @param {org.nem.core.model.primitive.Amount} amount
             * the amount
             * @return {*} the i build
             */
            fee(amount : org.nem.core.model.primitive.Amount) : MultisigSignatureTransactionBuilder.IBuild;

            /**
             * Fee calculator.
             * 
             * @param {*} feeCalculator
             * the fee calculator
             * @return {*} the i build
             */
            feeCalculator(feeCalculator : org.nem.core.model.TransactionFeeCalculator) : MultisigSignatureTransactionBuilder.IBuild;

            /**
             * Deadline.
             * 
             * @param {org.nem.core.time.TimeInstant} timeInstant
             * the time instant
             * @return {*} the i build
             */
            deadline(timeInstant : org.nem.core.time.TimeInstant) : MultisigSignatureTransactionBuilder.IBuild;

            /**
             * Signature.
             * 
             * @param {org.nem.core.crypto.Signature} signature
             * the signature
             * @return {*} the i build
             */
            signature(signature : org.nem.core.crypto.Signature) : MultisigSignatureTransactionBuilder.IBuild;

            /**
             * Co sign.
             * 
             * @return {org.nem.core.model.MultisigSignatureTransaction} the multisig signature transaction
             * @throws ApiException the api exception
             */
            coSign() : org.nem.core.model.MultisigSignatureTransaction;

            /**
             * Co sign future.
             * 
             * @return {java.util.concurrent.CompletableFuture} the completable future
             * @throws ApiException the api exception
             */
            coSignFuture() : java.util.concurrent.CompletableFuture<org.nem.core.serialization.Deserializer>;
        }

        /**
         * Instantiates a new builder.
         * 
         * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection
         * the peerConnection
         * @class
         */
        export class Builder implements MultisigSignatureTransactionBuilder.IPeerConnection, MultisigSignatureTransactionBuilder.ISigner, MultisigSignatureTransactionBuilder.ITransaction, MultisigSignatureTransactionBuilder.IBuild {
            /**
             * 
             * @return {*}
             */
            public startAssignSigners() : MultisigSignatureTransactionBuilder.ISigner {
                return this;
            }

            /**
             * 
             * @return {*}
             */
            public endAssignSigners() : MultisigSignatureTransactionBuilder.ITransaction {
                return this;
            }

            /**
             * The instance.
             */
            instance : org.nem.core.model.MultisigSignatureTransaction;

            /**
             * The peer connection.
             */
            peerConnection : io.nem.xpx.facade.connection.PeerConnection;

            /**
             * The time stamp.
             */
            __timeStamp : org.nem.core.time.TimeInstant;

            /**
             * The multisig.
             */
            __multisig : org.nem.core.model.Account;

            /**
             * The other transaction.
             */
            __otherTransaction : org.nem.core.model.Transaction;

            /**
             * The hash transaction.
             */
            hashTransaction : org.nem.core.crypto.Hash;

            /**
             * The signature.
             */
            __signature : org.nem.core.crypto.Signature;

            /**
             * The fee.
             */
            __fee : org.nem.core.model.primitive.Amount;

            /**
             * The fee calculator.
             */
            __feeCalculator : org.nem.core.model.TransactionFeeCalculator;

            /**
             * The sign by.
             */
            __signBy : org.nem.core.model.Account;

            /**
             * The deadline.
             */
            __deadline : org.nem.core.time.TimeInstant;

            /**
             * The signers.
             */
            signers : Array<org.nem.core.model.Account> = <any>([]);

            public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection) {
                if(this.instance===undefined) this.instance = null;
                if(this.peerConnection===undefined) this.peerConnection = null;
                if(this.__timeStamp===undefined) this.__timeStamp = null;
                if(this.__multisig===undefined) this.__multisig = null;
                if(this.__otherTransaction===undefined) this.__otherTransaction = null;
                if(this.hashTransaction===undefined) this.hashTransaction = null;
                if(this.__signature===undefined) this.__signature = null;
                if(this.__fee===undefined) this.__fee = null;
                if(this.__feeCalculator===undefined) this.__feeCalculator = null;
                if(this.__signBy===undefined) this.__signBy = null;
                if(this.__deadline===undefined) this.__deadline = null;
                this.peerConnection = peerConnection;
            }

            public multisig(multisig : org.nem.core.model.Account) : MultisigSignatureTransactionBuilder.ISigner {
                this.__multisig = multisig;
                return this;
            }

            /**
             * Builds the multisig signature transaction.
             * 
             * @return {org.nem.core.model.MultisigSignatureTransaction} the multisig signature transaction
             * @private
             */
            buildMultisigSignatureTransaction() : org.nem.core.model.MultisigSignatureTransaction {
                if(this.__timeStamp == null) {
                    this.__timeStamp = io.nem.xpx.model.XpxSdkGlobalConstants.TIME_PROVIDER_$LI$().getCurrentTime();
                }
                for(let index149=0; index149 < this.signers.length; index149++) {
                    let signer = this.signers[index149];
                    {
                        if(this.__otherTransaction != null) {
                            this.instance = new org.nem.core.model.MultisigSignatureTransaction(this.__timeStamp, signer, this.__multisig, this.__otherTransaction);
                        }
                        if(this.hashTransaction != null) {
                            this.instance = new org.nem.core.model.MultisigSignatureTransaction(this.__timeStamp, signer, this.__multisig, this.hashTransaction);
                        }
                        if(this.__fee == null && this.__feeCalculator == null) {
                            this.instance.setFee(this.peerConnection.getTransactionFeeCalculators().getFeeCalculator().calculateMinimumFee(this.instance));
                        } else {
                            if(this.__fee != null) {
                                this.instance.setFee(this.__fee);
                            } else if(this.__feeCalculator != null) {
                                let feeCalculator : org.nem.core.model.TransactionFeeCalculator;
                                if(this.__feeCalculator != null) {
                                    feeCalculator = this.__feeCalculator;
                                } else {
                                    feeCalculator = this.peerConnection.getTransactionFeeCalculators().getFeeCalculator();
                                }
                                this.instance.setFee(feeCalculator.calculateMinimumFee(this.instance));
                            }
                        }
                        if(this.__deadline != null) {
                            this.instance.setDeadline(this.__deadline);
                        } else {
                            this.instance.setDeadline(this.__timeStamp.addHours(23));
                        }
                        if(this.__signature != null) {
                            this.instance.setSignature(this.__signature);
                        }
                        if(this.__signBy != null) {
                            this.instance.signBy(this.__signBy);
                        }
                        this.instance.sign();
                    }
                }
                return this.instance;
            }

            /**
             * 
             * @return {org.nem.core.model.MultisigSignatureTransaction}
             */
            public coSign() : org.nem.core.model.MultisigSignatureTransaction {
                this.peerConnection.getTransactionSender().sendMultisigSignatureTransaction(this.buildMultisigSignatureTransaction());
                return this.instance;
            }

            /**
             * 
             * @param {org.nem.core.model.primitive.Amount} amount
             * @return {*}
             */
            public fee(amount : org.nem.core.model.primitive.Amount) : MultisigSignatureTransactionBuilder.IBuild {
                this.__fee = amount;
                return this;
            }

            /**
             * 
             * @param {org.nem.core.time.TimeInstant} deadline
             * @return {*}
             */
            public deadline(deadline : org.nem.core.time.TimeInstant) : MultisigSignatureTransactionBuilder.IBuild {
                this.__deadline = deadline;
                return this;
            }

            /**
             * 
             * @param {org.nem.core.crypto.Signature} signature
             * @return {*}
             */
            public signature(signature : org.nem.core.crypto.Signature) : MultisigSignatureTransactionBuilder.IBuild {
                this.__signature = signature;
                return this;
            }

            /**
             * 
             * @param {org.nem.core.time.TimeInstant} timeInstance
             * @return {*}
             */
            public timeStamp(timeInstance : org.nem.core.time.TimeInstant) : MultisigSignatureTransactionBuilder.IBuild {
                this.__timeStamp = timeInstance;
                return this;
            }

            /**
             * 
             * @param {org.nem.core.model.Account} account
             * @return {*}
             */
            public signBy(account : org.nem.core.model.Account) : MultisigSignatureTransactionBuilder.IBuild {
                this.__signBy = account;
                return this;
            }

            /**
             * 
             * @param {*} feeCalculator
             * @return {*}
             */
            public feeCalculator(feeCalculator : org.nem.core.model.TransactionFeeCalculator) : MultisigSignatureTransactionBuilder.IBuild {
                this.__feeCalculator = feeCalculator;
                return this;
            }

            public otherTransaction$org_nem_core_model_Transaction(transaction : org.nem.core.model.Transaction) : MultisigSignatureTransactionBuilder.IBuild {
                this.__otherTransaction = transaction;
                return this;
            }

            /**
             * 
             * @param {org.nem.core.model.Transaction} transaction
             * @return {*}
             */
            public otherTransaction(transaction? : any) : any {
                if(((transaction != null && transaction instanceof <any>org.nem.core.model.Transaction) || transaction === null)) {
                    return <any>this.otherTransaction$org_nem_core_model_Transaction(transaction);
                } else if(((transaction != null && transaction instanceof <any>org.nem.core.crypto.Hash) || transaction === null)) {
                    return <any>this.otherTransaction$org_nem_core_crypto_Hash(transaction);
                } else throw new Error('invalid overload');
            }

            public otherTransaction$org_nem_core_crypto_Hash(hashTransaction : org.nem.core.crypto.Hash) : MultisigSignatureTransactionBuilder.IBuild {
                this.hashTransaction = hashTransaction;
                return this;
            }

            /**
             * 
             * @param {org.nem.core.model.Account} signer
             * @return {*}
             */
            public addSigner(signer : org.nem.core.model.Account) : MultisigSignatureTransactionBuilder.ISigner {
                /* add */(this.signers.push(signer)>0);
                return this;
            }

            /**
             * 
             * @param {org.nem.core.model.Account[]} signers
             * @return {*}
             */
            public addSigners(signers : Array<org.nem.core.model.Account>) : MultisigSignatureTransactionBuilder.ITransaction {
                /* addAll */((l1, l2) => l1.push.apply(l1, l2))(this.signers, signers);
                return this;
            }

            /**
             * 
             * @param {org.nem.core.model.Account} signer
             * @return {*}
             */
            public signer(signer : org.nem.core.model.Account) : MultisigSignatureTransactionBuilder.ITransaction {
                /* add */(this.signers.push(signer)>0);
                return this;
            }

            /**
             * 
             * @return {java.util.concurrent.CompletableFuture}
             */
            public coSignFuture() : java.util.concurrent.CompletableFuture<org.nem.core.serialization.Deserializer> {
                return this.peerConnection.getTransactionSender().sendFutureMultisigSignatureTransaction(this.buildMultisigSignatureTransaction());
            }
        }
        Builder["__class"] = "io.nem.xpx.builder.MultisigSignatureTransactionBuilder.Builder";
        Builder["__interfaces"] = ["io.nem.xpx.builder.MultisigSignatureTransactionBuilder.IPeerConnection","io.nem.xpx.builder.MultisigSignatureTransactionBuilder.IBuild","io.nem.xpx.builder.MultisigSignatureTransactionBuilder.ITransaction","io.nem.xpx.builder.MultisigSignatureTransactionBuilder.ISigner"];


    }

}
namespace io.nem.xpx.builder {
    /**
     * The Class MultisigTransactionBuilder.
     * @class
     */
    export class MultisigTransactionBuilder {
        constructor() {
        }

        /**
         * PeerConnection.
         * 
         * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection
         * the peer connection
         * @return {*} the i peer connection
         */
        public static peerConnection(peerConnection : io.nem.xpx.facade.connection.PeerConnection) : MultisigTransactionBuilder.IPeerConnection {
            return new MultisigTransactionBuilder.Builder(peerConnection);
        }
    }
    MultisigTransactionBuilder["__class"] = "io.nem.xpx.builder.MultisigTransactionBuilder";


    export namespace MultisigTransactionBuilder {

        /**
         * The Interface ISender.
         * @class
         */
        export interface IPeerConnection {
            /**
             * Sender.
             * 
             * @param {org.nem.core.model.Account} sender
             * the sender
             * @return {*} the i sender
             */
            sender(sender : org.nem.core.model.Account) : MultisigTransactionBuilder.ITransaction;
        }

        /**
         * The Interface ITransaction.
         * @class
         */
        export interface ITransaction {
            /**
             * Other transaction.
             * 
             * @param {org.nem.core.model.Transaction} transaction
             * the transaction
             * @return {*} the i build
             */
            otherTransaction(transaction : org.nem.core.model.Transaction) : MultisigTransactionBuilder.IBuild;
        }

        /**
         * The Interface IBuild.
         * @class
         */
        export interface IBuild {
            /**
             * Time stamp.
             * 
             * @param {org.nem.core.time.TimeInstant} timeInstance
             * the time instance
             * @return {*} the i build
             */
            timeStamp(timeInstance : org.nem.core.time.TimeInstant) : MultisigTransactionBuilder.IBuild;

            /**
             * Sign by.
             * 
             * @param {org.nem.core.model.Account} account
             * the account
             * @return {*} the i build
             */
            signBy(account : org.nem.core.model.Account) : MultisigTransactionBuilder.IBuild;

            /**
             * Fee.
             * 
             * @param {org.nem.core.model.primitive.Amount} amount
             * the amount
             * @return {*} the i build
             */
            fee(amount : org.nem.core.model.primitive.Amount) : MultisigTransactionBuilder.IBuild;

            /**
             * Fee calculator.
             * 
             * @param {*} feeCalculator
             * the fee calculator
             * @return {*} the i build
             */
            feeCalculator(feeCalculator : org.nem.core.model.TransactionFeeCalculator) : MultisigTransactionBuilder.IBuild;

            /**
             * Deadline.
             * 
             * @param {org.nem.core.time.TimeInstant} timeInstant
             * the time instant
             * @return {*} the i build
             */
            deadline(timeInstant : org.nem.core.time.TimeInstant) : MultisigTransactionBuilder.IBuild;

            /**
             * Signature.
             * 
             * @param {org.nem.core.crypto.Signature} signature
             * the signature
             * @return {*} the i build
             */
            signature(signature : org.nem.core.crypto.Signature) : MultisigTransactionBuilder.IBuild;

            /**
             * Adds the signature.
             * 
             * @param {org.nem.core.model.MultisigSignatureTransaction} signature
             * the signature
             * @return {*} the i build
             */
            addSignature(signature : org.nem.core.model.MultisigSignatureTransaction) : MultisigTransactionBuilder.IBuild;

            /**
             * Builds the multisig transaction.
             * 
             * @return {org.nem.core.model.MultisigTransaction} the multisig transaction
             */
            buildMultisigTransaction() : org.nem.core.model.MultisigTransaction;

            /**
             * Builds the and send multisig transaction.
             * 
             * @return {org.nem.core.model.ncc.NemAnnounceResult} the nem announce result
             * @throws ApiException the api exception
             */
            buildAndSendMultisigTransaction() : org.nem.core.model.ncc.NemAnnounceResult;

            /**
             * Builds the and sign multisig transaction.
             * 
             * @return {io.nem.xpx.model.RequestAnnounceDataSignature} the request announce data signature
             * @throws ApiException the api exception
             */
            buildAndSignMultisigTransaction() : io.nem.xpx.model.RequestAnnounceDataSignature;

            /**
             * Builds the and send future multisig transaction.
             * 
             * @return {java.util.concurrent.CompletableFuture} the completable future
             * @throws ApiException the api exception
             */
            buildAndSendFutureMultisigTransaction() : java.util.concurrent.CompletableFuture<org.nem.core.serialization.Deserializer>;
        }

        /**
         * Instantiates a new builder.
         * 
         * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection
         * the sender
         * @class
         */
        export class Builder implements MultisigTransactionBuilder.IPeerConnection, MultisigTransactionBuilder.ITransaction, MultisigTransactionBuilder.IBuild {
            /**
             * The instance.
             */
            instance : org.nem.core.model.MultisigTransaction;

            /**
             * The peer connection.
             */
            peerConnection : io.nem.xpx.facade.connection.PeerConnection;

            /**
             * The time stamp.
             */
            __timeStamp : org.nem.core.time.TimeInstant;

            /**
             * The sender.
             */
            __sender : org.nem.core.model.Account;

            /**
             * The other transaction.
             */
            __otherTransaction : org.nem.core.model.Transaction;

            /**
             * The signature.
             */
            __signature : org.nem.core.crypto.Signature;

            /**
             * The fee.
             */
            __fee : org.nem.core.model.primitive.Amount;

            /**
             * The fee calculator.
             */
            __feeCalculator : org.nem.core.model.TransactionFeeCalculator;

            /**
             * The sign by.
             */
            __signBy : org.nem.core.model.Account;

            /**
             * The deadline.
             */
            __deadline : org.nem.core.time.TimeInstant;

            /**
             * The multisig signature.
             */
            multisigSignature : Array<org.nem.core.model.MultisigSignatureTransaction> = <any>([]);

            public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection) {
                if(this.instance===undefined) this.instance = null;
                if(this.peerConnection===undefined) this.peerConnection = null;
                if(this.__timeStamp===undefined) this.__timeStamp = null;
                if(this.__sender===undefined) this.__sender = null;
                if(this.__otherTransaction===undefined) this.__otherTransaction = null;
                if(this.__signature===undefined) this.__signature = null;
                if(this.__fee===undefined) this.__fee = null;
                if(this.__feeCalculator===undefined) this.__feeCalculator = null;
                if(this.__signBy===undefined) this.__signBy = null;
                if(this.__deadline===undefined) this.__deadline = null;
                this.peerConnection = peerConnection;
            }

            /**
             * 
             * @param {org.nem.core.model.Account} sender
             * @return {*}
             */
            public sender(sender : org.nem.core.model.Account) : MultisigTransactionBuilder.ITransaction {
                this.__sender = sender;
                return this;
            }

            /**
             * 
             * @return {org.nem.core.model.MultisigTransaction}
             */
            public buildMultisigTransaction() : org.nem.core.model.MultisigTransaction {
                let xpxMosaic : org.nem.core.model.mosaic.Mosaic = new org.nem.core.model.mosaic.Mosaic(new org.nem.core.model.mosaic.MosaicId(new org.nem.core.model.namespace.NamespaceId("prx"), "xpx"), org.nem.core.model.primitive.Quantity.fromValue(1));
                (<org.nem.core.model.TransferTransaction>this.instance.getOtherTransaction()).getAttachment().addMosaic(xpxMosaic);
                if(this.__timeStamp == null) {
                    this.__timeStamp = io.nem.xpx.model.XpxSdkGlobalConstants.TIME_PROVIDER_$LI$().getCurrentTime();
                }
                this.instance = new org.nem.core.model.MultisigTransaction(this.__timeStamp, this.__sender, this.__otherTransaction);
                if(this.__fee == null && this.__feeCalculator == null) {
                    this.instance.setFee(this.peerConnection.getTransactionFeeCalculators().getFeeCalculatorMultiSig().calculateMinimumFee(this.instance));
                } else {
                    if(this.__fee != null) {
                        this.instance.setFee(this.__fee);
                    } else if(this.__feeCalculator != null) {
                        let feeCalculator : org.nem.core.model.TransactionFeeCalculator;
                        if(this.__feeCalculator != null) {
                            feeCalculator = this.__feeCalculator;
                        } else {
                            feeCalculator = this.peerConnection.getTransactionFeeCalculators().getFeeCalculatorMultiSig();
                        }
                        this.instance.setFee(feeCalculator.calculateMinimumFee(this.instance));
                    }
                }
                if(this.__deadline != null) {
                    this.instance.setDeadline(this.__deadline);
                } else {
                    this.instance.setDeadline(this.__timeStamp.addHours(23));
                }
                if(this.__signature != null) {
                    this.instance.setSignature(this.__signature);
                }
                if(this.__signBy != null) {
                    this.instance.signBy(this.__signBy);
                }
                if(/* size */(<number>this.multisigSignature.length) > 0) {
                    for(let index150=0; index150 < this.multisigSignature.length; index150++) {
                        let multiSigSignatureTransaction = this.multisigSignature[index150];
                        {
                            this.instance.addSignature(multiSigSignatureTransaction);
                        }
                    }
                }
                this.instance.sign();
                return this.instance;
            }

            /**
             * 
             * @return {org.nem.core.model.ncc.NemAnnounceResult}
             */
            public buildAndSendMultisigTransaction() : org.nem.core.model.ncc.NemAnnounceResult {
                this.buildMultisigTransaction().sign();
                let data : number[] = org.nem.core.serialization.BinarySerializer.serializeToBytes(this.instance.asNonVerifiable());
                let request : org.nem.core.model.ncc.RequestAnnounce = new org.nem.core.model.ncc.RequestAnnounce(data, this.instance.getSignature().getBytes());
                let requestAnnounceDataSignature : io.nem.xpx.model.RequestAnnounceDataSignature = new io.nem.xpx.model.RequestAnnounceDataSignature();
                requestAnnounceDataSignature.setData(new org.nem.core.serialization.JsonDeserializer(org.nem.core.serialization.JsonSerializer.serializeToJson(request), null).readString("data", 5000));
                requestAnnounceDataSignature.setSignature(new org.nem.core.serialization.JsonDeserializer(org.nem.core.serialization.JsonSerializer.serializeToJson(request), null).readString("signature", 5000));
                return this.peerConnection.getTransactionSender().sendMultisigTransaction(this.instance);
            }

            /**
             * 
             * @param {org.nem.core.model.primitive.Amount} amount
             * @return {*}
             */
            public fee(amount : org.nem.core.model.primitive.Amount) : MultisigTransactionBuilder.IBuild {
                this.__fee = amount;
                return this;
            }

            /**
             * 
             * @param {org.nem.core.time.TimeInstant} timeInstant
             * @return {*}
             */
            public deadline(timeInstant : org.nem.core.time.TimeInstant) : MultisigTransactionBuilder.IBuild {
                this.__deadline = timeInstant;
                return this;
            }

            /**
             * 
             * @param {org.nem.core.crypto.Signature} signature
             * @return {*}
             */
            public signature(signature : org.nem.core.crypto.Signature) : MultisigTransactionBuilder.IBuild {
                this.__signature = signature;
                return this;
            }

            /**
             * 
             * @param {org.nem.core.time.TimeInstant} timeInstance
             * @return {*}
             */
            public timeStamp(timeInstance : org.nem.core.time.TimeInstant) : MultisigTransactionBuilder.IBuild {
                return this;
            }

            /**
             * 
             * @param {org.nem.core.model.Account} account
             * @return {*}
             */
            public signBy(account : org.nem.core.model.Account) : MultisigTransactionBuilder.IBuild {
                this.__signBy = account;
                return this;
            }

            /**
             * 
             * @param {*} feeCalculator
             * @return {*}
             */
            public feeCalculator(feeCalculator : org.nem.core.model.TransactionFeeCalculator) : MultisigTransactionBuilder.IBuild {
                this.__feeCalculator = feeCalculator;
                return this;
            }

            /**
             * 
             * @param {org.nem.core.model.MultisigSignatureTransaction} signature
             * @return {*}
             */
            public addSignature(signature : org.nem.core.model.MultisigSignatureTransaction) : MultisigTransactionBuilder.IBuild {
                /* add */(this.multisigSignature.push(signature)>0);
                return this;
            }

            /**
             * 
             * @param {org.nem.core.model.Transaction} transaction
             * @return {*}
             */
            public otherTransaction(transaction : org.nem.core.model.Transaction) : MultisigTransactionBuilder.IBuild {
                this.__otherTransaction = transaction;
                return this;
            }

            /**
             * 
             * @return {java.util.concurrent.CompletableFuture}
             */
            public buildAndSendFutureMultisigTransaction() : java.util.concurrent.CompletableFuture<org.nem.core.serialization.Deserializer> {
                return this.peerConnection.getTransactionSender().sendFutureMultiSigTransaction(this.buildMultisigTransaction());
            }

            /**
             * 
             * @return {io.nem.xpx.model.RequestAnnounceDataSignature}
             */
            public buildAndSignMultisigTransaction() : io.nem.xpx.model.RequestAnnounceDataSignature {
                this.buildMultisigTransaction().sign();
                let data : number[] = org.nem.core.serialization.BinarySerializer.serializeToBytes(this.instance.asNonVerifiable());
                let request : org.nem.core.model.ncc.RequestAnnounce = new org.nem.core.model.ncc.RequestAnnounce(data, this.instance.getSignature().getBytes());
                let requestAnnounceDataSignature : io.nem.xpx.model.RequestAnnounceDataSignature = new io.nem.xpx.model.RequestAnnounceDataSignature();
                requestAnnounceDataSignature.setData(new org.nem.core.serialization.JsonDeserializer(org.nem.core.serialization.JsonSerializer.serializeToJson(request), null).readString("data", 5000));
                requestAnnounceDataSignature.setSignature(new org.nem.core.serialization.JsonDeserializer(org.nem.core.serialization.JsonSerializer.serializeToJson(request), null).readString("signature", 5000));
                return requestAnnounceDataSignature;
            }
        }
        Builder["__class"] = "io.nem.xpx.builder.MultisigTransactionBuilder.Builder";
        Builder["__interfaces"] = ["io.nem.xpx.builder.MultisigTransactionBuilder.IBuild","io.nem.xpx.builder.MultisigTransactionBuilder.IPeerConnection","io.nem.xpx.builder.MultisigTransactionBuilder.ITransaction"];


    }

}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface BinaryDataStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface BinaryDataStep<T> {
        /**
         * Data.
         * 
         * @param {Array} data the data
         * @return {*} the t
         */
        data(data : number[]) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface CommonUploadBuildSteps.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface CommonUploadBuildSteps<T> extends io.nem.xpx.builder.steps.KeywordsStep<T>, io.nem.xpx.builder.steps.MetadataStep<T>, io.nem.xpx.builder.steps.MosaicsStep<T>, io.nem.xpx.builder.steps.PrivacyStrategyUploadStep<T> {    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface ContentTypeStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface ContentTypeStep<T> {
        /**
         * Content type.
         * 
         * @param {string} contentType the content type
         * @return {*} the t
         */
        contentType(contentType : string) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface EncodingStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface EncodingStep<T> {
        /**
         * Encoding.
         * 
         * @param {string} encoding the encoding
         * @return {*} the t
         */
        encoding(encoding : string) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface FileNameStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface FileNameStep<T> {
        /**
         * File name.
         * 
         * @param {string} fileName the file name
         * @return {*} the t
         */
        fileName(fileName : string) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface FilesStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface FilesStep<T> {
        /**
         * Adds the files.
         * 
         * @param {Array} files the files
         * @return {*} the t
         */
        addFiles(...files : any[]) : any;

        /**
         * Adds the file.
         * 
         * @param {java.io.File} file the file
         * @return {*} the t
         */
        addFile(file : java.io.File) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface FileStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface FileStep<T> {
        /**
         * File.
         * 
         * @param {java.io.File} file the file
         * @return {*} the t
         */
        file(file : java.io.File) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface NemHashStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface HashStep<T> {
        /**
         * Nem hash.
         * 
         * @param {string} nemHash the nem hash
         * @return {*} the t
         */
        nemHash(nemHash : string) : T;

        ipfsHash(ipfsHash : string) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface KeywordsStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface KeywordsStep<T> {
        /**
         * Keywords.
         * 
         * @param {string} keywords the keywords
         * @return {*} the t
         */
        keywords(keywords : string) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface MetadataStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface MetadataStep<T> {
        /**
         * Metadata.
         * 
         * @param {*} metadata the metadata
         * @return {*} the t
         */
        metadata(metadata : any) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface MosaicsStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface MosaicsStep<T> {
        /**
         * Mosaics.
         * 
         * @param {Array} mosaics the mosaics
         * @return {*} the t
         */
        mosaics(...mosaics : org.nem.core.model.mosaic.Mosaic[]) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface MultisigPublicKeyStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface MultisigPublicKeyStep<T> {
        /**
         * Multisig public key step.
         * 
         * @param {string} multisigPublicKeyStep the multisig public key step
         * @return {*} the t
         */
        multisigPublicKeyStep(multisigPublicKeyStep : string) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface NameStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface NameStep<T> {
        /**
         * Name.
         * 
         * @param {string} name the name
         * @return {*} the t
         */
        name(name : string) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface PathStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface PathStep<T> {
        /**
         * Path.
         * 
         * @param {string} path the path
         * @return {*} the t
         */
        path(path : string) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface PrivacyStrategyDownloadStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface PrivacyStrategyDownloadStep<T> {
        /**
         * Privacy strategy.
         * 
         * @param {io.nem.xpx.strategy.privacy.PrivacyStrategy} privacyStrategy the privacy strategy
         * @return {*} the t
         */
        privacyStrategy(privacyStrategy : io.nem.xpx.strategy.privacy.PrivacyStrategy) : T;

        /**
         * Plain privacy.
         * 
         * @return {*} the t
         */
        plainPrivacy() : T;

        /**
         * Secured with nem keys privacy strategy.
         * 
         * @param {string} senderOrReceiverPrivateKey the sender or receiver private key
         * @param {string} receiverOrSenderPublicKey the receiver or sender public key
         * @return {*} the t
         */
        securedWithNemKeysPrivacyStrategy(senderOrReceiverPrivateKey : string, receiverOrSenderPublicKey : string) : T;

        /**
         * Secured with password privacy strategy.
         * 
         * @param {string} password the password
         * @return {*} the t
         */
        securedWithPasswordPrivacyStrategy(password : string) : T;

        securedWithShamirSecretSharingPrivacyStrategy(secretTotalPartCount? : any, secretMinimumPartCountToBuild? : any, ...secretParts : any[]) : any;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface PrivacyStrategyUploadStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface PrivacyStrategyUploadStep<T> {
        /**
         * Privacy strategy.
         * 
         * @param {io.nem.xpx.strategy.privacy.PrivacyStrategy} privacyStrategy the privacy strategy
         * @return {*} the t
         */
        privacyStrategy(privacyStrategy : io.nem.xpx.strategy.privacy.PrivacyStrategy) : T;

        /**
         * Plain privacy.
         * 
         * @return {*} the t
         */
        plainPrivacy() : T;

        /**
         * Secured with nem keys privacy strategy.
         * 
         * @return {*} the t
         */
        securedWithNemKeysPrivacyStrategy() : T;

        /**
         * Secured with password privacy strategy.
         * 
         * @param {string} password the password
         * @return {*} the t
         */
        securedWithPasswordPrivacyStrategy(password : string) : T;

        securedWithShamirSecretSharingPrivacyStrategy(secretTotalPartCount? : any, secretMinimumPartCountToBuild? : any, ...secretParts : any[]) : any;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface ReceiverOrSenderPublicKeyStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface ReceiverOrSenderPublicKeyStep<T> {
        /**
         * Receiver or sender public key.
         * 
         * @param {string} receiverOrSenderPublicKey the receiver or sender public key
         * @return {*} the t
         */
        receiverOrSenderPublicKey(receiverOrSenderPublicKey : string) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface ReceiverPublicKeyStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface ReceiverPublicKeyStep<T> {
        /**
         * Receiver public key.
         * 
         * @param {string} receiverPublicKey the receiver public key
         * @return {*} the t
         */
        receiverPublicKey(receiverPublicKey : string) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface SenderOrReceiverPrivateKeyStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface SenderOrReceiverPrivateKeyStep<T> {
        /**
         * Sender or receiver private key.
         * 
         * @param {string} senderOrReceiverPrivateKey the sender or receiver private key
         * @return {*} the t
         */
        senderOrReceiverPrivateKey(senderOrReceiverPrivateKey : string) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface SenderPrivateKeyStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface SenderPrivateKeyStep<T> {
        /**
         * Sender private key.
         * 
         * @param {string} senderPrivateKey the sender private key
         * @return {*} the t
         */
        senderPrivateKey(senderPrivateKey : string) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface TextDataStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface TextDataStep<T> {
        /**
         * Data.
         * 
         * @param {string} data the data
         * @return {*} the t
         */
        data(data : string) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface UrlStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface UrlStep<T> {
        /**
         * URL.
         * 
         * @param {java.net.URL} url the url
         * @return {*} the t
         */
        url(url : java.net.URL) : T;
    }
}
namespace io.nem.xpx.builder.steps {
    /**
     * The Interface ZipFileNameStep.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface ZipFileNameStep<T> {
        /**
         * Zip file name.
         * 
         * @param {string} name the name
         * @return {*} the t
         */
        zipFileName(name : string) : T;
    }
}
namespace io.nem.xpx.builder {
    /**
     * Instantiates a new transfer transaction builder.
     * 
     * @param {io.nem.xpx.service.TransactionFeeCalculators} transactionFeeCalculators the transaction fee calculators
     * @class
     */
    export class TransferTransactionBuilder {
        /**
         * The transaction fee calculators.
         */
        /*private*/ transactionFeeCalculators : io.nem.xpx.service.TransactionFeeCalculators;

        /**
         * The version.
         */
        /*private*/ __version : number;

        /**
         * The time stamp.
         */
        /*private*/ __timeStamp : org.nem.core.time.TimeInstant;

        /**
         * The sender.
         */
        /*private*/ __sender : org.nem.core.model.Account;

        /**
         * The recipient.
         */
        /*private*/ __recipient : org.nem.core.model.Account;

        /**
         * The amount.
         */
        /*private*/ __amount : org.nem.core.model.primitive.Amount;

        /**
         * The attachment.
         */
        /*private*/ __attachment : org.nem.core.model.TransferTransactionAttachment;

        /**
         * The signature.
         */
        /*private*/ __signature : org.nem.core.crypto.Signature;

        /**
         * The deadline.
         */
        /*private*/ __deadline : org.nem.core.time.TimeInstant;

        /**
         * The fee.
         */
        /*private*/ __fee : org.nem.core.model.primitive.Amount;

        /**
         * The fee calculator.
         */
        /*private*/ __feeCalculator : org.nem.core.model.TransactionFeeCalculator;

        /**
         * The sign by.
         */
        /*private*/ __signBy : org.nem.core.model.Account;

        public constructor(transactionFeeCalculators : io.nem.xpx.service.TransactionFeeCalculators) {
            if(this.transactionFeeCalculators===undefined) this.transactionFeeCalculators = null;
            if(this.__version===undefined) this.__version = 0;
            if(this.__timeStamp===undefined) this.__timeStamp = null;
            if(this.__sender===undefined) this.__sender = null;
            if(this.__recipient===undefined) this.__recipient = null;
            if(this.__amount===undefined) this.__amount = null;
            if(this.__attachment===undefined) this.__attachment = null;
            if(this.__signature===undefined) this.__signature = null;
            if(this.__deadline===undefined) this.__deadline = null;
            if(this.__fee===undefined) this.__fee = null;
            if(this.__feeCalculator===undefined) this.__feeCalculator = null;
            if(this.__signBy===undefined) this.__signBy = null;
            this.transactionFeeCalculators = transactionFeeCalculators;
        }

        /**
         * Sender.
         * 
         * @param {org.nem.core.model.Account} sender the sender
         * @return {io.nem.xpx.builder.TransferTransactionBuilder} the transfer transaction builder
         */
        public sender(sender : org.nem.core.model.Account) : TransferTransactionBuilder {
            this.__sender = sender;
            return this;
        }

        /**
         * Recipient.
         * 
         * @param {org.nem.core.model.Account} recipient the recipient
         * @return {io.nem.xpx.builder.TransferTransactionBuilder} the transfer transaction builder
         */
        public recipient(recipient : org.nem.core.model.Account) : TransferTransactionBuilder {
            this.__recipient = recipient;
            return this;
        }

        /**
         * Amount.
         * 
         * @param {org.nem.core.model.primitive.Amount} amount the amount
         * @return {io.nem.xpx.builder.TransferTransactionBuilder} the transfer transaction builder
         */
        public amount(amount : org.nem.core.model.primitive.Amount) : TransferTransactionBuilder {
            this.__amount = amount;
            return this;
        }

        /**
         * Attachment.
         * 
         * @param {org.nem.core.model.TransferTransactionAttachment} attachment the attachment
         * @return {io.nem.xpx.builder.TransferTransactionBuilder} the transfer transaction builder
         */
        public attachment(attachment : org.nem.core.model.TransferTransactionAttachment) : TransferTransactionBuilder {
            this.__attachment = attachment;
            return this;
        }

        public buildTransaction$() : org.nem.core.model.TransferTransaction {
            return this.buildTransaction$boolean(false);
        }

        /**
         * Fee.
         * 
         * @param {org.nem.core.model.primitive.Amount} amount the amount
         * @return {io.nem.xpx.builder.TransferTransactionBuilder} the transfer transaction builder
         */
        public fee(amount : org.nem.core.model.primitive.Amount) : TransferTransactionBuilder {
            this.__fee = amount;
            return this;
        }

        /**
         * Deadline.
         * 
         * @param {org.nem.core.time.TimeInstant} deadline the deadline
         * @return {io.nem.xpx.builder.TransferTransactionBuilder} the transfer transaction builder
         */
        public deadline(deadline : org.nem.core.time.TimeInstant) : TransferTransactionBuilder {
            this.__deadline = deadline;
            return this;
        }

        /**
         * Signature.
         * 
         * @param {org.nem.core.crypto.Signature} signature the signature
         * @return {io.nem.xpx.builder.TransferTransactionBuilder} the transfer transaction builder
         */
        public signature(signature : org.nem.core.crypto.Signature) : TransferTransactionBuilder {
            this.__signature = signature;
            return this;
        }

        /**
         * Message.
         * 
         * @param {org.nem.core.model.Message} message the message
         * @return {io.nem.xpx.builder.TransferTransactionBuilder} the transfer transaction builder
         */
        public message(message : org.nem.core.model.Message) : TransferTransactionBuilder {
            if(this.__attachment == null) {
                this.__attachment = (io.nem.xpx.factory.AttachmentFactory.createTransferTransactionAttachmentMessage(message));
            } else {
                this.__attachment.setMessage(message);
            }
            return this;
        }

        /**
         * Fee calculator.
         * 
         * @param {*} feeCalculator the fee calculator
         * @return {io.nem.xpx.builder.TransferTransactionBuilder} the transfer transaction builder
         */
        public feeCalculator(feeCalculator : org.nem.core.model.TransactionFeeCalculator) : TransferTransactionBuilder {
            this.__feeCalculator = feeCalculator;
            return this;
        }

        /**
         * Version.
         * 
         * @param {number} version the version
         * @return {io.nem.xpx.builder.TransferTransactionBuilder} the transfer transaction builder
         */
        public version(version : number) : TransferTransactionBuilder {
            this.__version = version;
            return this;
        }

        /**
         * Time stamp.
         * 
         * @param {org.nem.core.time.TimeInstant} timeInstance the time instance
         * @return {io.nem.xpx.builder.TransferTransactionBuilder} the transfer transaction builder
         */
        public timeStamp(timeInstance : org.nem.core.time.TimeInstant) : TransferTransactionBuilder {
            this.__timeStamp = timeInstance;
            return this;
        }

        /**
         * Sign by.
         * 
         * @param {org.nem.core.model.Account} account the account
         * @return {io.nem.xpx.builder.TransferTransactionBuilder} the transfer transaction builder
         */
        public signBy(account : org.nem.core.model.Account) : TransferTransactionBuilder {
            this.__signBy = account;
            return this;
        }

        public addMosaic$org_nem_core_model_mosaic_Mosaic(mosaic : org.nem.core.model.mosaic.Mosaic) : TransferTransactionBuilder {
            if(this.__attachment == null) {
                this.__attachment = io.nem.xpx.factory.AttachmentFactory.createTransferTransactionAttachmentMosaic(mosaic);
            } else {
                this.__attachment.addMosaic(mosaic);
            }
            return this;
        }

        public addMosaic$org_nem_core_model_mosaic_MosaicId$org_nem_core_model_primitive_Quantity(mosaic : org.nem.core.model.mosaic.MosaicId, quantity : org.nem.core.model.primitive.Quantity) : TransferTransactionBuilder {
            this.__attachment.addMosaic(mosaic, quantity);
            return this;
        }

        /**
         * Adds the mosaic.
         * 
         * @param {org.nem.core.model.mosaic.MosaicId} mosaic the mosaic
         * @param {org.nem.core.model.primitive.Quantity} quantity the quantity
         * @return {io.nem.xpx.builder.TransferTransactionBuilder} the transfer transaction builder
         */
        public addMosaic(mosaic? : any, quantity? : any) : any {
            if(((mosaic != null && mosaic instanceof <any>org.nem.core.model.mosaic.MosaicId) || mosaic === null) && ((quantity != null && quantity instanceof <any>org.nem.core.model.primitive.Quantity) || quantity === null)) {
                return <any>this.addMosaic$org_nem_core_model_mosaic_MosaicId$org_nem_core_model_primitive_Quantity(mosaic, quantity);
            } else if(((mosaic != null && mosaic instanceof <any>org.nem.core.model.mosaic.Mosaic) || mosaic === null) && quantity === undefined) {
                return <any>this.addMosaic$org_nem_core_model_mosaic_Mosaic(mosaic);
            } else throw new Error('invalid overload');
        }

        /**
         * Adds the mosaics.
         * 
         * @param {Array} mosaics the mosaics
         * @return {io.nem.xpx.builder.TransferTransactionBuilder} the transfer transaction builder
         */
        public addMosaics(...mosaics : org.nem.core.model.mosaic.Mosaic[]) : TransferTransactionBuilder {
            for(let index151=0; index151 < mosaics.length; index151++) {
                let mosaic = mosaics[index151];
                {
                    this.__attachment.addMosaic(mosaic);
                }
            }
            return this;
        }

        public buildTransaction$boolean(isForMultisig : boolean) : org.nem.core.model.TransferTransaction {
            let instance : org.nem.core.model.TransferTransaction;
            let xpxMosaic : org.nem.core.model.mosaic.Mosaic = new org.nem.core.model.mosaic.Mosaic(new org.nem.core.model.mosaic.MosaicId(new org.nem.core.model.namespace.NamespaceId("prx"), "xpx"), org.nem.core.model.primitive.Quantity.fromValue(1));
            this.__attachment.addMosaic(xpxMosaic);
            if(this.__timeStamp == null) {
                this.__timeStamp = io.nem.xpx.model.XpxSdkGlobalConstants.TIME_PROVIDER_$LI$().getCurrentTime();
            }
            if(this.__amount == null) {
                this.amount(org.nem.core.model.primitive.Amount.fromNem(0));
            }
            if(this.__version === 0) {
                instance = new org.nem.core.model.TransferTransaction(this.__timeStamp, this.__sender, this.__recipient, this.__amount, this.__attachment);
            } else {
                instance = new org.nem.core.model.TransferTransaction(this.__version, this.__timeStamp, this.__sender, this.__recipient, this.__amount, this.__attachment);
            }
            let amountFee : org.nem.core.model.primitive.Amount;
            if(this.__fee != null) {
                amountFee = this.__fee;
            } else if(this.__feeCalculator != null) {
                amountFee = this.__feeCalculator.calculateMinimumFee(instance);
            } else {
                let globalFeeCalculator : org.nem.core.model.TransactionFeeCalculator = isForMultisig?this.transactionFeeCalculators.getFeeCalculatorMultiSig$java_lang_String(this.__sender.getAddress().getEncoded()):this.transactionFeeCalculators.getFeeCalculator$java_lang_String(this.__sender.getAddress().getEncoded());
                amountFee = globalFeeCalculator.calculateMinimumFee(instance);
            }
            instance.setFee(amountFee);
            if(this.__deadline != null) {
                instance.setDeadline(this.__deadline);
            } else {
                instance.setDeadline(this.__timeStamp.addHours(23));
            }
            if(this.__signature != null) {
                instance.setSignature(this.__signature);
            }
            if(this.__signBy != null) {
                instance.signBy(this.__signBy);
            }
            return instance;
        }

        /**
         * Builds the transaction.
         * 
         * @param {boolean} isForMultisig the is for multisig
         * @return {org.nem.core.model.TransferTransaction} the transfer transaction
         */
        public buildTransaction(isForMultisig? : any) : any {
            if(((typeof isForMultisig === 'boolean') || isForMultisig === null)) {
                return <any>this.buildTransaction$boolean(isForMultisig);
            } else if(isForMultisig === undefined) {
                return <any>this.buildTransaction$();
            } else throw new Error('invalid overload');
        }

        /**
         * Builds the and sign transaction.
         * 
         * @return {org.nem.core.model.TransferTransaction} the transfer transaction
         */
        public buildAndSignTransaction() : org.nem.core.model.TransferTransaction {
            let transferTransaction : org.nem.core.model.TransferTransaction = this.buildTransaction();
            transferTransaction.sign();
            return transferTransaction;
        }
    }
    TransferTransactionBuilder["__class"] = "io.nem.xpx.builder.TransferTransactionBuilder";

}
namespace io.nem.xpx.callback {
    /**
     * The Class RemoteDataHashUploadCallback.
     * @class
     */
    export class RemoteDataHashUploadCallback implements io.nem.ApiCallback<string> {
        /**
         * The logger.
         */
        LOGGER : java.util.logging.Logger = java.util.logging.Logger.getAnonymousLogger();

        /**
         * 
         * @param {io.nem.xpx.exceptions.ApiException} e
         * @param {number} statusCode
         * @param {*} responseHeaders
         */
        public onFailure(e : io.nem.xpx.exceptions.ApiException, statusCode : number, responseHeaders : any) {
            java.util.logging.Logger.getAnonymousLogger().severe(e.message);
        }

        public onSuccess$java_lang_String$int$java_util_Map(result : string, statusCode : number, responseHeaders : any) {
            java.util.logging.Logger.getAnonymousLogger().info("onSuccess " + result);
        }

        /**
         * 
         * @param {string} result
         * @param {number} statusCode
         * @param {*} responseHeaders
         */
        public onSuccess(result? : any, statusCode? : any, responseHeaders? : any) : any {
            if(((typeof result === 'string') || result === null) && ((typeof statusCode === 'number') || statusCode === null) && ((responseHeaders != null && (responseHeaders instanceof Object)) || responseHeaders === null)) {
                return <any>this.onSuccess$java_lang_String$int$java_util_Map(result, statusCode, responseHeaders);
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {number} bytesWritten
         * @param {number} contentLength
         * @param {boolean} done
         */
        public onUploadProgress(bytesWritten : number, contentLength : number, done : boolean) {
            java.util.logging.Logger.getAnonymousLogger().info("onUploadProgress: " + done);
        }

        /**
         * 
         * @param {number} bytesRead
         * @param {number} contentLength
         * @param {boolean} done
         */
        public onDownloadProgress(bytesRead : number, contentLength : number, done : boolean) {
            java.util.logging.Logger.getAnonymousLogger().info("onDownloadProgress: " + done);
        }

        constructor() {
        }
    }
    RemoteDataHashUploadCallback["__class"] = "io.nem.xpx.callback.RemoteDataHashUploadCallback";
    RemoteDataHashUploadCallback["__interfaces"] = ["io.nem.ApiCallback"];


}
namespace io.nem.xpx.callback {
    /**
     * The Interface ServiceAsyncCallback.
     * 
     * @param <T> the generic type
     * @class
     */
    export interface ServiceAsyncCallback<T> {
        /**
         * Process.
         * 
         * @param {*} uploadData the upload data
         */
        (uploadData : T);
    }
}
namespace io.nem.xpx.exceptions {
    /**
     * Instantiates a new announce transaction failure exception.
     * 
     * @param {string} message the message
     * @class
     * @extends Error
     */
    export class AnnounceTransactionFailureException extends Error {
        public constructor(message : string) {
            super(message); this.message=message;
            (<any>Object).setPrototypeOf(this, AnnounceTransactionFailureException.prototype);
        }
    }
    AnnounceTransactionFailureException["__class"] = "io.nem.xpx.exceptions.AnnounceTransactionFailureException";
    AnnounceTransactionFailureException["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.exceptions {
    /**
     * Instantiates a new api exception.
     * 
     * @param {string} message the message
     * @param {Error} throwable the throwable
     * @param {number} code the code
     * @param {*} responseHeaders the response headers
     * @param {string} responseBody the response body
     * @class
     * @extends Error
     */
    export class ApiException extends Error {
        /**
         * The code.
         */
        /*private*/ code : number;

        /**
         * The response headers.
         */
        /*private*/ responseHeaders : any;

        /**
         * The response body.
         */
        /*private*/ responseBody : string;

        public constructor(message? : any, throwable? : any, code? : any, responseHeaders? : any, responseBody? : any) {
            if(((typeof message === 'string') || message === null) && ((throwable != null && (throwable["__classes"] && throwable["__classes"].indexOf("java.lang.Throwable") >= 0) || throwable != null && throwable instanceof <any>Error) || throwable === null) && ((typeof code === 'number') || code === null) && ((responseHeaders != null && (responseHeaders instanceof Object)) || responseHeaders === null) && ((typeof responseBody === 'string') || responseBody === null)) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                this.code = 0;
                this.responseHeaders = null;
                this.responseBody = null;
                (<any>Object).setPrototypeOf(this, ApiException.prototype);
                (() => {
                    this.code = code;
                    this.responseHeaders = responseHeaders;
                    this.responseBody = responseBody;
                })();
            } else if(((typeof message === 'string') || message === null) && ((throwable != null && (throwable["__classes"] && throwable["__classes"].indexOf("java.lang.Throwable") >= 0) || throwable != null && throwable instanceof <any>Error) || throwable === null) && ((typeof code === 'number') || code === null) && ((responseHeaders != null && (responseHeaders instanceof Object)) || responseHeaders === null) && responseBody === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                {
                    let __args = Array.prototype.slice.call(arguments);
                    let responseBody : any = null;
                    super(message); this.message=message;
                    this.code = 0;
                    this.responseHeaders = null;
                    this.responseBody = null;
                    (<any>Object).setPrototypeOf(this, ApiException.prototype);
                    (() => {
                        this.code = code;
                        this.responseHeaders = responseHeaders;
                        this.responseBody = responseBody;
                    })();
                }
            } else if(((typeof message === 'string') || message === null) && ((typeof throwable === 'number') || throwable === null) && ((code != null && (code instanceof Object)) || code === null) && ((typeof responseHeaders === 'string') || responseHeaders === null) && responseBody === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let code : any = __args[1];
                let responseHeaders : any = __args[2];
                let responseBody : any = __args[3];
                {
                    let __args = Array.prototype.slice.call(arguments);
                    let throwable : any = <Error>null;
                    super(message); this.message=message;
                    this.code = 0;
                    this.responseHeaders = null;
                    this.responseBody = null;
                    (<any>Object).setPrototypeOf(this, ApiException.prototype);
                    (() => {
                        this.code = code;
                        this.responseHeaders = responseHeaders;
                        this.responseBody = responseBody;
                    })();
                }
            } else if(((typeof message === 'number') || message === null) && ((typeof throwable === 'string') || throwable === null) && ((code != null && (code instanceof Object)) || code === null) && ((typeof responseHeaders === 'string') || responseHeaders === null) && responseBody === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let code : any = __args[0];
                let message : any = __args[1];
                let responseHeaders : any = __args[2];
                let responseBody : any = __args[3];
                {
                    let __args = Array.prototype.slice.call(arguments);
                    super(message); this.message=message;
                    this.code = 0;
                    this.responseHeaders = null;
                    this.responseBody = null;
                    (<any>Object).setPrototypeOf(this, ApiException.prototype);
                    (() => {
                        this.code = code;
                    })();
                }
                (() => {
                    this.responseHeaders = responseHeaders;
                    this.responseBody = responseBody;
                })();
            } else if(((typeof message === 'number') || message === null) && ((throwable != null && (throwable instanceof Object)) || throwable === null) && ((typeof code === 'string') || code === null) && responseHeaders === undefined && responseBody === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let code : any = __args[0];
                let responseHeaders : any = __args[1];
                let responseBody : any = __args[2];
                {
                    let __args = Array.prototype.slice.call(arguments);
                    let message : any = <string>null;
                    let throwable : any = <Error>null;
                    super(message); this.message=message;
                    this.code = 0;
                    this.responseHeaders = null;
                    this.responseBody = null;
                    (<any>Object).setPrototypeOf(this, ApiException.prototype);
                    (() => {
                        this.code = code;
                        this.responseHeaders = responseHeaders;
                        this.responseBody = responseBody;
                    })();
                }
            } else if(((typeof message === 'number') || message === null) && ((typeof throwable === 'string') || throwable === null) && code === undefined && responseHeaders === undefined && responseBody === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let code : any = __args[0];
                let message : any = __args[1];
                super(message); this.message=message;
                this.code = 0;
                this.responseHeaders = null;
                this.responseBody = null;
                (<any>Object).setPrototypeOf(this, ApiException.prototype);
                (() => {
                    this.code = code;
                })();
            } else if(((message != null && (message["__classes"] && message["__classes"].indexOf("java.lang.Throwable") >= 0) || message != null && message instanceof <any>Error) || message === null) && throwable === undefined && code === undefined && responseHeaders === undefined && responseBody === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let throwable : any = __args[0];
                super(throwable); this.message=throwable;
                this.code = 0;
                this.responseHeaders = null;
                this.responseBody = null;
                (<any>Object).setPrototypeOf(this, ApiException.prototype);
            } else if(((typeof message === 'string') || message === null) && throwable === undefined && code === undefined && responseHeaders === undefined && responseBody === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                this.code = 0;
                this.responseHeaders = null;
                this.responseBody = null;
                (<any>Object).setPrototypeOf(this, ApiException.prototype);
            } else if(message === undefined && throwable === undefined && code === undefined && responseHeaders === undefined && responseBody === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                super();
                this.code = 0;
                this.responseHeaders = null;
                this.responseBody = null;
                (<any>Object).setPrototypeOf(this, ApiException.prototype);
            } else throw new Error('invalid overload');
        }

        /**
         * Get the HTTP status code.
         * 
         * @return {number} HTTP status code
         */
        public getCode() : number {
            return this.code;
        }

        /**
         * Get the HTTP response headers.
         * 
         * @return {*} A map of list of string
         */
        public getResponseHeaders() : any {
            return this.responseHeaders;
        }

        /**
         * Get the HTTP response body.
         * 
         * @return {string} Response body in the form of string
         */
        public getResponseBody() : string {
            return this.responseBody;
        }
    }
    ApiException["__class"] = "io.nem.xpx.exceptions.ApiException";
    ApiException["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.exceptions {
    /**
     * Instantiates a new decode nem message failure exception.
     * 
     * @param {string} message the message
     * @param {Error} cause the cause
     * @class
     * @extends Error
     */
    export class DecodeNemMessageFailureException extends Error {
        public constructor(message? : any, cause? : any) {
            if(((typeof message === 'string') || message === null) && ((cause != null && (cause["__classes"] && cause["__classes"].indexOf("java.lang.Throwable") >= 0) || cause != null && cause instanceof <any>Error) || cause === null)) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, DecodeNemMessageFailureException.prototype);
            } else if(((typeof message === 'string') || message === null) && cause === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, DecodeNemMessageFailureException.prototype);
            } else throw new Error('invalid overload');
        }
    }
    DecodeNemMessageFailureException["__class"] = "io.nem.xpx.exceptions.DecodeNemMessageFailureException";
    DecodeNemMessageFailureException["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.exceptions {
    /**
     * Instantiates a new decryption failure exception.
     * 
     * @param {string} message the message
     * @param {Error} cause the cause
     * @class
     * @extends Error
     */
    export class DecryptionFailureException extends Error {
        public constructor(message? : any, cause? : any) {
            if(((typeof message === 'string') || message === null) && ((cause != null && (cause["__classes"] && cause["__classes"].indexOf("java.lang.Throwable") >= 0) || cause != null && cause instanceof <any>Error) || cause === null)) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, DecryptionFailureException.prototype);
            } else if(((typeof message === 'string') || message === null) && cause === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, DecryptionFailureException.prototype);
            } else throw new Error('invalid overload');
        }
    }
    DecryptionFailureException["__class"] = "io.nem.xpx.exceptions.DecryptionFailureException";
    DecryptionFailureException["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.exceptions {
    /**
     * Instantiates a new decode nem message failure exception.
     * 
     * @param {string} message the message
     * @param {Error} cause the cause
     * @class
     * @extends Error
     */
    export class DeletePinnedContentFailureException extends Error {
        public constructor(message? : any, cause? : any) {
            if(((typeof message === 'string') || message === null) && ((cause != null && (cause["__classes"] && cause["__classes"].indexOf("java.lang.Throwable") >= 0) || cause != null && cause instanceof <any>Error) || cause === null)) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, DeletePinnedContentFailureException.prototype);
            } else if(((typeof message === 'string') || message === null) && cause === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, DeletePinnedContentFailureException.prototype);
            } else throw new Error('invalid overload');
        }
    }
    DeletePinnedContentFailureException["__class"] = "io.nem.xpx.exceptions.DeletePinnedContentFailureException";
    DeletePinnedContentFailureException["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.exceptions {
    /**
     * Instantiates a new encryption failure exception.
     * 
     * @param {string} message the message
     * @param {Error} cause the cause
     * @class
     * @extends Error
     */
    export class EncryptionFailureException extends Error {
        public constructor(message? : any, cause? : any) {
            if(((typeof message === 'string') || message === null) && ((cause != null && (cause["__classes"] && cause["__classes"].indexOf("java.lang.Throwable") >= 0) || cause != null && cause instanceof <any>Error) || cause === null)) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, EncryptionFailureException.prototype);
            } else if(((typeof message === 'string') || message === null) && cause === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, EncryptionFailureException.prototype);
            } else throw new Error('invalid overload');
        }
    }
    EncryptionFailureException["__class"] = "io.nem.xpx.exceptions.EncryptionFailureException";
    EncryptionFailureException["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.exceptions {
    /**
     * Instantiates a new keywords above max length limit exception.
     * 
     * @param {string} message the message
     * @class
     * @extends Error
     */
    export class KeywordsAboveMaxLengthLimitException extends Error {
        public constructor(message : string) {
            super(message); this.message=message;
            (<any>Object).setPrototypeOf(this, KeywordsAboveMaxLengthLimitException.prototype);
        }
    }
    KeywordsAboveMaxLengthLimitException["__class"] = "io.nem.xpx.exceptions.KeywordsAboveMaxLengthLimitException";
    KeywordsAboveMaxLengthLimitException["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.exceptions {
    /**
     * Instantiates a new resource not found exception.
     * 
     * @param {string} message the message
     * @param {Error} cause the cause
     * @class
     * @extends Error
     */
    export class MessageDigestNotMatchException extends Error {
        /**
         * The Constant serialVersionUID.
         */
        static serialVersionUID : number = 1;

        public constructor(message? : any, cause? : any) {
            if(((typeof message === 'string') || message === null) && ((cause != null && (cause["__classes"] && cause["__classes"].indexOf("java.lang.Throwable") >= 0) || cause != null && cause instanceof <any>Error) || cause === null)) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, MessageDigestNotMatchException.prototype);
            } else if(((typeof message === 'string') || message === null) && cause === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, MessageDigestNotMatchException.prototype);
            } else if(((message != null && (message["__classes"] && message["__classes"].indexOf("java.lang.Throwable") >= 0) || message != null && message instanceof <any>Error) || message === null) && cause === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let cause : any = __args[0];
                super(cause); this.message=cause;
                (<any>Object).setPrototypeOf(this, MessageDigestNotMatchException.prototype);
            } else if(message === undefined && cause === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                super();
                (<any>Object).setPrototypeOf(this, MessageDigestNotMatchException.prototype);
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            return "MessageDigestNotMatchException []";
        }
    }
    MessageDigestNotMatchException["__class"] = "io.nem.xpx.exceptions.MessageDigestNotMatchException";
    MessageDigestNotMatchException["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.exceptions {
    /**
     * Instantiates a new metadata above max length limit exception.
     * 
     * @param {string} message the message
     * @class
     * @extends Error
     */
    export class MetadataAboveMaxLengthLimitException extends Error {
        public constructor(message : string) {
            super(message); this.message=message;
            (<any>Object).setPrototypeOf(this, MetadataAboveMaxLengthLimitException.prototype);
        }
    }
    MetadataAboveMaxLengthLimitException["__class"] = "io.nem.xpx.exceptions.MetadataAboveMaxLengthLimitException";
    MetadataAboveMaxLengthLimitException["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.exceptions {
    /**
     * Instantiates a new mosaic information not found exception.
     * 
     * @param {string} message the message
     * @class
     * @extends Error
     */
    export class MosaicInformationNotFoundException extends Error {
        public constructor(message : string) {
            super(message); this.message=message;
            (<any>Object).setPrototypeOf(this, MosaicInformationNotFoundException.prototype);
        }
    }
    MosaicInformationNotFoundException["__class"] = "io.nem.xpx.exceptions.MosaicInformationNotFoundException";
    MosaicInformationNotFoundException["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.exceptions {
    /**
     * Instantiates a new path upload not supported exception.
     * 
     * @param {string} message the message
     * @class
     * @extends Error
     */
    export class PathUploadNotSupportedException extends Error {
        public constructor(message : string) {
            super(message); this.message=message;
            (<any>Object).setPrototypeOf(this, PathUploadNotSupportedException.prototype);
        }
    }
    PathUploadNotSupportedException["__class"] = "io.nem.xpx.exceptions.PathUploadNotSupportedException";
    PathUploadNotSupportedException["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.exceptions {
    /**
     * Instantiates a new decode nem message failure exception.
     * 
     * @param {string} message the message
     * @param {Error} cause the cause
     * @class
     * @extends Error
     */
    export class PeerConnectionInitFailureException extends Error {
        public constructor(message? : any, cause? : any) {
            if(((typeof message === 'string') || message === null) && ((cause != null && (cause["__classes"] && cause["__classes"].indexOf("java.lang.Throwable") >= 0) || cause != null && cause instanceof <any>Error) || cause === null)) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, PeerConnectionInitFailureException.prototype);
            } else if(((typeof message === 'string') || message === null) && cause === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, PeerConnectionInitFailureException.prototype);
            } else throw new Error('invalid overload');
        }
    }
    PeerConnectionInitFailureException["__class"] = "io.nem.xpx.exceptions.PeerConnectionInitFailureException";
    PeerConnectionInitFailureException["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.exceptions {
    /**
     * Instantiates a new peer connection not found exception.
     * 
     * @param {string} message the message
     * @class
     * @extends Error
     */
    export class PeerConnectionNotFoundException extends Error {
        public constructor(message : string) {
            super(message); this.message=message;
            (<any>Object).setPrototypeOf(this, PeerConnectionNotFoundException.prototype);
        }
    }
    PeerConnectionNotFoundException["__class"] = "io.nem.xpx.exceptions.PeerConnectionNotFoundException";
    PeerConnectionNotFoundException["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.exceptions {
    /**
     * Instantiates a new decode nem message failure exception.
     * 
     * @param {string} message the message
     * @param {Error} cause the cause
     * @class
     * @extends Error
     */
    export class UploadContentFailureException extends Error {
        public constructor(message? : any, cause? : any) {
            if(((typeof message === 'string') || message === null) && ((cause != null && (cause["__classes"] && cause["__classes"].indexOf("java.lang.Throwable") >= 0) || cause != null && cause instanceof <any>Error) || cause === null)) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, UploadContentFailureException.prototype);
            } else if(((typeof message === 'string') || message === null) && cause === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, UploadContentFailureException.prototype);
            } else throw new Error('invalid overload');
        }
    }
    UploadContentFailureException["__class"] = "io.nem.xpx.exceptions.UploadContentFailureException";
    UploadContentFailureException["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.facade {
    /**
     * The Class AbstractAsyncFacadeService.
     * @class
     */
    export abstract class AbstractAsyncFacadeService {
        /**
         * Run async.
         * 
         * @param <T> the generic type
         * @param {*} facadeMethod the facade method
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the completable future
         */
        runAsync<T>(facadeMethod : () => T, callback : io.nem.xpx.callback.ServiceAsyncCallback<T>) : java.util.concurrent.CompletableFuture<T> {
            return java.util.concurrent.CompletableFuture.supplyAsync<any>(() => (target => (typeof target === 'function')?target():(<any>target).get())(facadeMethod)).thenApply<any>((result) => {
                callback(result);
                return result;
            });
        }
    }
    AbstractAsyncFacadeService["__class"] = "io.nem.xpx.facade.AbstractAsyncFacadeService";

}
namespace io.nem.xpx.facade {
    /**
     * The Class AbstractFacadeService.
     * @class
     */
    export abstract class AbstractFacadeService {
        /**
         * Byte to serial object.
         * 
         * @param {Array} object
         * the object
         * @return {io.nem.xpx.service.model.buffers.ResourceHashMessage} the resource hash message
         */
        deserializeResourceMessageHash(object : number[]) : io.nem.xpx.service.model.buffers.ResourceHashMessage {
            let resourceMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage = io.nem.xpx.service.model.buffers.ResourceHashMessage.getRootAsResourceHashMessage$java_nio_ByteBuffer(java.nio.ByteBuffer.wrap(org.apache.commons.codec.binary.Base64.decodeBase64(object)));
            return resourceMessage;
        }

        /**
         * Check if txn have XPX mosaic.
         * 
         * @param {org.nem.core.model.Transaction} transaction the transaction
         * @return {boolean} true, if successful
         */
        checkIfTxnHaveXPXMosaic(transaction : org.nem.core.model.Transaction) : boolean {
            if(transaction != null && transaction instanceof <any>org.nem.core.model.TransferTransaction) {
                let mosaicIter : any = /* iterator */((a) => { var i = 0; return { next: function() { return i<a.length?a[i++]:null; }, hasNext: function() { return i<a.length; }}})((<org.nem.core.model.TransferTransaction>transaction).getMosaics());
                while((mosaicIter.hasNext())) {
                    let mosaic : org.nem.core.model.mosaic.Mosaic = mosaicIter.next();
                    if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(mosaic.getMosaicId().getNamespaceId().getRoot().toString(),"prx")) && /* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(mosaic.getMosaicId().getName(),"xpx"))) {
                        return true;
                    }
                };
            }
            return false;
        }
    }
    AbstractFacadeService["__class"] = "io.nem.xpx.facade.AbstractFacadeService";

}
namespace io.nem.xpx.facade.connection {
    /**
     * The Class PeerConnection.
     * @class
     */
    export abstract class PeerConnection {
        /**
         * The node endpoint.
         */
        nodeEndpoint : org.nem.core.node.NodeEndpoint;

        /*private*/ syncGateways : Array<string>;

        /**
         * The async nem connector.
         */
        /*private*/ asyncNemConnector : org.nem.core.connect.client.DefaultAsyncNemConnector<org.nem.core.node.ApiId>;

        /**
         * The nem transaction api.
         */
        /*private*/ nemTransactionApi : io.nem.xpx.service.NemTransactionApi;

        /**
         * The nem account api.
         */
        /*private*/ nemAccountApi : io.nem.xpx.service.NemAccountApi;

        /**
         * The nem namespace and mosaics api.
         */
        /*private*/ nemNamespaceAndMosaicsApi : io.nem.xpx.service.NemNamespaceAndMosaicsApi;

        /**
         * The transaction sender.
         */
        /*private*/ transactionSender : io.nem.xpx.service.TransactionSender;

        /**
         * The transaction fee calculators.
         */
        /*private*/ transactionFeeCalculators : io.nem.xpx.service.TransactionFeeCalculators;

        /**
         * The transaction announcer.
         */
        /*private*/ transactionAnnouncer : io.nem.xpx.service.TransactionAnnouncer;

        public constructor() {
            if(this.nodeEndpoint===undefined) this.nodeEndpoint = null;
            if(this.syncGateways===undefined) this.syncGateways = null;
            if(this.asyncNemConnector===undefined) this.asyncNemConnector = null;
            if(this.nemTransactionApi===undefined) this.nemTransactionApi = null;
            if(this.nemAccountApi===undefined) this.nemAccountApi = null;
            if(this.nemNamespaceAndMosaicsApi===undefined) this.nemNamespaceAndMosaicsApi = null;
            if(this.transactionSender===undefined) this.transactionSender = null;
            if(this.transactionFeeCalculators===undefined) this.transactionFeeCalculators = null;
            if(this.transactionAnnouncer===undefined) this.transactionAnnouncer = null;
            this.syncGateways = /* emptyList */[];
        }

        /**
         * Checks if is local.
         * 
         * @return {boolean} true, if is local
         */
        public abstract isLocal() : boolean;

        /**
         * Gets the account api.
         * 
         * @return {*} the account api
         */
        public abstract getAccountApi() : io.nem.xpx.service.intf.AccountApi;

        /**
         * Gets the data hash api.
         * 
         * @return {*} the data hash api
         */
        public abstract getDataHashApi() : io.nem.xpx.service.intf.DataHashApi;

        /**
         * Gets the directory load api.
         * 
         * @return {*} the directory load api
         */
        public abstract getDirectoryLoadApi() : io.nem.xpx.service.intf.DirectoryLoadApi;

        /**
         * Gets the download api.
         * 
         * @return {*} the download api
         */
        public abstract getDownloadApi() : io.nem.xpx.service.intf.DownloadApi;

        /**
         * Gets the node api.
         * 
         * @return {*} the node api
         */
        public abstract getNodeApi() : io.nem.xpx.service.intf.NodeApi;

        /**
         * Gets the publish and subscribe api.
         * 
         * @return {*} the publish and subscribe api
         */
        public abstract getPublishAndSubscribeApi() : io.nem.xpx.service.intf.PublishAndSubscribeApi;

        public abstract getFileAndNamingRouteApi() : io.nem.xpx.service.common.FileAndNamingRouteApi;

        /**
         * Gets the search api.
         * 
         * @return {*} the search api
         */
        public abstract getSearchApi() : io.nem.xpx.service.intf.SearchApi;

        /**
         * Gets the transaction and announce api.
         * 
         * @return {*} the transaction and announce api
         */
        public abstract getTransactionAndAnnounceApi() : io.nem.xpx.service.intf.TransactionAndAnnounceApi;

        /**
         * Gets the upload api.
         * 
         * @return {*} the upload api
         */
        public abstract getUploadApi() : io.nem.xpx.service.intf.UploadApi;

        setSyncGateways(...syncGateways : Array<string>[]) {
            this.syncGateways = /* unmodifiableList */java.util.stream.Stream.of<any>(syncGateways).filter((arg0) => { return java.util.Objects.nonNull(arg0) }).flatMap<any>((list) => list.stream()).collect<any, any>(java.util.stream.Collectors.toList<any>()).slice(0);
        }

        /**
         * Gets the sync gateways.
         * 
         * @return {string[]} list of gateway URLs where uploads will be sync
         */
        public getSyncGateways() : Array<string> {
            return this.syncGateways;
        }

        /**
         * Gets the nem transaction api.
         * 
         * @return {io.nem.xpx.service.NemTransactionApi} the nem transaction api
         */
        public getNemTransactionApi() : io.nem.xpx.service.NemTransactionApi {
            if(this.nemTransactionApi == null) this.nemTransactionApi = new io.nem.xpx.service.NemTransactionApi(this.nodeEndpoint, this.getAsyncNemConnector());
            return this.nemTransactionApi;
        }

        /**
         * Gets the nem account api.
         * 
         * @return {io.nem.xpx.service.NemAccountApi} the nem account api
         */
        public getNemAccountApi() : io.nem.xpx.service.NemAccountApi {
            if(this.nemAccountApi == null) this.nemAccountApi = new io.nem.xpx.service.NemAccountApi(this.nodeEndpoint, this.getAsyncNemConnector());
            return this.nemAccountApi;
        }

        /**
         * Gets the nem namespace and mosaics api.
         * 
         * @return {io.nem.xpx.service.NemNamespaceAndMosaicsApi} the nem namespace and mosaics api
         */
        public getNemNamespaceAndMosaicsApi() : io.nem.xpx.service.NemNamespaceAndMosaicsApi {
            if(this.nemNamespaceAndMosaicsApi == null) this.nemNamespaceAndMosaicsApi = new io.nem.xpx.service.NemNamespaceAndMosaicsApi(this.nodeEndpoint, this.getAsyncNemConnector());
            return this.nemNamespaceAndMosaicsApi;
        }

        /**
         * Gets the transaction sender.
         * 
         * @return {io.nem.xpx.service.TransactionSender} the transaction sender
         */
        public getTransactionSender() : io.nem.xpx.service.TransactionSender {
            if(this.transactionSender == null) this.transactionSender = new io.nem.xpx.service.TransactionSender(this.getNemTransactionApi(), this.getNemAccountApi());
            return this.transactionSender;
        }

        /**
         * Gets the transaction fee calculators.
         * 
         * @return {io.nem.xpx.service.TransactionFeeCalculators} the transaction fee calculators
         */
        public getTransactionFeeCalculators() : io.nem.xpx.service.TransactionFeeCalculators {
            if(this.transactionFeeCalculators == null) this.transactionFeeCalculators = new io.nem.xpx.service.TransactionFeeCalculators(this.getNemAccountApi(), this.getNemNamespaceAndMosaicsApi());
            return this.transactionFeeCalculators;
        }

        /**
         * Gets the transaction announcer.
         * 
         * @return {io.nem.xpx.service.TransactionAnnouncer} the transaction announcer
         */
        public getTransactionAnnouncer() : io.nem.xpx.service.TransactionAnnouncer {
            if(this.transactionAnnouncer == null) this.transactionAnnouncer = new io.nem.xpx.service.TransactionAnnouncer(this.getTransactionFeeCalculators(), this.getTransactionSender());
            return this.transactionAnnouncer;
        }

        /**
         * Gets the async nem connector.
         * 
         * @return {org.nem.core.connect.client.DefaultAsyncNemConnector} the async nem connector
         * @private
         */
        /*private*/ getAsyncNemConnector() : org.nem.core.connect.client.DefaultAsyncNemConnector<org.nem.core.node.ApiId> {
            if(this.asyncNemConnector == null) this.asyncNemConnector = io.nem.xpx.factory.ConnectionFactory.createConnector();
            return this.asyncNemConnector;
        }
    }
    PeerConnection["__class"] = "io.nem.xpx.facade.connection.PeerConnection";

}
namespace io.nem.xpx.facade {
    /**
     * The Enum DataTextContentType.
     * @enum
     * @property {io.nem.xpx.facade.DataTextContentType} TEXT_PLAIN
     * The text plain.
     * @property {io.nem.xpx.facade.DataTextContentType} TEXT_XML
     * The text xml.
     * @property {io.nem.xpx.facade.DataTextContentType} TEXT_HTML
     * The text html.
     * @property {io.nem.xpx.facade.DataTextContentType} APPLICATION_JSON
     * The application json.
     * @property {io.nem.xpx.facade.DataTextContentType} APPLICATION_XML
     * The application xml.
     * @property {io.nem.xpx.facade.DataTextContentType} APPLICATION_ZIP
     * The application zip.
     * @property {io.nem.xpx.facade.DataTextContentType} APPLICATION_PDF
     * The application pdf.
     * @property {io.nem.xpx.facade.DataTextContentType} VIDEO_MP4
     * The video mp4.
     * @property {io.nem.xpx.facade.DataTextContentType} VIDEO_QUICKTIME
     * The video quicktime.
     * @property {io.nem.xpx.facade.DataTextContentType} IMAGE_PNG
     * @class
     */
    export enum DataTextContentType {
        
        /**
         * The text plain.
         */
        TEXT_PLAIN, 
        /**
         * The text xml.
         */
        TEXT_XML, 
        /**
         * The text html.
         */
        TEXT_HTML, 
        /**
         * The application json.
         */
        APPLICATION_JSON, 
        /**
         * The application xml.
         */
        APPLICATION_XML, 
        /**
         * The application zip.
         */
        APPLICATION_ZIP, 
        /**
         * The application pdf.
         */
        APPLICATION_PDF, 
        /**
         * The video mp4.
         */
        VIDEO_MP4, 
        /**
         * The video quicktime.
         */
        VIDEO_QUICKTIME, IMAGE_PNG
    }

    /** @ignore */
    export class DataTextContentType_$WRAPPER {
        /**
         * The value.
         */
        /*private*/ value;

        constructor(protected _$ordinal : number, protected _$name : string, value) {
            if(this.value===undefined) this.value = null;
            this.value = value;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            return this.value;
        }
        public name() : string { return this._$name; }
        public ordinal() : number { return this._$ordinal; }
    }
    DataTextContentType["__class"] = "io.nem.xpx.facade.DataTextContentType";
    DataTextContentType["__interfaces"] = ["java.lang.Comparable","java.io.Serializable"];

    DataTextContentType["_$wrappers"] = [new DataTextContentType_$WRAPPER(0, "TEXT_PLAIN", "text/plain"), new DataTextContentType_$WRAPPER(1, "TEXT_XML", "text/xml"), new DataTextContentType_$WRAPPER(2, "TEXT_HTML", "text/html"), new DataTextContentType_$WRAPPER(3, "APPLICATION_JSON", "application/json"), new DataTextContentType_$WRAPPER(4, "APPLICATION_XML", "application/xml"), new DataTextContentType_$WRAPPER(5, "APPLICATION_ZIP", "application/zip"), new DataTextContentType_$WRAPPER(6, "APPLICATION_PDF", "application/pdf"), new DataTextContentType_$WRAPPER(7, "VIDEO_MP4", "video/mp4"), new DataTextContentType_$WRAPPER(8, "VIDEO_QUICKTIME", "video/quicktime"), new DataTextContentType_$WRAPPER(9, "IMAGE_PNG", "image/png")];

}
namespace io.nem.xpx.facade.download {
    /**
     * Instantiates a new download exception.
     * 
     * @param {string} message the message
     * @param {Error} exception the exception
     * @class
     * @extends Error
     */
    export class DownloadException extends Error {
        /**
         * The Constant serialVersionUID.
         */
        static serialVersionUID : number = 1;

        public constructor(message? : any, exception? : any) {
            if(((typeof message === 'string') || message === null) && ((exception != null && (exception["__classes"] && exception["__classes"].indexOf("java.lang.Exception") >= 0) || exception != null && exception instanceof <any>Error) || exception === null)) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, DownloadException.prototype);
            } else if(((message != null && (message["__classes"] && message["__classes"].indexOf("java.lang.Exception") >= 0) || message != null && message instanceof <any>Error) || message === null) && exception === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let exception : any = __args[0];
                super(exception); this.message=exception;
                (<any>Object).setPrototypeOf(this, DownloadException.prototype);
            } else if(((typeof message === 'string') || message === null) && exception === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, DownloadException.prototype);
            } else throw new Error('invalid overload');
        }
    }
    DownloadException["__class"] = "io.nem.xpx.facade.download.DownloadException";
    DownloadException["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.facade.download {
    /**
     * The Class DownloadParameter.
     * @class
     */
    export class DownloadParameter {
        /*private*/ ipfsHash : string;

        /**
         * The nem hash.
         */
        /*private*/ nemHash : string;

        /**
         * The sender or receiver private key.
         */
        /*private*/ senderOrReceiverPrivateKey : string;

        /**
         * The receiver or sender public key.
         */
        /*private*/ receiverOrSenderPublicKey : string;

        /**
         * The privacy strategy.
         */
        /*private*/ privacyStrategy : io.nem.xpx.strategy.privacy.PrivacyStrategy = io.nem.xpx.strategy.privacy.PrivacyStrategyFactory.plainPrivacy();

        /**
         * Gets the nem hash.
         * 
         * @return {string} the nem hash
         */
        public getNemHash() : string {
            return this.nemHash;
        }

        /**
         * Sets the nem hash.
         * 
         * @param {string} nemHash the new nem hash
         */
        public setNemHash(nemHash : string) {
            this.nemHash = nemHash;
        }

        public getIpfsHash() : string {
            return this.ipfsHash;
        }

        public setIpfsHash(ipfsHash : string) {
            this.ipfsHash = ipfsHash;
        }

        /**
         * Gets the sender or receiver private key.
         * 
         * @return {string} the sender or receiver private key
         */
        public getSenderOrReceiverPrivateKey() : string {
            return this.senderOrReceiverPrivateKey;
        }

        /**
         * Sets the sender or receiver private key.
         * 
         * @param {string} senderOrReceiverPrivateKey the new sender or receiver private key
         */
        public setSenderOrReceiverPrivateKey(senderOrReceiverPrivateKey : string) {
            this.senderOrReceiverPrivateKey = senderOrReceiverPrivateKey;
        }

        /**
         * Gets the receiver or sender public key.
         * 
         * @return {string} the receiver or sender public key
         */
        public getReceiverOrSenderPublicKey() : string {
            return this.receiverOrSenderPublicKey;
        }

        /**
         * Sets the receiver or sender public key.
         * 
         * @param {string} receiverOrSenderPublicKey the new receiver or sender public key
         */
        public setReceiverOrSenderPublicKey(receiverOrSenderPublicKey : string) {
            this.receiverOrSenderPublicKey = receiverOrSenderPublicKey;
        }

        /**
         * Gets the privacy strategy.
         * 
         * @return {io.nem.xpx.strategy.privacy.PrivacyStrategy} the privacy strategy
         */
        public getPrivacyStrategy() : io.nem.xpx.strategy.privacy.PrivacyStrategy {
            return this.privacyStrategy;
        }

        /**
         * Sets the privacy strategy.
         * 
         * @param {io.nem.xpx.strategy.privacy.PrivacyStrategy} privacyStrategy the new privacy strategy
         */
        public setPrivacyStrategy(privacyStrategy : io.nem.xpx.strategy.privacy.PrivacyStrategy) {
            this.privacyStrategy = privacyStrategy;
        }

        /**
         * Creates the.
         * 
         * @return {*} the nem hash step
         */
        public static create() : io.nem.xpx.builder.steps.HashStep<DownloadParameter.BuildStep> {
            return new DownloadParameter.Builder();
        }

        constructor() {
            if(this.ipfsHash===undefined) this.ipfsHash = null;
            if(this.nemHash===undefined) this.nemHash = null;
            if(this.senderOrReceiverPrivateKey===undefined) this.senderOrReceiverPrivateKey = null;
            if(this.receiverOrSenderPublicKey===undefined) this.receiverOrSenderPublicKey = null;
        }
    }
    DownloadParameter["__class"] = "io.nem.xpx.facade.download.DownloadParameter";
    DownloadParameter["__interfaces"] = ["java.io.Serializable"];



    export namespace DownloadParameter {

        /**
         * The Interface BuildStep.
         * @class
         */
        export interface BuildStep extends io.nem.xpx.builder.steps.PrivacyStrategyDownloadStep<DownloadParameter.BuildStep> {
            /**
             * Builds the.
             * 
             * @return {io.nem.xpx.facade.download.DownloadParameter} the download parameter
             */
            build() : io.nem.xpx.facade.download.DownloadParameter;
        }

        /**
         * The Class Builder.
         * @class
         */
        export class Builder implements io.nem.xpx.builder.steps.HashStep<any>, DownloadParameter.BuildStep {
            /**
             * The instance.
             */
            instance : io.nem.xpx.facade.download.DownloadParameter;

            constructor() {
                if(this.instance===undefined) this.instance = null;
                this.instance = new io.nem.xpx.facade.download.DownloadParameter();
            }

            /**
             * 
             * @param {io.nem.xpx.strategy.privacy.PrivacyStrategy} privacyStrategy
             * @return {*}
             */
            public privacyStrategy(privacyStrategy : io.nem.xpx.strategy.privacy.PrivacyStrategy) : DownloadParameter.BuildStep {
                this.instance.setPrivacyStrategy(privacyStrategy);
                return this;
            }

            /**
             * 
             * @return {*}
             */
            public plainPrivacy() : DownloadParameter.BuildStep {
                this.instance.setPrivacyStrategy(io.nem.xpx.strategy.privacy.PrivacyStrategyFactory.plainPrivacy());
                return this;
            }

            /**
             * 
             * @param {string} senderOrReceiverPrivateKey
             * @param {string} receiverOrSenderPublicKey
             * @return {*}
             */
            public securedWithNemKeysPrivacyStrategy(senderOrReceiverPrivateKey : string, receiverOrSenderPublicKey : string) : DownloadParameter.BuildStep {
                this.instance.setPrivacyStrategy(io.nem.xpx.strategy.privacy.PrivacyStrategyFactory.securedWithNemKeysPrivacyStrategy(senderOrReceiverPrivateKey, receiverOrSenderPublicKey));
                this.instance.setSenderOrReceiverPrivateKey(senderOrReceiverPrivateKey);
                this.instance.setReceiverOrSenderPublicKey(receiverOrSenderPublicKey);
                return this;
            }

            /**
             * 
             * @param {string} password
             * @return {*}
             */
            public securedWithPasswordPrivacyStrategy(password : string) : DownloadParameter.BuildStep {
                this.instance.setPrivacyStrategy(io.nem.xpx.strategy.privacy.PrivacyStrategyFactory.securedWithPasswordPrivacyStrategy(password));
                return this;
            }

            public securedWithShamirSecretSharingPrivacyStrategy$int$int$io_nem_xpx_strategy_privacy_SecuredWithShamirSecretSharingPrivacyStrategy_SecretPart_A(secretTotalPartCount : number, secretMinimumPartCountToBuild : number, ...secretParts : io.nem.xpx.strategy.privacy.SecuredWithShamirSecretSharingPrivacyStrategy.SecretPart[]) : DownloadParameter.BuildStep {
                this.instance.setPrivacyStrategy(io.nem.xpx.strategy.privacy.PrivacyStrategyFactory.securedWithShamirSecretSharingPrivacyStrategy(secretTotalPartCount, secretMinimumPartCountToBuild, <any>(java.util.stream.Stream.of<any>(secretParts).collect<any, any>(java.util.stream.Collectors.toMap<any, any, any>((parts) => parts.index, (parts) => parts.__secretPart)))));
                return <DownloadParameter.BuildStep><any>this;
            }

            /**
             * 
             * @param {number} secretTotalPartCount
             * @param {number} secretMinimumPartCountToBuild
             * @param {Array} secretParts
             * @return {*}
             */
            public securedWithShamirSecretSharingPrivacyStrategy(secretTotalPartCount? : any, secretMinimumPartCountToBuild? : any, ...secretParts : any[]) : any {
                if(((typeof secretTotalPartCount === 'number') || secretTotalPartCount === null) && ((typeof secretMinimumPartCountToBuild === 'number') || secretMinimumPartCountToBuild === null) && ((secretParts != null && secretParts instanceof <any>Array && (secretParts.length==0 || secretParts[0] == null ||(secretParts[0] != null && secretParts[0] instanceof <any>io.nem.xpx.strategy.privacy.SecuredWithShamirSecretSharingPrivacyStrategy.SecretPart))) || secretParts === null)) {
                    return <any>this.securedWithShamirSecretSharingPrivacyStrategy$int$int$io_nem_xpx_strategy_privacy_SecuredWithShamirSecretSharingPrivacyStrategy_SecretPart_A(secretTotalPartCount, secretMinimumPartCountToBuild, secretParts);
                } else if(((typeof secretTotalPartCount === 'number') || secretTotalPartCount === null) && ((typeof secretMinimumPartCountToBuild === 'number') || secretMinimumPartCountToBuild === null) && ((secretParts != null && (secretParts instanceof Array)) || secretParts === null)) {
                    return <any>this.securedWithShamirSecretSharingPrivacyStrategy$int$int$java_util_List(secretTotalPartCount, secretMinimumPartCountToBuild, secretParts);
                } else if(((typeof secretTotalPartCount === 'number') || secretTotalPartCount === null) && ((typeof secretMinimumPartCountToBuild === 'number') || secretMinimumPartCountToBuild === null) && ((secretParts != null && (secretParts instanceof Object)) || secretParts === null)) {
                    return <any>this.securedWithShamirSecretSharingPrivacyStrategy$int$int$java_util_Map(secretTotalPartCount, secretMinimumPartCountToBuild, secretParts);
                } else throw new Error('invalid overload');
            }

            public securedWithShamirSecretSharingPrivacyStrategy$int$int$java_util_List(secretTotalPartCount : number, secretMinimumPartCountToBuild : number, secretParts : Array<io.nem.xpx.strategy.privacy.SecuredWithShamirSecretSharingPrivacyStrategy.SecretPart>) : DownloadParameter.BuildStep {
                this.instance.setPrivacyStrategy(io.nem.xpx.strategy.privacy.PrivacyStrategyFactory.securedWithShamirSecretSharingPrivacyStrategy(secretTotalPartCount, secretMinimumPartCountToBuild, secretParts == null?/* emptyMap */{}:<any>(secretParts.stream().collect<any, any>(java.util.stream.Collectors.toMap<any, any, any>((parts) => parts.index, (parts) => parts.__secretPart)))));
                return <DownloadParameter.BuildStep><any>this;
            }

            public securedWithShamirSecretSharingPrivacyStrategy$int$int$java_util_Map(secretTotalPartCount : number, secretMinimumPartCountToBuild : number, secretParts : any) : DownloadParameter.BuildStep {
                this.instance.setPrivacyStrategy(io.nem.xpx.strategy.privacy.PrivacyStrategyFactory.securedWithShamirSecretSharingPrivacyStrategy(secretTotalPartCount, secretMinimumPartCountToBuild, secretParts == null?/* emptyMap */{}:secretParts));
                return <DownloadParameter.BuildStep><any>this;
            }

            /**
             * 
             * @param {string} nemHash
             * @return {*}
             */
            public nemHash(nemHash : string) : DownloadParameter.BuildStep {
                this.instance.setNemHash(nemHash);
                return this;
            }

            /**
             * 
             * @param {string} ipfsHash
             * @return {*}
             */
            public ipfsHash(ipfsHash : string) : DownloadParameter.BuildStep {
                this.instance.setIpfsHash(ipfsHash);
                return this;
            }

            /**
             * 
             * @return {io.nem.xpx.facade.download.DownloadParameter}
             */
            public build() : io.nem.xpx.facade.download.DownloadParameter {
                return this.instance;
            }
        }
        Builder["__class"] = "io.nem.xpx.facade.download.DownloadParameter.Builder";
        Builder["__interfaces"] = ["io.nem.xpx.facade.download.DownloadParameter.BuildStep","io.nem.xpx.builder.steps.HashStep","io.nem.xpx.builder.steps.PrivacyStrategyDownloadStep"];


    }

}
namespace io.nem.xpx.facade.download {
    /**
     * Instantiate class.
     * 
     * @param {io.nem.xpx.service.model.buffers.ResourceHashMessage} dataMessage the data message
     * @param {Array} data the data
     * @param {io.nem.xpx.model.NemMessageType} messageType the message type
     * @class
     */
    export class DownloadResult {
        /**
         * The Constant serialVersionUID.
         */
        static serialVersionUID : number = 1;

        /**
         * The data message.
         */
        /*private*/ dataMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage;

        /**
         * The data.
         */
        /*private*/ data : number[];

        /**
         * The message type.
         */
        /*private*/ messageType : io.nem.xpx.model.NemMessageType;

        public constructor(dataMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage, data : number[], messageType : io.nem.xpx.model.NemMessageType) {
            if(this.dataMessage===undefined) this.dataMessage = null;
            if(this.data===undefined) this.data = null;
            if(this.messageType===undefined) this.messageType = null;
            this.dataMessage = dataMessage;
            this.data = data;
            this.messageType = messageType;
        }

        /**
         * Gets the data message.
         * 
         * @return {io.nem.xpx.service.model.buffers.ResourceHashMessage} the data message
         */
        public getDataMessage() : io.nem.xpx.service.model.buffers.ResourceHashMessage {
            return this.dataMessage;
        }

        /**
         * Gets the data.
         * 
         * @return {Array} the data
         */
        public getData() : number[] {
            return this.data;
        }

        /**
         * Gets the message type.
         * 
         * @return {io.nem.xpx.model.NemMessageType} the message type
         */
        public getMessageType() : io.nem.xpx.model.NemMessageType {
            return this.messageType;
        }

        /**
         * Gets the serialversionuid.
         * 
         * @return {number} the serialversionuid
         */
        public static getSerialversionuid() : number {
            return DownloadResult.serialVersionUID;
        }
    }
    DownloadResult["__class"] = "io.nem.xpx.facade.download.DownloadResult";
    DownloadResult["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.facade.multisigupload {
    /**
     * Instantiate class.
     * 
     * @param {io.nem.xpx.facade.upload.UploadResult} uploadData the upload data
     * @param {string} secretKey the secret key
     * @class
     */
    export class MultisigUploadResult {
        /**
         * The Constant serialVersionUID.
         */
        static serialVersionUID : number = 1;

        /**
         * The upload data.
         */
        /*private*/ uploadResult : io.nem.xpx.facade.upload.UploadResult;

        /**
         * The secret key.
         */
        /*private*/ secretKey : string;

        public constructor(uploadData : io.nem.xpx.facade.upload.UploadResult, secretKey : string) {
            if(this.uploadResult===undefined) this.uploadResult = null;
            if(this.secretKey===undefined) this.secretKey = null;
            this.uploadResult = uploadData;
            this.secretKey = secretKey;
        }

        /**
         * Gets the upload result.
         * 
         * @return {io.nem.xpx.facade.upload.UploadResult} the upload result
         */
        public getUploadResult() : io.nem.xpx.facade.upload.UploadResult {
            return this.uploadResult;
        }

        /**
         * Gets the secret key.
         * 
         * @return {string} the secret key
         */
        public getSecretKey() : string {
            return this.secretKey;
        }
    }
    MultisigUploadResult["__class"] = "io.nem.xpx.facade.multisigupload.MultisigUploadResult";
    MultisigUploadResult["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.facade.publishandsubscribe {
    /**
     * Instantiates a new search.
     * 
     * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection            the peer connection
     * @throws PeerConnectionNotFoundException the peer connection not found exception
     * @class
     */
    export class PublishAndSubscribe {
        /**
         * The peer connection.
         */
        /*private*/ peerConnection : io.nem.xpx.facade.connection.PeerConnection;

        /**
         * The engine.
         */
        /*private*/ engine : org.nem.core.crypto.CryptoEngine;

        /**
         * The publish and subscribe api.
         */
        /*private*/ publishAndSubscribeApi : io.nem.xpx.service.intf.PublishAndSubscribeApi;

        /**
         * The transaction and announce api.
         */
        /*private*/ transactionAndAnnounceApi : io.nem.xpx.service.intf.TransactionAndAnnounceApi;

        /**
         * The is local peer connection.
         */
        /*private*/ isLocalPeerConnection : boolean = false;

        public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection) {
            if(this.peerConnection===undefined) this.peerConnection = null;
            if(this.engine===undefined) this.engine = null;
            if(this.publishAndSubscribeApi===undefined) this.publishAndSubscribeApi = null;
            if(this.transactionAndAnnounceApi===undefined) this.transactionAndAnnounceApi = null;
            if(peerConnection == null) {
                throw new io.nem.xpx.exceptions.PeerConnectionNotFoundException("PeerConnection can\'t be null");
            }
            this.peerConnection = peerConnection;
            this.publishAndSubscribeApi = peerConnection.getPublishAndSubscribeApi();
            this.transactionAndAnnounceApi = peerConnection.getTransactionAndAnnounceApi();
            this.isLocalPeerConnection = peerConnection.isLocal();
            this.engine = org.nem.core.crypto.CryptoEngines.ed25519Engine();
        }

        /**
         * Subscribe and listen to topic.
         * 
         * @param {string} topic the topic
         */
        public subscribeAndListenToTopic(topic : string) {
        }

        /**
         * Publish topic.
         * 
         * @param {string} topic the topic
         * @param {string} initialMessage the initial message
         * @throws Exception the exception
         */
        public publishTopic(topic : string, initialMessage : string) {
            this.publishAndSubscribeApi.publishTopicUsingGET(topic, initialMessage);
        }

        /**
         * Send to topic.
         * 
         * @param {string} topic the topic
         * @param {string} message the message
         * @throws Exception the exception
         */
        public sendToTopic(topic : string, message : string) {
            this.publishAndSubscribeApi.sendToTopicUsingGET(topic, message);
        }

        /**
         * Send to topic by nem hash.
         * 
         * @param {string} nemHash the nem hash
         * @param {string} message the message
         * @throws Exception the exception
         */
        public sendToTopicByNemHash(nemHash : string, message : string) {
            this.publishAndSubscribeApi.sendToTopicUsingGET(nemHash, message);
        }
    }
    PublishAndSubscribe["__class"] = "io.nem.xpx.facade.publishandsubscribe.PublishAndSubscribe";

}
namespace io.nem.xpx.facade.publishandsubscribe {
    /**
     * The Class PublishAndSubscribe.
     * @class
     */
    export class PublishAndSubscribeResult {    }
    PublishAndSubscribeResult["__class"] = "io.nem.xpx.facade.publishandsubscribe.PublishAndSubscribeResult";

}
namespace io.nem.xpx.facade.upload {
    /**
     * The Class AbstractUploadParameter.
     * @class
     */
    export abstract class AbstractUploadParameter {
        /**
         * The Constant MAX_LENGTH_ALLOWED_FOR_METADATA.
         */
        public static MAX_LENGTH_ALLOWED_FOR_METADATA : number = 400;

        /**
         * The Constant MAX_LENGTH_ALLOWED_FOR_KEYWORDS.
         */
        public static MAX_LENGTH_ALLOWED_FOR_KEYWORDS : number = 80;

        /**
         * The sender private key.
         */
        /*private*/ senderPrivateKey : string;

        /**
         * The receiver public key.
         */
        /*private*/ receiverPublicKey : string;

        /**
         * The content type.
         */
        /*private*/ contentType : string;

        /**
         * The name.
         */
        /*private*/ name : string;

        /**
         * The keywords.
         */
        /*private*/ keywords : string;

        /**
         * The meta data.
         */
        /*private*/ metaData : string;

        /**
         * The mosaics.
         */
        /*private*/ mosaics : org.nem.core.model.mosaic.Mosaic[];

        /**
         * The privacy strategy.
         */
        /*private*/ privacyStrategy : io.nem.xpx.strategy.privacy.PrivacyStrategy = io.nem.xpx.strategy.privacy.PrivacyStrategyFactory.plainPrivacy();

        /**
         * Gets the sender private key.
         * 
         * @return {string} the sender private key
         */
        public getSenderPrivateKey() : string {
            return this.senderPrivateKey;
        }

        /**
         * Sets the sender private key.
         * 
         * @param {string} senderPrivateKey the new sender private key
         */
        public setSenderPrivateKey(senderPrivateKey : string) {
            this.senderPrivateKey = senderPrivateKey;
        }

        /**
         * Gets the receiver public key.
         * 
         * @return {string} the receiver public key
         */
        public getReceiverPublicKey() : string {
            return this.receiverPublicKey;
        }

        /**
         * Sets the receiver public key.
         * 
         * @param {string} receiverPublicKey the new receiver public key
         */
        public setReceiverPublicKey(receiverPublicKey : string) {
            this.receiverPublicKey = receiverPublicKey;
        }

        /**
         * Gets the content type.
         * 
         * @return {string} the content type
         */
        public getContentType() : string {
            return this.contentType;
        }

        /**
         * Sets the content type.
         * 
         * @param {string} contentType the new content type
         */
        public setContentType(contentType : string) {
            this.contentType = contentType;
        }

        /**
         * Gets the name.
         * 
         * @return {string} the name
         */
        public getName() : string {
            return this.name;
        }

        /**
         * Sets the name.
         * 
         * @param {string} name the new name
         */
        public setName(name : string) {
            this.name = name;
        }

        /**
         * Gets the keywords.
         * 
         * @return {string} the keywords
         */
        public getKeywords() : string {
            return this.keywords;
        }

        /**
         * Sets the keywords.
         * 
         * @param {string} keywords the new keywords
         */
        public setKeywords(keywords : string) {
            if(keywords != null && keywords.length > AbstractUploadParameter.MAX_LENGTH_ALLOWED_FOR_KEYWORDS) throw new io.nem.xpx.exceptions.KeywordsAboveMaxLengthLimitException(java.lang.String.format("The provided keywords exceeds the maximum %d characters allowed: %s", AbstractUploadParameter.MAX_LENGTH_ALLOWED_FOR_KEYWORDS, keywords));
            this.keywords = keywords;
        }

        /**
         * Gets the meta data as string.
         * 
         * @return {string} the meta data as string
         */
        public getMetaDataAsString() : string {
            return this.metaData;
        }

        /**
         * Sets the meta data.
         * 
         * @param {*} metaData the meta data
         */
        public setMetaData(metaData : any) {
            if(metaData != null) {
                let metadataAsString : string = io.nem.xpx.utils.JsonUtils.toJson(metaData);
                if(metadataAsString.length > AbstractUploadParameter.MAX_LENGTH_ALLOWED_FOR_METADATA) throw new io.nem.xpx.exceptions.MetadataAboveMaxLengthLimitException(java.lang.String.format("The provided metadata exceeds the maximum %d characters allowed: %s", AbstractUploadParameter.MAX_LENGTH_ALLOWED_FOR_METADATA, metadataAsString));
                this.metaData = metadataAsString;
            } else {
                this.metaData = null;
            }
        }

        /**
         * Gets the mosaics.
         * 
         * @return {Array} the mosaics
         */
        public getMosaics() : org.nem.core.model.mosaic.Mosaic[] {
            return this.mosaics == null?[]:this.mosaics;
        }

        /**
         * Sets the mosaics.
         * 
         * @param {Array} mosaics the new mosaics
         */
        public setMosaics(mosaics : org.nem.core.model.mosaic.Mosaic[]) {
            this.mosaics = mosaics;
        }

        /**
         * Adds the mosaic.
         * 
         * @param {org.nem.core.model.mosaic.Mosaic} mosaic the mosaic
         */
        public addMosaic(mosaic : org.nem.core.model.mosaic.Mosaic) {
            this.mosaics[this.mosaics.length - 1] = mosaic;
        }

        /**
         * Gets the privacy strategy.
         * 
         * @return {io.nem.xpx.strategy.privacy.PrivacyStrategy} the privacy strategy
         */
        public getPrivacyStrategy() : io.nem.xpx.strategy.privacy.PrivacyStrategy {
            return this.privacyStrategy;
        }

        /**
         * Sets the privacy strategy.
         * 
         * @param {io.nem.xpx.strategy.privacy.PrivacyStrategy} privacyStrategy the new privacy strategy
         */
        public setPrivacyStrategy(privacyStrategy : io.nem.xpx.strategy.privacy.PrivacyStrategy) {
            this.privacyStrategy = privacyStrategy;
        }

        constructor() {
            if(this.senderPrivateKey===undefined) this.senderPrivateKey = null;
            if(this.receiverPublicKey===undefined) this.receiverPublicKey = null;
            if(this.contentType===undefined) this.contentType = null;
            if(this.name===undefined) this.name = null;
            if(this.keywords===undefined) this.keywords = null;
            if(this.metaData===undefined) this.metaData = null;
            if(this.mosaics===undefined) this.mosaics = null;
        }
    }
    AbstractUploadParameter["__class"] = "io.nem.xpx.facade.upload.AbstractUploadParameter";

}
namespace io.nem.xpx.facade.upload {
    /**
     * The Class AbstractUploadParameterBuilder.
     * 
     * @param <NextBuildStepAfterPublicKey> the generic type
     * @param <FinalBuildSteps> the generic type
     * @class
     */
    export abstract class AbstractUploadParameterBuilder<NextBuildStepAfterPublicKey, FinalBuildSteps> implements io.nem.xpx.builder.steps.CommonUploadBuildSteps<FinalBuildSteps>, io.nem.xpx.builder.steps.SenderPrivateKeyStep<any>, io.nem.xpx.builder.steps.ReceiverPublicKeyStep<any> {
        /**
         * The instance.
         */
        instance : io.nem.xpx.facade.upload.AbstractUploadParameter;

        constructor(instance : io.nem.xpx.facade.upload.AbstractUploadParameter) {
            if(this.instance===undefined) this.instance = null;
            this.instance = instance;
        }

        /**
         * 
         * @param {Array} mosaics
         * @return {*}
         */
        public mosaics(...mosaics : org.nem.core.model.mosaic.Mosaic[]) : FinalBuildSteps {
            this.instance.setMosaics(mosaics);
            return <FinalBuildSteps><any>this;
        }

        /**
         * 
         * @param {string} keywords
         * @return {*}
         */
        public keywords(keywords : string) : FinalBuildSteps {
            this.instance.setKeywords(keywords);
            return <FinalBuildSteps><any>this;
        }

        /**
         * 
         * @param {*} metadata
         * @return {*}
         */
        public metadata(metadata : any) : FinalBuildSteps {
            this.instance.setMetaData(metadata);
            return <FinalBuildSteps><any>this;
        }

        /**
         * 
         * @param {io.nem.xpx.strategy.privacy.PrivacyStrategy} privacyStrategy
         * @return {*}
         */
        public privacyStrategy(privacyStrategy : io.nem.xpx.strategy.privacy.PrivacyStrategy) : FinalBuildSteps {
            this.instance.setPrivacyStrategy(privacyStrategy);
            return <FinalBuildSteps><any>this;
        }

        /**
         * 
         * @return {*}
         */
        public plainPrivacy() : FinalBuildSteps {
            this.instance.setPrivacyStrategy(io.nem.xpx.strategy.privacy.PrivacyStrategyFactory.plainPrivacy());
            return <FinalBuildSteps><any>this;
        }

        /**
         * 
         * @return {*}
         */
        public securedWithNemKeysPrivacyStrategy() : FinalBuildSteps {
            this.instance.setPrivacyStrategy(io.nem.xpx.strategy.privacy.PrivacyStrategyFactory.securedWithNemKeysPrivacyStrategy(this.instance.getSenderPrivateKey(), this.instance.getReceiverPublicKey()));
            return <FinalBuildSteps><any>this;
        }

        /**
         * 
         * @param {string} password
         * @return {*}
         */
        public securedWithPasswordPrivacyStrategy(password : string) : FinalBuildSteps {
            this.instance.setPrivacyStrategy(io.nem.xpx.strategy.privacy.PrivacyStrategyFactory.securedWithPasswordPrivacyStrategy(password));
            return <FinalBuildSteps><any>this;
        }

        public securedWithShamirSecretSharingPrivacyStrategy$int$int$io_nem_xpx_strategy_privacy_SecuredWithShamirSecretSharingPrivacyStrategy_SecretPart_A(secretTotalPartCount : number, secretMinimumPartCountToBuild : number, ...secretParts : io.nem.xpx.strategy.privacy.SecuredWithShamirSecretSharingPrivacyStrategy.SecretPart[]) : FinalBuildSteps {
            this.instance.setPrivacyStrategy(io.nem.xpx.strategy.privacy.PrivacyStrategyFactory.securedWithShamirSecretSharingPrivacyStrategy(secretTotalPartCount, secretMinimumPartCountToBuild, <any>(java.util.stream.Stream.of<any>(secretParts).collect<any, any>(java.util.stream.Collectors.toMap<any, any, any>((parts) => parts.index, (parts) => parts.__secretPart)))));
            return <FinalBuildSteps><any>this;
        }

        /**
         * 
         * @param {number} secretTotalPartCount
         * @param {number} secretMinimumPartCountToBuild
         * @param {Array} secretParts
         * @return {*}
         */
        public securedWithShamirSecretSharingPrivacyStrategy(secretTotalPartCount? : any, secretMinimumPartCountToBuild? : any, ...secretParts : any[]) : any {
            if(((typeof secretTotalPartCount === 'number') || secretTotalPartCount === null) && ((typeof secretMinimumPartCountToBuild === 'number') || secretMinimumPartCountToBuild === null) && ((secretParts != null && secretParts instanceof <any>Array && (secretParts.length==0 || secretParts[0] == null ||(secretParts[0] != null && secretParts[0] instanceof <any>io.nem.xpx.strategy.privacy.SecuredWithShamirSecretSharingPrivacyStrategy.SecretPart))) || secretParts === null)) {
                return <any>this.securedWithShamirSecretSharingPrivacyStrategy$int$int$io_nem_xpx_strategy_privacy_SecuredWithShamirSecretSharingPrivacyStrategy_SecretPart_A(secretTotalPartCount, secretMinimumPartCountToBuild, secretParts);
            } else if(((typeof secretTotalPartCount === 'number') || secretTotalPartCount === null) && ((typeof secretMinimumPartCountToBuild === 'number') || secretMinimumPartCountToBuild === null) && ((secretParts != null && (secretParts instanceof Array)) || secretParts === null)) {
                return <any>this.securedWithShamirSecretSharingPrivacyStrategy$int$int$java_util_List(secretTotalPartCount, secretMinimumPartCountToBuild, secretParts);
            } else if(((typeof secretTotalPartCount === 'number') || secretTotalPartCount === null) && ((typeof secretMinimumPartCountToBuild === 'number') || secretMinimumPartCountToBuild === null) && ((secretParts != null && (secretParts instanceof Object)) || secretParts === null)) {
                return <any>this.securedWithShamirSecretSharingPrivacyStrategy$int$int$java_util_Map(secretTotalPartCount, secretMinimumPartCountToBuild, secretParts);
            } else throw new Error('invalid overload');
        }

        public securedWithShamirSecretSharingPrivacyStrategy$int$int$java_util_List(secretTotalPartCount : number, secretMinimumPartCountToBuild : number, secretParts : Array<io.nem.xpx.strategy.privacy.SecuredWithShamirSecretSharingPrivacyStrategy.SecretPart>) : FinalBuildSteps {
            this.instance.setPrivacyStrategy(io.nem.xpx.strategy.privacy.PrivacyStrategyFactory.securedWithShamirSecretSharingPrivacyStrategy(secretTotalPartCount, secretMinimumPartCountToBuild, secretParts == null?/* emptyMap */{}:<any>(secretParts.stream().collect<any, any>(java.util.stream.Collectors.toMap<any, any, any>((parts) => parts.index, (parts) => parts.__secretPart)))));
            return <FinalBuildSteps><any>this;
        }

        public securedWithShamirSecretSharingPrivacyStrategy$int$int$java_util_Map(secretTotalPartCount : number, secretMinimumPartCountToBuild : number, secretParts : any) : FinalBuildSteps {
            this.instance.setPrivacyStrategy(io.nem.xpx.strategy.privacy.PrivacyStrategyFactory.securedWithShamirSecretSharingPrivacyStrategy(secretTotalPartCount, secretMinimumPartCountToBuild, secretParts == null?/* emptyMap */{}:secretParts));
            return <FinalBuildSteps><any>this;
        }

        /**
         * 
         * @param {string} senderPrivateKeyStep
         * @return {*}
         */
        public senderPrivateKey(senderPrivateKeyStep : string) : io.nem.xpx.builder.steps.ReceiverPublicKeyStep<any> {
            this.instance.setSenderPrivateKey(senderPrivateKeyStep);
            return this;
        }

        /**
         * 
         * @param {string} receiverPublicKey
         * @return {*}
         */
        public receiverPublicKey(receiverPublicKey : string) : NextBuildStepAfterPublicKey {
            this.instance.setReceiverPublicKey(receiverPublicKey);
            return <NextBuildStepAfterPublicKey><any>this;
        }
    }
    AbstractUploadParameterBuilder["__class"] = "io.nem.xpx.facade.upload.AbstractUploadParameterBuilder";
    AbstractUploadParameterBuilder["__interfaces"] = ["io.nem.xpx.builder.steps.KeywordsStep","io.nem.xpx.builder.steps.PrivacyStrategyUploadStep","io.nem.xpx.builder.steps.MosaicsStep","io.nem.xpx.builder.steps.ReceiverPublicKeyStep","io.nem.xpx.builder.steps.MetadataStep","io.nem.xpx.builder.steps.SenderPrivateKeyStep","io.nem.xpx.builder.steps.CommonUploadBuildSteps"];


}
namespace io.nem.xpx.facade.upload {
    /**
     * Instantiates a new multi file upload result.
     * 
     * @param {io.nem.xpx.facade.upload.MultiFileUploadResult.FileUploadResult[]} fileUploadResults the file upload results
     * @class
     */
    export class MultiFileUploadResult {
        /**
         * The file upload results.
         */
        /*private*/ fileUploadResults : Array<MultiFileUploadResult.FileUploadResult>;

        public constructor(fileUploadResults : Array<MultiFileUploadResult.FileUploadResult>) {
            if(this.fileUploadResults===undefined) this.fileUploadResults = null;
            this.fileUploadResults = fileUploadResults == null?/* emptyList */[]:/* unmodifiableList */fileUploadResults.slice(0);
        }

        /**
         * Gets the file upload results.
         * 
         * @return {io.nem.xpx.facade.upload.MultiFileUploadResult.FileUploadResult[]} the file upload results
         */
        public getFileUploadResults() : Array<MultiFileUploadResult.FileUploadResult> {
            return this.fileUploadResults;
        }

        /**
         * Checks for failure.
         * 
         * @return {boolean} true, if successful
         */
        public hasFailure() : boolean {
            return this.fileUploadResults.stream().anyMatch((result) => result.uploadException != null);
        }
    }
    MultiFileUploadResult["__class"] = "io.nem.xpx.facade.upload.MultiFileUploadResult";


    export namespace MultiFileUploadResult {

        /**
         * Instantiates a new file upload result.
         * 
         * @param {java.io.File} file the file
         * @param {io.nem.xpx.facade.upload.UploadResult} uploadResult the upload result
         * @class
         */
        export class FileUploadResult {
            /**
             * The file.
             */
            file : java.io.File;

            /**
             * The upload result.
             */
            uploadResult : io.nem.xpx.facade.upload.UploadResult;

            /**
             * The upload exception.
             */
            uploadException : io.nem.xpx.facade.upload.UploadException;

            public constructor(file? : any, uploadResult? : any) {
                if(((file != null && file instanceof <any>java.io.File) || file === null) && ((uploadResult != null && uploadResult instanceof <any>io.nem.xpx.facade.upload.UploadResult) || uploadResult === null)) {
                    let __args = Array.prototype.slice.call(arguments);
                    if(this.file===undefined) this.file = null;
                    if(this.uploadResult===undefined) this.uploadResult = null;
                    if(this.uploadException===undefined) this.uploadException = null;
                    if(this.file===undefined) this.file = null;
                    if(this.uploadResult===undefined) this.uploadResult = null;
                    if(this.uploadException===undefined) this.uploadException = null;
                    (() => {
                        this.file = file;
                        this.uploadResult = uploadResult;
                    })();
                } else if(((file != null && file instanceof <any>java.io.File) || file === null) && ((uploadResult != null && uploadResult instanceof <any>io.nem.xpx.facade.upload.UploadException) || uploadResult === null)) {
                    let __args = Array.prototype.slice.call(arguments);
                    let uploadException : any = __args[1];
                    if(this.file===undefined) this.file = null;
                    if(this.uploadResult===undefined) this.uploadResult = null;
                    if(this.uploadException===undefined) this.uploadException = null;
                    if(this.file===undefined) this.file = null;
                    if(this.uploadResult===undefined) this.uploadResult = null;
                    if(this.uploadException===undefined) this.uploadException = null;
                    (() => {
                        this.file = file;
                        this.uploadException = uploadException;
                    })();
                } else throw new Error('invalid overload');
            }

            /**
             * Gets the file.
             * 
             * @return {java.io.File} the file
             */
            public getFile() : java.io.File {
                return this.file;
            }

            /**
             * Gets the upload result.
             * 
             * @return {io.nem.xpx.facade.upload.UploadResult} the upload result
             */
            public getUploadResult() : io.nem.xpx.facade.upload.UploadResult {
                return this.uploadResult;
            }

            /**
             * Gets the upload exception.
             * 
             * @return {io.nem.xpx.facade.upload.UploadException} the upload exception
             */
            public getUploadException() : io.nem.xpx.facade.upload.UploadException {
                return this.uploadException;
            }
        }
        FileUploadResult["__class"] = "io.nem.xpx.facade.upload.MultiFileUploadResult.FileUploadResult";

    }

}
namespace io.nem.xpx.facade.upload {
    /**
     * Instantiates a new upload exception.
     * 
     * @param {string} message the message
     * @param {Error} exception the exception
     * @class
     * @extends Error
     */
    export class UploadException extends Error {
        /**
         * The Constant serialVersionUID.
         */
        static serialVersionUID : number = 1;

        public constructor(message? : any, exception? : any) {
            if(((typeof message === 'string') || message === null) && ((exception != null && (exception["__classes"] && exception["__classes"].indexOf("java.lang.Exception") >= 0) || exception != null && exception instanceof <any>Error) || exception === null)) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, UploadException.prototype);
            } else if(((message != null && (message["__classes"] && message["__classes"].indexOf("java.lang.Exception") >= 0) || message != null && message instanceof <any>Error) || message === null) && exception === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let exception : any = __args[0];
                super(exception); this.message=exception;
                (<any>Object).setPrototypeOf(this, UploadException.prototype);
            } else if(((typeof message === 'string') || message === null) && exception === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                super(message); this.message=message;
                (<any>Object).setPrototypeOf(this, UploadException.prototype);
            } else throw new Error('invalid overload');
        }
    }
    UploadException["__class"] = "io.nem.xpx.facade.upload.UploadException";
    UploadException["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.facade.upload {
    /**
     * Instantiate class.
     * 
     * @param {io.nem.xpx.service.model.buffers.ResourceHashMessage} dataMessage the data message
     * @param {string} nemHash the nem hash
     * @class
     */
    export class UploadResult {
        /**
         * The Constant serialVersionUID.
         */
        static serialVersionUID : number = 1;

        /**
         * The data message.
         */
        /*private*/ dataMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage;

        /**
         * The nem hash.
         */
        /*private*/ nemHash : string;

        public constructor(dataMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage, nemHash : string) {
            if(this.dataMessage===undefined) this.dataMessage = null;
            if(this.nemHash===undefined) this.nemHash = null;
            this.dataMessage = dataMessage;
            this.nemHash = nemHash;
        }

        /**
         * Gets the data message.
         * 
         * @return {io.nem.xpx.service.model.buffers.ResourceHashMessage} the data message
         */
        public getDataMessage() : io.nem.xpx.service.model.buffers.ResourceHashMessage {
            return this.dataMessage;
        }

        /**
         * Gets the nem hash.
         * 
         * @return {string} the nem hash
         */
        public getNemHash() : string {
            return this.nemHash;
        }

        public getIpfsHash() : string {
            return this.dataMessage.hash();
        }
    }
    UploadResult["__class"] = "io.nem.xpx.facade.upload.UploadResult";
    UploadResult["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.factory {
    /**
     * A factory for creating Attachment objects.
     * @class
     */
    export class AttachmentFactory {
        /**
         * Creates a new Attachment object.
         * 
         * @return {org.nem.core.model.TransferTransactionAttachment} the transfer transaction attachment
         */
        public static createTransferTransactionAttachment() : org.nem.core.model.TransferTransactionAttachment {
            return new org.nem.core.model.TransferTransactionAttachment();
        }

        /**
         * Creates a new Attachment object.
         * 
         * @param {org.nem.core.model.Message} message
         * the message
         * @return {org.nem.core.model.TransferTransactionAttachment} the transfer transaction attachment
         */
        public static createTransferTransactionAttachmentMessage(message : org.nem.core.model.Message) : org.nem.core.model.TransferTransactionAttachment {
            return new org.nem.core.model.TransferTransactionAttachment(message);
        }

        /**
         * Creates a new Attachment object.
         * 
         * @param {org.nem.core.model.mosaic.Mosaic} mosaic the mosaic
         * @return {org.nem.core.model.TransferTransactionAttachment} the transfer transaction attachment
         */
        public static createTransferTransactionAttachmentMosaic(mosaic : org.nem.core.model.mosaic.Mosaic) : org.nem.core.model.TransferTransactionAttachment {
            let attachment : org.nem.core.model.TransferTransactionAttachment = new org.nem.core.model.TransferTransactionAttachment();
            attachment.addMosaic(mosaic);
            return attachment;
        }
    }
    AttachmentFactory["__class"] = "io.nem.xpx.factory.AttachmentFactory";

}
namespace io.nem.xpx.factory {
    /**
     * A factory for creating Connector objects.
     * @class
     */
    export class ConnectionFactory {
        /**
         * The Constant CLIENT.
         */
        static CLIENT : org.nem.core.connect.HttpMethodClient<org.nem.core.connect.ErrorResponseDeserializerUnion>; public static CLIENT_$LI$() : org.nem.core.connect.HttpMethodClient<org.nem.core.connect.ErrorResponseDeserializerUnion> { if(ConnectionFactory.CLIENT == null) ConnectionFactory.CLIENT = ConnectionFactory.createHttpMethodClient(); return ConnectionFactory.CLIENT; };

        /**
         * Creates a new Connector object.
         * 
         * @return {org.nem.core.connect.client.DefaultAsyncNemConnector} the default async nem connector
         */
        public static createConnector() : org.nem.core.connect.client.DefaultAsyncNemConnector<org.nem.core.node.ApiId> {
            let connector : org.nem.core.connect.client.DefaultAsyncNemConnector<org.nem.core.node.ApiId> = <any>(new org.nem.core.connect.client.DefaultAsyncNemConnector<any>(ConnectionFactory.CLIENT_$LI$(), (r) => {
                throw Object.defineProperty(new Error(r.toString()), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
            }));
            connector.setAccountLookup((arg0) => { return new org.nem.core.model.Account(arg0) });
            return connector;
        }

        public static createNemNodeConnection$java_lang_String$java_lang_String$java_lang_String$int$java_lang_String(network : string, protocol : string, domainOrIp : string, port : number, wsPort : string) : org.nem.core.node.NodeEndpoint {
            ConnectionFactory.setNetwork(network);
            return new org.nem.core.node.NodeEndpoint(protocol, domainOrIp, port);
        }

        /**
         * Creates a new Connection object.
         * 
         * @param {string} network the nem network
         * @param {string} protocol the protocol
         * @param {string} domainOrIp the domain or ip
         * @param {number} port the port
         * @param {string} wsPort the ws port
         * @return {org.nem.core.node.NodeEndpoint} the node endpoint
         */
        public static createNemNodeConnection(network? : any, protocol? : any, domainOrIp? : any, port? : any, wsPort? : any) : any {
            if(((typeof network === 'string') || network === null) && ((typeof protocol === 'string') || protocol === null) && ((typeof domainOrIp === 'string') || domainOrIp === null) && ((typeof port === 'number') || port === null) && ((typeof wsPort === 'string') || wsPort === null)) {
                return <any>io.nem.xpx.factory.ConnectionFactory.createNemNodeConnection$java_lang_String$java_lang_String$java_lang_String$int$java_lang_String(network, protocol, domainOrIp, port, wsPort);
            } else if(((typeof network === 'string') || network === null) && ((typeof protocol === 'string') || protocol === null) && ((typeof domainOrIp === 'string') || domainOrIp === null) && ((typeof port === 'number') || port === null) && wsPort === undefined) {
                return <any>io.nem.xpx.factory.ConnectionFactory.createNemNodeConnection$java_lang_String$java_lang_String$java_lang_String$int(network, protocol, domainOrIp, port);
            } else throw new Error('invalid overload');
        }

        public static createNemNodeConnection$java_lang_String$java_lang_String$java_lang_String$int(network : string, protocol : string, domainOrIp : string, port : number) : org.nem.core.node.NodeEndpoint {
            ConnectionFactory.setNetwork(network);
            return new org.nem.core.node.NodeEndpoint(protocol, domainOrIp, port);
        }

        /**
         * Creates a new Connection object.
         * 
         * @param {string} multiAddress the multi address
         * @return {io.ipfs.api.IPFS} the ipfs
         */
        public static createIPFSNodeConnection(multiAddress : string) : io.ipfs.api.IPFS {
            return new io.ipfs.api.IPFS(new io.ipfs.multiaddr.MultiAddress(multiAddress));
        }

        public static setNetwork(network : string) {
            let networkInfo : org.nem.core.model.NetworkInfo = org.nem.core.model.NetworkInfos.getTestNetworkInfo();
            if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(network,"mainnet"))) {
                networkInfo = org.nem.core.model.NetworkInfos.getMainNetworkInfo();
            } else if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(network,"mijinnet"))) {
                networkInfo = org.nem.core.model.NetworkInfos.getMijinNetworkInfo();
            }
            org.nem.core.model.NetworkInfos.setDefault(networkInfo);
        }

        /**
         * Creates a new Connector object.
         * 
         * @return {org.nem.core.connect.HttpMethodClient} the http method client< error response deserializer union>
         * @private
         */
        /*private*/ static createHttpMethodClient() : org.nem.core.connect.HttpMethodClient<org.nem.core.connect.ErrorResponseDeserializerUnion> {
            let connectionTimeout : number = 4000;
            let socketTimeout : number = 10000;
            let requestTimeout : number = 30000;
            return <any>(new org.nem.core.connect.HttpMethodClient<any>(connectionTimeout, socketTimeout, requestTimeout));
        }
    }
    ConnectionFactory["__class"] = "io.nem.xpx.factory.ConnectionFactory";

}
namespace io.nem.xpx.model {
    /**
     * AccountInfo.
     * @class
     */
    export class AccountInfo {
        /**
         * The address.
         */
        /*private*/ __address : io.nem.xpx.model.Address = null;

        /**
         * The balance.
         */
        /*private*/ __balance : io.nem.xpx.model.Amount = null;

        /**
         * The importance.
         */
        /*private*/ __importance : number = null;

        /**
         * The key pair.
         */
        /*private*/ __keyPair : io.nem.xpx.model.KeyPair = null;

        /**
         * The label.
         */
        /*private*/ __label : string = null;

        /**
         * The multisig info.
         */
        /*private*/ __multisigInfo : io.nem.xpx.model.MultisigInfo = null;

        /**
         * The num harvested blocks.
         */
        /*private*/ __numHarvestedBlocks : io.nem.xpx.model.BlockAmount = null;

        /**
         * The vested balance.
         */
        /*private*/ __vestedBalance : io.nem.xpx.model.Amount = null;

        /**
         * Address.
         * 
         * @param {io.nem.xpx.model.Address} address the address
         * @return {io.nem.xpx.model.AccountInfo} the account info
         */
        public address(address : io.nem.xpx.model.Address) : AccountInfo {
            this.__address = address;
            return this;
        }

        /**
         * Get address.
         * 
         * @return {io.nem.xpx.model.Address} address
         */
        public getAddress() : io.nem.xpx.model.Address {
            return this.__address;
        }

        /**
         * Sets the address.
         * 
         * @param {io.nem.xpx.model.Address} address the new address
         */
        public setAddress(address : io.nem.xpx.model.Address) {
            this.__address = address;
        }

        /**
         * Balance.
         * 
         * @param {io.nem.xpx.model.Amount} balance the balance
         * @return {io.nem.xpx.model.AccountInfo} the account info
         */
        public balance(balance : io.nem.xpx.model.Amount) : AccountInfo {
            this.__balance = balance;
            return this;
        }

        /**
         * Get balance.
         * 
         * @return {io.nem.xpx.model.Amount} balance
         */
        public getBalance() : io.nem.xpx.model.Amount {
            return this.__balance;
        }

        /**
         * Sets the balance.
         * 
         * @param {io.nem.xpx.model.Amount} balance the new balance
         */
        public setBalance(balance : io.nem.xpx.model.Amount) {
            this.__balance = balance;
        }

        /**
         * Importance.
         * 
         * @param {number} importance the importance
         * @return {io.nem.xpx.model.AccountInfo} the account info
         */
        public importance(importance : number) : AccountInfo {
            this.__importance = importance;
            return this;
        }

        /**
         * Get importance.
         * 
         * @return {number} importance
         */
        public getImportance() : number {
            return this.__importance;
        }

        /**
         * Sets the importance.
         * 
         * @param {number} importance the new importance
         */
        public setImportance(importance : number) {
            this.__importance = importance;
        }

        /**
         * Key pair.
         * 
         * @param {io.nem.xpx.model.KeyPair} keyPair the key pair
         * @return {io.nem.xpx.model.AccountInfo} the account info
         */
        public keyPair(keyPair : io.nem.xpx.model.KeyPair) : AccountInfo {
            this.__keyPair = keyPair;
            return this;
        }

        /**
         * Get keyPair.
         * 
         * @return {io.nem.xpx.model.KeyPair} keyPair
         */
        public getKeyPair() : io.nem.xpx.model.KeyPair {
            return this.__keyPair;
        }

        /**
         * Sets the key pair.
         * 
         * @param {io.nem.xpx.model.KeyPair} keyPair the new key pair
         */
        public setKeyPair(keyPair : io.nem.xpx.model.KeyPair) {
            this.__keyPair = keyPair;
        }

        /**
         * Label.
         * 
         * @param {string} label the label
         * @return {io.nem.xpx.model.AccountInfo} the account info
         */
        public label(label : string) : AccountInfo {
            this.__label = label;
            return this;
        }

        /**
         * Get label.
         * 
         * @return {string} label
         */
        public getLabel() : string {
            return this.__label;
        }

        /**
         * Sets the label.
         * 
         * @param {string} label the new label
         */
        public setLabel(label : string) {
            this.__label = label;
        }

        /**
         * Multisig info.
         * 
         * @param {io.nem.xpx.model.MultisigInfo} multisigInfo the multisig info
         * @return {io.nem.xpx.model.AccountInfo} the account info
         */
        public multisigInfo(multisigInfo : io.nem.xpx.model.MultisigInfo) : AccountInfo {
            this.__multisigInfo = multisigInfo;
            return this;
        }

        /**
         * Get multisigInfo.
         * 
         * @return {io.nem.xpx.model.MultisigInfo} multisigInfo
         */
        public getMultisigInfo() : io.nem.xpx.model.MultisigInfo {
            return this.__multisigInfo;
        }

        /**
         * Sets the multisig info.
         * 
         * @param {io.nem.xpx.model.MultisigInfo} multisigInfo the new multisig info
         */
        public setMultisigInfo(multisigInfo : io.nem.xpx.model.MultisigInfo) {
            this.__multisigInfo = multisigInfo;
        }

        /**
         * Num harvested blocks.
         * 
         * @param {io.nem.xpx.model.BlockAmount} numHarvestedBlocks the num harvested blocks
         * @return {io.nem.xpx.model.AccountInfo} the account info
         */
        public numHarvestedBlocks(numHarvestedBlocks : io.nem.xpx.model.BlockAmount) : AccountInfo {
            this.__numHarvestedBlocks = numHarvestedBlocks;
            return this;
        }

        /**
         * Get numHarvestedBlocks.
         * 
         * @return {io.nem.xpx.model.BlockAmount} numHarvestedBlocks
         */
        public getNumHarvestedBlocks() : io.nem.xpx.model.BlockAmount {
            return this.__numHarvestedBlocks;
        }

        /**
         * Sets the num harvested blocks.
         * 
         * @param {io.nem.xpx.model.BlockAmount} numHarvestedBlocks the new num harvested blocks
         */
        public setNumHarvestedBlocks(numHarvestedBlocks : io.nem.xpx.model.BlockAmount) {
            this.__numHarvestedBlocks = numHarvestedBlocks;
        }

        /**
         * Vested balance.
         * 
         * @param {io.nem.xpx.model.Amount} vestedBalance the vested balance
         * @return {io.nem.xpx.model.AccountInfo} the account info
         */
        public vestedBalance(vestedBalance : io.nem.xpx.model.Amount) : AccountInfo {
            this.__vestedBalance = vestedBalance;
            return this;
        }

        /**
         * Get vestedBalance.
         * 
         * @return {io.nem.xpx.model.Amount} vestedBalance
         */
        public getVestedBalance() : io.nem.xpx.model.Amount {
            return this.__vestedBalance;
        }

        /**
         * Sets the vested balance.
         * 
         * @param {io.nem.xpx.model.Amount} vestedBalance the new vested balance
         */
        public setVestedBalance(vestedBalance : io.nem.xpx.model.Amount) {
            this.__vestedBalance = vestedBalance;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let accountInfo : AccountInfo = <AccountInfo>o;
            return java.util.Objects.equals(this.__address, accountInfo.__address) && java.util.Objects.equals(this.__balance, accountInfo.__balance) && java.util.Objects.equals(this.__importance, accountInfo.__importance) && java.util.Objects.equals(this.__keyPair, accountInfo.__keyPair) && java.util.Objects.equals(this.__label, accountInfo.__label) && java.util.Objects.equals(this.__multisigInfo, accountInfo.__multisigInfo) && java.util.Objects.equals(this.__numHarvestedBlocks, accountInfo.__numHarvestedBlocks) && java.util.Objects.equals(this.__vestedBalance, accountInfo.__vestedBalance);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class AccountInfo {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__address)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    address: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__balance)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    balance: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__importance)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    importance: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__keyPair)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    keyPair: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__label)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    label: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__multisigInfo)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    multisigInfo: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__numHarvestedBlocks)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    numHarvestedBlocks: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__vestedBalance)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    vestedBalance: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    AccountInfo["__class"] = "io.nem.xpx.model.AccountInfo";

}
namespace io.nem.xpx.model {
    /**
     * AccountMetaData.
     * @class
     */
    export class AccountMetaData {
        /**
         * The cosignatories.
         */
        /*private*/ __cosignatories : Array<io.nem.xpx.model.AccountInfo> = null;

        /**
         * The cosignatory of.
         */
        /*private*/ __cosignatoryOf : Array<io.nem.xpx.model.AccountInfo> = null;

        /**
         * The remote status.
         */
        /*private*/ __remoteStatus : AccountMetaData.RemoteStatusEnum = null;

        /**
         * The status.
         */
        /*private*/ __status : AccountMetaData.StatusEnum = null;

        /**
         * Cosignatories.
         * 
         * @param {io.nem.xpx.model.AccountInfo[]} cosignatories the cosignatories
         * @return {io.nem.xpx.model.AccountMetaData} the account meta data
         */
        public cosignatories(cosignatories : Array<io.nem.xpx.model.AccountInfo>) : AccountMetaData {
            this.__cosignatories = cosignatories;
            return this;
        }

        /**
         * Adds the cosignatories item.
         * 
         * @param {io.nem.xpx.model.AccountInfo} cosignatoriesItem the cosignatories item
         * @return {io.nem.xpx.model.AccountMetaData} the account meta data
         */
        public addCosignatoriesItem(cosignatoriesItem : io.nem.xpx.model.AccountInfo) : AccountMetaData {
            if(this.__cosignatories == null) {
                this.__cosignatories = <any>([]);
            }
            /* add */(this.__cosignatories.push(cosignatoriesItem)>0);
            return this;
        }

        /**
         * Get cosignatories.
         * 
         * @return {io.nem.xpx.model.AccountInfo[]} cosignatories
         */
        public getCosignatories() : Array<io.nem.xpx.model.AccountInfo> {
            return this.__cosignatories;
        }

        /**
         * Sets the cosignatories.
         * 
         * @param {io.nem.xpx.model.AccountInfo[]} cosignatories the new cosignatories
         */
        public setCosignatories(cosignatories : Array<io.nem.xpx.model.AccountInfo>) {
            this.__cosignatories = cosignatories;
        }

        /**
         * Cosignatory of.
         * 
         * @param {io.nem.xpx.model.AccountInfo[]} cosignatoryOf the cosignatory of
         * @return {io.nem.xpx.model.AccountMetaData} the account meta data
         */
        public cosignatoryOf(cosignatoryOf : Array<io.nem.xpx.model.AccountInfo>) : AccountMetaData {
            this.__cosignatoryOf = cosignatoryOf;
            return this;
        }

        /**
         * Adds the cosignatory of item.
         * 
         * @param {io.nem.xpx.model.AccountInfo} cosignatoryOfItem the cosignatory of item
         * @return {io.nem.xpx.model.AccountMetaData} the account meta data
         */
        public addCosignatoryOfItem(cosignatoryOfItem : io.nem.xpx.model.AccountInfo) : AccountMetaData {
            if(this.__cosignatoryOf == null) {
                this.__cosignatoryOf = <any>([]);
            }
            /* add */(this.__cosignatoryOf.push(cosignatoryOfItem)>0);
            return this;
        }

        /**
         * Get cosignatoryOf.
         * 
         * @return {io.nem.xpx.model.AccountInfo[]} cosignatoryOf
         */
        public getCosignatoryOf() : Array<io.nem.xpx.model.AccountInfo> {
            return this.__cosignatoryOf;
        }

        /**
         * Sets the cosignatory of.
         * 
         * @param {io.nem.xpx.model.AccountInfo[]} cosignatoryOf the new cosignatory of
         */
        public setCosignatoryOf(cosignatoryOf : Array<io.nem.xpx.model.AccountInfo>) {
            this.__cosignatoryOf = cosignatoryOf;
        }

        /**
         * Remote status.
         * 
         * @param {io.nem.xpx.model.AccountMetaData.RemoteStatusEnum} remoteStatus the remote status
         * @return {io.nem.xpx.model.AccountMetaData} the account meta data
         */
        public remoteStatus(remoteStatus : AccountMetaData.RemoteStatusEnum) : AccountMetaData {
            this.__remoteStatus = remoteStatus;
            return this;
        }

        /**
         * Get remoteStatus.
         * 
         * @return {io.nem.xpx.model.AccountMetaData.RemoteStatusEnum} remoteStatus
         */
        public getRemoteStatus() : AccountMetaData.RemoteStatusEnum {
            return this.__remoteStatus;
        }

        /**
         * Sets the remote status.
         * 
         * @param {io.nem.xpx.model.AccountMetaData.RemoteStatusEnum} remoteStatus the new remote status
         */
        public setRemoteStatus(remoteStatus : AccountMetaData.RemoteStatusEnum) {
            this.__remoteStatus = remoteStatus;
        }

        /**
         * Status.
         * 
         * @param {io.nem.xpx.model.AccountMetaData.StatusEnum} status the status
         * @return {io.nem.xpx.model.AccountMetaData} the account meta data
         */
        public status(status : AccountMetaData.StatusEnum) : AccountMetaData {
            this.__status = status;
            return this;
        }

        /**
         * Get status.
         * 
         * @return {io.nem.xpx.model.AccountMetaData.StatusEnum} status
         */
        public getStatus() : AccountMetaData.StatusEnum {
            return this.__status;
        }

        /**
         * Sets the status.
         * 
         * @param {io.nem.xpx.model.AccountMetaData.StatusEnum} status the new status
         */
        public setStatus(status : AccountMetaData.StatusEnum) {
            this.__status = status;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let accountMetaData : AccountMetaData = <AccountMetaData>o;
            return java.util.Objects.equals(this.__cosignatories, accountMetaData.__cosignatories) && java.util.Objects.equals(this.__cosignatoryOf, accountMetaData.__cosignatoryOf) && java.util.Objects.equals(this.__remoteStatus, accountMetaData.__remoteStatus) && java.util.Objects.equals(this.__status, accountMetaData.__status);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class AccountMetaData {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__cosignatories)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    cosignatories: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__cosignatoryOf)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    cosignatoryOf: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__remoteStatus)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    remoteStatus: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__status)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    status: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    AccountMetaData["__class"] = "io.nem.xpx.model.AccountMetaData";


    export namespace AccountMetaData {

        /**
         * Gets or Sets remoteStatus.
         * @enum
         * @property {io.nem.xpx.model.AccountMetaData.RemoteStatusEnum} REMOTE
         * The remote.
         * @property {io.nem.xpx.model.AccountMetaData.RemoteStatusEnum} ACTIVATING
         * The activating.
         * @property {io.nem.xpx.model.AccountMetaData.RemoteStatusEnum} ACTIVE
         * The active.
         * @property {io.nem.xpx.model.AccountMetaData.RemoteStatusEnum} DEACTIVATING
         * The deactivating.
         * @property {io.nem.xpx.model.AccountMetaData.RemoteStatusEnum} INACTIVE
         * The inactive.
         * @class
         */
        export enum RemoteStatusEnum {
            
            /**
             * The remote.
             */
            REMOTE, 
            /**
             * The activating.
             */
            ACTIVATING, 
            /**
             * The active.
             */
            ACTIVE, 
            /**
             * The deactivating.
             */
            DEACTIVATING, 
            /**
             * The inactive.
             */
            INACTIVE
        }

        /** @ignore */
        export class RemoteStatusEnum_$WRAPPER {
            /**
             * The value.
             */
            value;

            constructor(protected _$ordinal : number, protected _$name : string, value) {
                if(this.value===undefined) this.value = null;
                this.value = value;
            }

            /**
             * Gets the value.
             * 
             * @return {string} the value
             */
            public getValue() : string {
                return this.value;
            }

            /**
             * 
             * @return {string}
             */
            public toString() : string {
                return /* valueOf */new String(this.value).toString();
            }

            /**
             * From value.
             * 
             * @param {string} text the text
             * @return {io.nem.xpx.model.AccountMetaData.RemoteStatusEnum} the remote status enum
             */
            public static fromValue(text) : AccountMetaData.RemoteStatusEnum {
                {
                    let array153 = /* Enum.values */function() { let result: number[] = []; for(let val in io.nem.xpx.model.AccountMetaData.RemoteStatusEnum) { if(!isNaN(<any>val)) { result.push(parseInt(val,10)); } } return result; }();
                    for(let index152=0; index152 < array153.length; index152++) {
                        let b = array153[index152];
                        {
                            if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(/* valueOf */new String(io.nem.xpx.model.AccountMetaData.RemoteStatusEnum["_$wrappers"][b].value).toString(),text))) {
                                return b;
                            }
                        }
                    }
                }
                return null;
            }
            public name() : string { return this._$name; }
            public ordinal() : number { return this._$ordinal; }
        }
        RemoteStatusEnum["__class"] = "io.nem.xpx.model.AccountMetaData.RemoteStatusEnum";
        RemoteStatusEnum["__interfaces"] = ["java.lang.Comparable","java.io.Serializable"];


        export namespace RemoteStatusEnum {

            /**
             * The Class Adapter.
             * @class
             * @extends com.google.gson.TypeAdapter
             */
            export class Adapter extends com.google.gson.TypeAdapter<AccountMetaData.RemoteStatusEnum> {
                /**
                 * 
                 * @param {com.google.gson.stream.JsonWriter} jsonWriter
                 * @param {io.nem.xpx.model.AccountMetaData.RemoteStatusEnum} enumeration
                 */
                public write(jsonWriter : com.google.gson.stream.JsonWriter, enumeration : AccountMetaData.RemoteStatusEnum) {
                    jsonWriter.value(io.nem.xpx.model.AccountMetaData.RemoteStatusEnum["_$wrappers"][enumeration].getValue());
                }

                /**
                 * 
                 * @param {com.google.gson.stream.JsonReader} jsonReader
                 * @return {io.nem.xpx.model.AccountMetaData.RemoteStatusEnum}
                 */
                public read(jsonReader : com.google.gson.stream.JsonReader) : AccountMetaData.RemoteStatusEnum {
                    let value : string = jsonReader.nextString();
                    return AccountMetaData.RemoteStatusEnum_$WRAPPER.fromValue(/* valueOf */new String(value).toString());
                }

                constructor() {
                    super();
                }
            }
            Adapter["__class"] = "io.nem.xpx.model.AccountMetaData.RemoteStatusEnum.Adapter";

        }


        export namespace RemoteStatusEnum {

            /**
             * The Class Adapter.
             * @class
             * @extends com.google.gson.TypeAdapter
             */
            export class Adapter extends com.google.gson.TypeAdapter<AccountMetaData.RemoteStatusEnum> {
                /**
                 * 
                 * @param {com.google.gson.stream.JsonWriter} jsonWriter
                 * @param {io.nem.xpx.model.AccountMetaData.RemoteStatusEnum} enumeration
                 */
                public write(jsonWriter : com.google.gson.stream.JsonWriter, enumeration : AccountMetaData.RemoteStatusEnum) {
                    jsonWriter.value(io.nem.xpx.model.AccountMetaData.RemoteStatusEnum["_$wrappers"][enumeration].getValue());
                }

                /**
                 * 
                 * @param {com.google.gson.stream.JsonReader} jsonReader
                 * @return {io.nem.xpx.model.AccountMetaData.RemoteStatusEnum}
                 */
                public read(jsonReader : com.google.gson.stream.JsonReader) : AccountMetaData.RemoteStatusEnum {
                    let value : string = jsonReader.nextString();
                    return AccountMetaData.RemoteStatusEnum_$WRAPPER.fromValue(/* valueOf */new String(value).toString());
                }

                constructor() {
                    super();
                }
            }
            Adapter["__class"] = "io.nem.xpx.model.AccountMetaData.RemoteStatusEnum.Adapter";

        }

        RemoteStatusEnum["_$wrappers"] = [new RemoteStatusEnum_$WRAPPER(0, "REMOTE", "REMOTE"), new RemoteStatusEnum_$WRAPPER(1, "ACTIVATING", "ACTIVATING"), new RemoteStatusEnum_$WRAPPER(2, "ACTIVE", "ACTIVE"), new RemoteStatusEnum_$WRAPPER(3, "DEACTIVATING", "DEACTIVATING"), new RemoteStatusEnum_$WRAPPER(4, "INACTIVE", "INACTIVE")];


        /**
         * Gets or Sets status.
         * @enum
         * @property {io.nem.xpx.model.AccountMetaData.StatusEnum} UNKNOWN
         * The unknown.
         * @property {io.nem.xpx.model.AccountMetaData.StatusEnum} LOCKED
         * The locked.
         * @property {io.nem.xpx.model.AccountMetaData.StatusEnum} UNLOCKED
         * The unlocked.
         * @class
         */
        export enum StatusEnum {
            
            /**
             * The unknown.
             */
            UNKNOWN, 
            /**
             * The locked.
             */
            LOCKED, 
            /**
             * The unlocked.
             */
            UNLOCKED
        }

        /** @ignore */
        export class StatusEnum_$WRAPPER {
            /**
             * The value.
             */
            value;

            constructor(protected _$ordinal : number, protected _$name : string, value) {
                if(this.value===undefined) this.value = null;
                this.value = value;
            }

            /**
             * Gets the value.
             * 
             * @return {string} the value
             */
            public getValue() : string {
                return this.value;
            }

            /**
             * 
             * @return {string}
             */
            public toString() : string {
                return /* valueOf */new String(this.value).toString();
            }

            /**
             * From value.
             * 
             * @param {string} text the text
             * @return {io.nem.xpx.model.AccountMetaData.StatusEnum} the status enum
             */
            public static fromValue(text) : AccountMetaData.StatusEnum {
                {
                    let array155 = /* Enum.values */function() { let result: number[] = []; for(let val in io.nem.xpx.model.AccountMetaData.StatusEnum) { if(!isNaN(<any>val)) { result.push(parseInt(val,10)); } } return result; }();
                    for(let index154=0; index154 < array155.length; index154++) {
                        let b = array155[index154];
                        {
                            if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(/* valueOf */new String(io.nem.xpx.model.AccountMetaData.StatusEnum["_$wrappers"][b].value).toString(),text))) {
                                return b;
                            }
                        }
                    }
                }
                return null;
            }
            public name() : string { return this._$name; }
            public ordinal() : number { return this._$ordinal; }
        }
        StatusEnum["__class"] = "io.nem.xpx.model.AccountMetaData.StatusEnum";
        StatusEnum["__interfaces"] = ["java.lang.Comparable","java.io.Serializable"];


        export namespace StatusEnum {

            /**
             * The Class Adapter.
             * @class
             * @extends com.google.gson.TypeAdapter
             */
            export class Adapter extends com.google.gson.TypeAdapter<AccountMetaData.StatusEnum> {
                /**
                 * 
                 * @param {com.google.gson.stream.JsonWriter} jsonWriter
                 * @param {io.nem.xpx.model.AccountMetaData.StatusEnum} enumeration
                 */
                public write(jsonWriter : com.google.gson.stream.JsonWriter, enumeration : AccountMetaData.StatusEnum) {
                    jsonWriter.value(io.nem.xpx.model.AccountMetaData.StatusEnum["_$wrappers"][enumeration].getValue());
                }

                /**
                 * 
                 * @param {com.google.gson.stream.JsonReader} jsonReader
                 * @return {io.nem.xpx.model.AccountMetaData.StatusEnum}
                 */
                public read(jsonReader : com.google.gson.stream.JsonReader) : AccountMetaData.StatusEnum {
                    let value : string = jsonReader.nextString();
                    return AccountMetaData.StatusEnum_$WRAPPER.fromValue(/* valueOf */new String(value).toString());
                }

                constructor() {
                    super();
                }
            }
            Adapter["__class"] = "io.nem.xpx.model.AccountMetaData.StatusEnum.Adapter";

        }


        export namespace StatusEnum {

            /**
             * The Class Adapter.
             * @class
             * @extends com.google.gson.TypeAdapter
             */
            export class Adapter extends com.google.gson.TypeAdapter<AccountMetaData.StatusEnum> {
                /**
                 * 
                 * @param {com.google.gson.stream.JsonWriter} jsonWriter
                 * @param {io.nem.xpx.model.AccountMetaData.StatusEnum} enumeration
                 */
                public write(jsonWriter : com.google.gson.stream.JsonWriter, enumeration : AccountMetaData.StatusEnum) {
                    jsonWriter.value(io.nem.xpx.model.AccountMetaData.StatusEnum["_$wrappers"][enumeration].getValue());
                }

                /**
                 * 
                 * @param {com.google.gson.stream.JsonReader} jsonReader
                 * @return {io.nem.xpx.model.AccountMetaData.StatusEnum}
                 */
                public read(jsonReader : com.google.gson.stream.JsonReader) : AccountMetaData.StatusEnum {
                    let value : string = jsonReader.nextString();
                    return AccountMetaData.StatusEnum_$WRAPPER.fromValue(/* valueOf */new String(value).toString());
                }

                constructor() {
                    super();
                }
            }
            Adapter["__class"] = "io.nem.xpx.model.AccountMetaData.StatusEnum.Adapter";

        }

        StatusEnum["_$wrappers"] = [new StatusEnum_$WRAPPER(0, "UNKNOWN", "UNKNOWN"), new StatusEnum_$WRAPPER(1, "LOCKED", "LOCKED"), new StatusEnum_$WRAPPER(2, "UNLOCKED", "UNLOCKED")];

    }

}
namespace io.nem.xpx.model {
    /**
     * AccountMetaDataPair.
     * @class
     */
    export class AccountMetaDataPair {
        /**
         * The entity.
         */
        /*private*/ __entity : io.nem.xpx.model.AccountInfo = null;

        /**
         * The meta data.
         */
        /*private*/ __metaData : io.nem.xpx.model.AccountMetaData = null;

        /**
         * Entity.
         * 
         * @param {io.nem.xpx.model.AccountInfo} entity the entity
         * @return {io.nem.xpx.model.AccountMetaDataPair} the account meta data pair
         */
        public entity(entity : io.nem.xpx.model.AccountInfo) : AccountMetaDataPair {
            this.__entity = entity;
            return this;
        }

        /**
         * Get entity.
         * 
         * @return {io.nem.xpx.model.AccountInfo} entity
         */
        public getEntity() : io.nem.xpx.model.AccountInfo {
            return this.__entity;
        }

        /**
         * Sets the entity.
         * 
         * @param {io.nem.xpx.model.AccountInfo} entity the new entity
         */
        public setEntity(entity : io.nem.xpx.model.AccountInfo) {
            this.__entity = entity;
        }

        /**
         * Meta data.
         * 
         * @param {io.nem.xpx.model.AccountMetaData} metaData the meta data
         * @return {io.nem.xpx.model.AccountMetaDataPair} the account meta data pair
         */
        public metaData(metaData : io.nem.xpx.model.AccountMetaData) : AccountMetaDataPair {
            this.__metaData = metaData;
            return this;
        }

        /**
         * Get metaData.
         * 
         * @return {io.nem.xpx.model.AccountMetaData} metaData
         */
        public getMetaData() : io.nem.xpx.model.AccountMetaData {
            return this.__metaData;
        }

        /**
         * Sets the meta data.
         * 
         * @param {io.nem.xpx.model.AccountMetaData} metaData the new meta data
         */
        public setMetaData(metaData : io.nem.xpx.model.AccountMetaData) {
            this.__metaData = metaData;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let accountMetaDataPair : AccountMetaDataPair = <AccountMetaDataPair>o;
            return java.util.Objects.equals(this.__entity, accountMetaDataPair.__entity) && java.util.Objects.equals(this.__metaData, accountMetaDataPair.__metaData);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class AccountMetaDataPair {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__entity)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    entity: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__metaData)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    metaData: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    AccountMetaDataPair["__class"] = "io.nem.xpx.model.AccountMetaDataPair";

}
namespace io.nem.xpx.model {
    /**
     * Address.
     * @class
     */
    export class Address {
        /**
         * The encoded.
         */
        /*private*/ __encoded : string = null;

        /**
         * The public key.
         */
        /*private*/ __publicKey : io.nem.xpx.model.PublicKey = null;

        /**
         * The valid.
         */
        /*private*/ __valid : boolean = null;

        /**
         * The version.
         */
        /*private*/ __version : number[] = null;

        /**
         * Encoded.
         * 
         * @param {string} encoded the encoded
         * @return {io.nem.xpx.model.Address} the address
         */
        public encoded(encoded : string) : Address {
            this.__encoded = encoded;
            return this;
        }

        /**
         * Get encoded.
         * 
         * @return {string} encoded
         */
        public getEncoded() : string {
            return this.__encoded;
        }

        /**
         * Sets the encoded.
         * 
         * @param {string} encoded the new encoded
         */
        public setEncoded(encoded : string) {
            this.__encoded = encoded;
        }

        /**
         * Public key.
         * 
         * @param {io.nem.xpx.model.PublicKey} publicKey the public key
         * @return {io.nem.xpx.model.Address} the address
         */
        public publicKey(publicKey : io.nem.xpx.model.PublicKey) : Address {
            this.__publicKey = publicKey;
            return this;
        }

        /**
         * Get publicKey.
         * 
         * @return {io.nem.xpx.model.PublicKey} publicKey
         */
        public getPublicKey() : io.nem.xpx.model.PublicKey {
            return this.__publicKey;
        }

        /**
         * Sets the public key.
         * 
         * @param {io.nem.xpx.model.PublicKey} publicKey the new public key
         */
        public setPublicKey(publicKey : io.nem.xpx.model.PublicKey) {
            this.__publicKey = publicKey;
        }

        /**
         * Valid.
         * 
         * @param {boolean} valid the valid
         * @return {io.nem.xpx.model.Address} the address
         */
        public valid(valid : boolean) : Address {
            this.__valid = valid;
            return this;
        }

        /**
         * Get valid.
         * 
         * @return {boolean} valid
         */
        public getValid() : boolean {
            return this.__valid;
        }

        /**
         * Sets the valid.
         * 
         * @param {boolean} valid the new valid
         */
        public setValid(valid : boolean) {
            this.__valid = valid;
        }

        /**
         * Version.
         * 
         * @param {Array} version the version
         * @return {io.nem.xpx.model.Address} the address
         */
        public version(version : number[]) : Address {
            this.__version = version;
            return this;
        }

        /**
         * Get version.
         * 
         * @return {Array} version
         */
        public getVersion() : number[] {
            return this.__version;
        }

        /**
         * Sets the version.
         * 
         * @param {Array} version the new version
         */
        public setVersion(version : number[]) {
            this.__version = version;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let address : Address = <Address>o;
            return java.util.Objects.equals(this.__encoded, address.__encoded) && java.util.Objects.equals(this.__publicKey, address.__publicKey) && java.util.Objects.equals(this.__valid, address.__valid) && java.util.Objects.equals(this.__version, address.__version);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class Address {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__encoded)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    encoded: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__publicKey)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    publicKey: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__valid)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    valid: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__version)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    version: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    Address["__class"] = "io.nem.xpx.model.Address";

}
namespace io.nem.xpx.model {
    /**
     * Amount.
     * @class
     */
    export class Amount {
        /**
         * The num micro nem.
         */
        /*private*/ __numMicroNem : number = null;

        /**
         * The num nem.
         */
        /*private*/ __numNem : number = null;

        /**
         * Num micro nem.
         * 
         * @param {number} numMicroNem the num micro nem
         * @return {io.nem.xpx.model.Amount} the amount
         */
        public numMicroNem(numMicroNem : number) : Amount {
            this.__numMicroNem = numMicroNem;
            return this;
        }

        /**
         * Get numMicroNem.
         * 
         * @return {number} numMicroNem
         */
        public getNumMicroNem() : number {
            return this.__numMicroNem;
        }

        /**
         * Sets the num micro nem.
         * 
         * @param {number} numMicroNem the new num micro nem
         */
        public setNumMicroNem(numMicroNem : number) {
            this.__numMicroNem = numMicroNem;
        }

        /**
         * Num nem.
         * 
         * @param {number} numNem the num nem
         * @return {io.nem.xpx.model.Amount} the amount
         */
        public numNem(numNem : number) : Amount {
            this.__numNem = numNem;
            return this;
        }

        /**
         * Get numNem.
         * 
         * @return {number} numNem
         */
        public getNumNem() : number {
            return this.__numNem;
        }

        /**
         * Sets the num nem.
         * 
         * @param {number} numNem the new num nem
         */
        public setNumNem(numNem : number) {
            this.__numNem = numNem;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let amount : Amount = <Amount>o;
            return java.util.Objects.equals(this.__numMicroNem, amount.__numMicroNem) && java.util.Objects.equals(this.__numNem, amount.__numNem);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class Amount {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__numMicroNem)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    numMicroNem: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__numNem)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    numNem: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    Amount["__class"] = "io.nem.xpx.model.Amount";

}
namespace io.nem.xpx.model {
    /**
     * BlockAmount.
     * @class
     */
    export class BlockAmount {
        /**
         * The raw.
         */
        /*private*/ __raw : number = null;

        /**
         * Raw.
         * 
         * @param {number} raw the raw
         * @return {io.nem.xpx.model.BlockAmount} the block amount
         */
        public raw(raw : number) : BlockAmount {
            this.__raw = raw;
            return this;
        }

        /**
         * Get raw.
         * 
         * @return {number} raw
         */
        public getRaw() : number {
            return this.__raw;
        }

        /**
         * Sets the raw.
         * 
         * @param {number} raw the new raw
         */
        public setRaw(raw : number) {
            this.__raw = raw;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let blockAmount : BlockAmount = <BlockAmount>o;
            return java.util.Objects.equals(this.__raw, blockAmount.__raw);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class BlockAmount {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__raw)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    raw: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    BlockAmount["__class"] = "io.nem.xpx.model.BlockAmount";

}
namespace io.nem.xpx.model {
    /**
     * The Class DataHashByteArrayEntity.
     * @class
     */
    export class DataHashByteArrayEntity {
        /**
         * The file.
         */
        /*private*/ file : number[];

        /**
         * The name.
         */
        /*private*/ name : string;

        /**
         * The content type.
         */
        /*private*/ contentType : string;

        /**
         * The keywords.
         */
        /*private*/ keywords : string;

        /**
         * The size.
         */
        /*private*/ size : number;

        /**
         * Gets the size.
         * 
         * @return {number} the size
         */
        public getSize() : number {
            return this.size;
        }

        /**
         * Sets the size.
         * 
         * @param {number} size the new size
         */
        public setSize(size : number) {
            this.size = size;
        }

        /**
         * Gets the content type.
         * 
         * @return {string} the content type
         */
        public getContentType() : string {
            return this.contentType;
        }

        /**
         * Sets the content type.
         * 
         * @param {string} contentType the new content type
         */
        public setContentType(contentType : string) {
            this.contentType = contentType;
        }

        /**
         * The metadata.
         */
        /*private*/ metadata : any;

        /**
         * Gets the file.
         * 
         * @return {Array} the file
         */
        public getFile() : number[] {
            return this.file;
        }

        /**
         * Sets the file.
         * 
         * @param {Array} file the new file
         */
        public setFile(file : number[]) {
            this.file = file;
        }

        /**
         * Gets the keywords.
         * 
         * @return {string} the keywords
         */
        public getKeywords() : string {
            return this.keywords;
        }

        /**
         * Sets the keywords.
         * 
         * @param {string} keywords the new keywords
         */
        public setKeywords(keywords : string) {
            this.keywords = keywords;
        }

        /**
         * Gets the metadata.
         * 
         * @return {*} the metadata
         */
        public getMetadata() : any {
            return this.metadata;
        }

        /**
         * Sets the metadata.
         * 
         * @param {*} metadata the metadata
         */
        public setMetadata(metadata : any) {
            this.metadata = metadata;
        }

        /**
         * Gets the name.
         * 
         * @return {string} the name
         */
        public getName() : string {
            return this.name;
        }

        /**
         * Sets the name.
         * 
         * @param {string} name the new name
         */
        public setName(name : string) {
            this.name = name;
        }

        constructor() {
            if(this.file===undefined) this.file = null;
            if(this.name===undefined) this.name = null;
            if(this.contentType===undefined) this.contentType = null;
            if(this.keywords===undefined) this.keywords = null;
            if(this.size===undefined) this.size = 0;
            if(this.metadata===undefined) this.metadata = null;
        }
    }
    DataHashByteArrayEntity["__class"] = "io.nem.xpx.model.DataHashByteArrayEntity";

}
namespace io.nem.xpx.model {
    /**
     * The Class DataHashPathEntity.
     * @class
     */
    export class DataHashPathEntity {
        /**
         * The path.
         */
        /*private*/ path : string;

        /**
         * The name.
         */
        /*private*/ name : string;

        /**
         * The content type.
         */
        /*private*/ contentType : string;

        /**
         * The keywords.
         */
        /*private*/ keywords : string;

        /**
         * The size.
         */
        /*private*/ size : number;

        /**
         * Gets the size.
         * 
         * @return {number} the size
         */
        public getSize() : number {
            return this.size;
        }

        /**
         * Sets the size.
         * 
         * @param {number} size the new size
         */
        public setSize(size : number) {
            this.size = size;
        }

        /**
         * Gets the content type.
         * 
         * @return {string} the content type
         */
        public getContentType() : string {
            return this.contentType;
        }

        /**
         * Sets the content type.
         * 
         * @param {string} contentType the new content type
         */
        public setContentType(contentType : string) {
            this.contentType = contentType;
        }

        /**
         * The metadata.
         */
        /*private*/ metadata : any;

        /**
         * Gets the path.
         * 
         * @return {string} the path
         */
        public getPath() : string {
            return this.path;
        }

        /**
         * Sets the path.
         * 
         * @param {string} path the new path
         */
        public setPath(path : string) {
            this.path = path;
        }

        /**
         * Gets the keywords.
         * 
         * @return {string} the keywords
         */
        public getKeywords() : string {
            return this.keywords;
        }

        /**
         * Sets the keywords.
         * 
         * @param {string} keywords the new keywords
         */
        public setKeywords(keywords : string) {
            this.keywords = keywords;
        }

        /**
         * Gets the metadata.
         * 
         * @return {*} the metadata
         */
        public getMetadata() : any {
            return this.metadata;
        }

        /**
         * Sets the metadata.
         * 
         * @param {*} metadata the metadata
         */
        public setMetadata(metadata : any) {
            this.metadata = metadata;
        }

        /**
         * Gets the name.
         * 
         * @return {string} the name
         */
        public getName() : string {
            return this.name;
        }

        /**
         * Sets the name.
         * 
         * @param {string} name the new name
         */
        public setName(name : string) {
            this.name = name;
        }

        constructor() {
            if(this.path===undefined) this.path = null;
            if(this.name===undefined) this.name = null;
            if(this.contentType===undefined) this.contentType = null;
            if(this.keywords===undefined) this.keywords = null;
            if(this.size===undefined) this.size = 0;
            if(this.metadata===undefined) this.metadata = null;
        }
    }
    DataHashPathEntity["__class"] = "io.nem.xpx.model.DataHashPathEntity";

}
namespace io.nem.xpx.model {
    /**
     * Instantiates a new data response.
     * 
     * @param {string} data the data
     * @class
     */
    export class DataResponse {
        /**
         * The data.
         */
        /*private*/ data : string;

        public constructor(data : string) {
            if(this.data===undefined) this.data = null;
            this.data = data;
        }

        /**
         * Gets the data.
         * 
         * @return {string} the data
         */
        public getData() : string {
            return this.data;
        }

        /**
         * Sets the data.
         * 
         * @param {string} data the new data
         */
        public setData(data : string) {
            this.data = data;
        }

        /**
         * To json.
         * 
         * @return {string} the string
         */
        public toJson() : string {
            return io.nem.xpx.utils.JsonUtils.toJson(this);
        }
    }
    DataResponse["__class"] = "io.nem.xpx.model.DataResponse";

}
namespace io.nem.xpx.model {
    /**
     * The Class GeneratedAccount.
     * @class
     */
    export class GeneratedAccount {
        /**
         * The key pair.
         */
        /*private*/ keyPair : org.nem.core.crypto.KeyPair;

        /**
         * The account.
         */
        /*private*/ account : org.nem.core.model.Account;

        /**
         * The encoded address.
         */
        /*private*/ encodedAddress : string;

        /**
         * The encoded public key.
         */
        /*private*/ encodedPublicKey : string;

        /**
         * The encoded private key.
         */
        /*private*/ encodedPrivateKey : string;

        /**
         * Gets the encoded address.
         * 
         * @return {string} the encoded address
         */
        public getEncodedAddress() : string {
            return this.encodedAddress;
        }

        /**
         * Sets the encoded address.
         * 
         * @param {string} encodedAddress the new encoded address
         */
        public setEncodedAddress(encodedAddress : string) {
            this.encodedAddress = encodedAddress;
        }

        /**
         * Gets the encoded public key.
         * 
         * @return {string} the encoded public key
         */
        public getEncodedPublicKey() : string {
            return this.encodedPublicKey;
        }

        /**
         * Sets the encoded public key.
         * 
         * @param {string} encodedPublicKey the new encoded public key
         */
        public setEncodedPublicKey(encodedPublicKey : string) {
            this.encodedPublicKey = encodedPublicKey;
        }

        /**
         * Gets the encoded private key.
         * 
         * @return {string} the encoded private key
         */
        public getEncodedPrivateKey() : string {
            return this.encodedPrivateKey;
        }

        /**
         * Sets the encoded private key.
         * 
         * @param {string} encodedPrivateKey the new encoded private key
         */
        public setEncodedPrivateKey(encodedPrivateKey : string) {
            this.encodedPrivateKey = encodedPrivateKey;
        }

        /**
         * Gets the key pair.
         * 
         * @return {org.nem.core.crypto.KeyPair} the key pair
         */
        public getKeyPair() : org.nem.core.crypto.KeyPair {
            return this.keyPair;
        }

        /**
         * Sets the key pair.
         * 
         * @param {org.nem.core.crypto.KeyPair} keyPair the new key pair
         */
        public setKeyPair(keyPair : org.nem.core.crypto.KeyPair) {
            this.keyPair = keyPair;
        }

        /**
         * Gets the account.
         * 
         * @return {org.nem.core.model.Account} the account
         */
        public getAccount() : org.nem.core.model.Account {
            return this.account;
        }

        /**
         * Sets the account.
         * 
         * @param {org.nem.core.model.Account} account the new account
         */
        public setAccount(account : org.nem.core.model.Account) {
            this.account = account;
        }

        constructor() {
            if(this.keyPair===undefined) this.keyPair = null;
            if(this.account===undefined) this.account = null;
            if(this.encodedAddress===undefined) this.encodedAddress = null;
            if(this.encodedPublicKey===undefined) this.encodedPublicKey = null;
            if(this.encodedPrivateKey===undefined) this.encodedPrivateKey = null;
        }
    }
    GeneratedAccount["__class"] = "io.nem.xpx.model.GeneratedAccount";

}
namespace io.nem.xpx.model {
    /**
     * GenericResponseMessage.
     * @class
     */
    export class GenericResponseMessage {
        /**
         * The message.
         */
        /*private*/ __message : string = null;

        /**
         * The status.
         */
        /*private*/ __status : GenericResponseMessage.StatusEnum = null;

        /**
         * Message.
         * 
         * @param {string} message the message
         * @return {io.nem.xpx.model.GenericResponseMessage} the generic response message
         */
        public message(message : string) : GenericResponseMessage {
            this.__message = message;
            return this;
        }

        /**
         * Get message.
         * 
         * @return {string} message
         */
        public getMessage() : string {
            return this.__message;
        }

        /**
         * Sets the message.
         * 
         * @param {string} message the new message
         */
        public setMessage(message : string) {
            this.__message = message;
        }

        /**
         * Status.
         * 
         * @param {io.nem.xpx.model.GenericResponseMessage.StatusEnum} status the status
         * @return {io.nem.xpx.model.GenericResponseMessage} the generic response message
         */
        public status(status : GenericResponseMessage.StatusEnum) : GenericResponseMessage {
            this.__status = status;
            return this;
        }

        /**
         * Get status.
         * 
         * @return {io.nem.xpx.model.GenericResponseMessage.StatusEnum} status
         */
        public getStatus() : GenericResponseMessage.StatusEnum {
            return this.__status;
        }

        /**
         * Sets the status.
         * 
         * @param {io.nem.xpx.model.GenericResponseMessage.StatusEnum} status the new status
         */
        public setStatus(status : GenericResponseMessage.StatusEnum) {
            this.__status = status;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let genericResponseMessage : GenericResponseMessage = <GenericResponseMessage>o;
            return java.util.Objects.equals(this.__message, genericResponseMessage.__message) && java.util.Objects.equals(this.__status, genericResponseMessage.__status);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class GenericResponseMessage {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__message)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    message: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__status)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    status: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    GenericResponseMessage["__class"] = "io.nem.xpx.model.GenericResponseMessage";


    export namespace GenericResponseMessage {

        /**
         * Gets or Sets status.
         * @enum
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _100
         * The  100.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _101
         * The  101.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _102
         * The  102.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _103
         * The  103.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _200
         * The  200.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _201
         * The  201.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _202
         * The  202.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _203
         * The  203.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _204
         * The  204.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _205
         * The  205.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _206
         * The  206.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _207
         * The  207.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _208
         * The  208.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _226
         * The  226.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _300
         * The  300.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _301
         * The  301.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _302
         * The  302.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _303
         * The  303.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _304
         * The  304.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _305
         * The  305.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _307
         * The  307.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _308
         * The  308.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _400
         * The  400.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _401
         * The  401.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _402
         * The  402.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _403
         * The  403.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _404
         * The  404.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _405
         * The  405.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _406
         * The  406.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _407
         * The  407.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _408
         * The  408.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _409
         * The  409.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _410
         * The  410.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _411
         * The  411.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _412
         * The  412.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _413
         * The  413.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _414
         * The  414.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _415
         * The  415.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _416
         * The  416.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _417
         * The  417.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _418
         * The  418.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _419
         * The  419.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _420
         * The  420.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _421
         * The  421.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _422
         * The  422.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _423
         * The  423.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _424
         * The  424.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _426
         * The  426.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _428
         * The  428.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _429
         * The  429.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _431
         * The  431.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _451
         * The  451.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _500
         * The  500.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _501
         * The  501.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _502
         * The  502.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _503
         * The  503.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _504
         * The  504.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _505
         * The  505.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _506
         * The  506.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _507
         * The  507.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _508
         * The  508.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _509
         * The  509.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _510
         * The  510.
         * @property {io.nem.xpx.model.GenericResponseMessage.StatusEnum} _511
         * The  511.
         * @class
         */
        export enum StatusEnum {
            
            /**
             * The  100.
             */
            _100, 
            /**
             * The  101.
             */
            _101, 
            /**
             * The  102.
             */
            _102, 
            /**
             * The  103.
             */
            _103, 
            /**
             * The  200.
             */
            _200, 
            /**
             * The  201.
             */
            _201, 
            /**
             * The  202.
             */
            _202, 
            /**
             * The  203.
             */
            _203, 
            /**
             * The  204.
             */
            _204, 
            /**
             * The  205.
             */
            _205, 
            /**
             * The  206.
             */
            _206, 
            /**
             * The  207.
             */
            _207, 
            /**
             * The  208.
             */
            _208, 
            /**
             * The  226.
             */
            _226, 
            /**
             * The  300.
             */
            _300, 
            /**
             * The  301.
             */
            _301, 
            /**
             * The  302.
             */
            _302, 
            /**
             * The  303.
             */
            _303, 
            /**
             * The  304.
             */
            _304, 
            /**
             * The  305.
             */
            _305, 
            /**
             * The  307.
             */
            _307, 
            /**
             * The  308.
             */
            _308, 
            /**
             * The  400.
             */
            _400, 
            /**
             * The  401.
             */
            _401, 
            /**
             * The  402.
             */
            _402, 
            /**
             * The  403.
             */
            _403, 
            /**
             * The  404.
             */
            _404, 
            /**
             * The  405.
             */
            _405, 
            /**
             * The  406.
             */
            _406, 
            /**
             * The  407.
             */
            _407, 
            /**
             * The  408.
             */
            _408, 
            /**
             * The  409.
             */
            _409, 
            /**
             * The  410.
             */
            _410, 
            /**
             * The  411.
             */
            _411, 
            /**
             * The  412.
             */
            _412, 
            /**
             * The  413.
             */
            _413, 
            /**
             * The  414.
             */
            _414, 
            /**
             * The  415.
             */
            _415, 
            /**
             * The  416.
             */
            _416, 
            /**
             * The  417.
             */
            _417, 
            /**
             * The  418.
             */
            _418, 
            /**
             * The  419.
             */
            _419, 
            /**
             * The  420.
             */
            _420, 
            /**
             * The  421.
             */
            _421, 
            /**
             * The  422.
             */
            _422, 
            /**
             * The  423.
             */
            _423, 
            /**
             * The  424.
             */
            _424, 
            /**
             * The  426.
             */
            _426, 
            /**
             * The  428.
             */
            _428, 
            /**
             * The  429.
             */
            _429, 
            /**
             * The  431.
             */
            _431, 
            /**
             * The  451.
             */
            _451, 
            /**
             * The  500.
             */
            _500, 
            /**
             * The  501.
             */
            _501, 
            /**
             * The  502.
             */
            _502, 
            /**
             * The  503.
             */
            _503, 
            /**
             * The  504.
             */
            _504, 
            /**
             * The  505.
             */
            _505, 
            /**
             * The  506.
             */
            _506, 
            /**
             * The  507.
             */
            _507, 
            /**
             * The  508.
             */
            _508, 
            /**
             * The  509.
             */
            _509, 
            /**
             * The  510.
             */
            _510, 
            /**
             * The  511.
             */
            _511
        }

        /** @ignore */
        export class StatusEnum_$WRAPPER {
            /**
             * The value.
             */
            value;

            constructor(protected _$ordinal : number, protected _$name : string, value) {
                if(this.value===undefined) this.value = null;
                this.value = value;
            }

            /**
             * Gets the value.
             * 
             * @return {string} the value
             */
            public getValue() : string {
                return this.value;
            }

            /**
             * 
             * @return {string}
             */
            public toString() : string {
                return /* valueOf */new String(this.value).toString();
            }

            /**
             * From value.
             * 
             * @param {string} text the text
             * @return {io.nem.xpx.model.GenericResponseMessage.StatusEnum} the status enum
             */
            public static fromValue(text) : GenericResponseMessage.StatusEnum {
                {
                    let array157 = /* Enum.values */function() { let result: number[] = []; for(let val in io.nem.xpx.model.GenericResponseMessage.StatusEnum) { if(!isNaN(<any>val)) { result.push(parseInt(val,10)); } } return result; }();
                    for(let index156=0; index156 < array157.length; index156++) {
                        let b = array157[index156];
                        {
                            if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(/* valueOf */new String(io.nem.xpx.model.GenericResponseMessage.StatusEnum["_$wrappers"][b].value).toString(),text))) {
                                return b;
                            }
                        }
                    }
                }
                return null;
            }
            public name() : string { return this._$name; }
            public ordinal() : number { return this._$ordinal; }
        }
        StatusEnum["__class"] = "io.nem.xpx.model.GenericResponseMessage.StatusEnum";
        StatusEnum["__interfaces"] = ["java.lang.Comparable","java.io.Serializable"];


        export namespace StatusEnum {

            /**
             * The Class Adapter.
             * @class
             * @extends com.google.gson.TypeAdapter
             */
            export class Adapter extends com.google.gson.TypeAdapter<GenericResponseMessage.StatusEnum> {
                /**
                 * 
                 * @param {com.google.gson.stream.JsonWriter} jsonWriter
                 * @param {io.nem.xpx.model.GenericResponseMessage.StatusEnum} enumeration
                 */
                public write(jsonWriter : com.google.gson.stream.JsonWriter, enumeration : GenericResponseMessage.StatusEnum) {
                    jsonWriter.value(io.nem.xpx.model.GenericResponseMessage.StatusEnum["_$wrappers"][enumeration].getValue());
                }

                /**
                 * 
                 * @param {com.google.gson.stream.JsonReader} jsonReader
                 * @return {io.nem.xpx.model.GenericResponseMessage.StatusEnum}
                 */
                public read(jsonReader : com.google.gson.stream.JsonReader) : GenericResponseMessage.StatusEnum {
                    let value : string = jsonReader.nextString();
                    return GenericResponseMessage.StatusEnum_$WRAPPER.fromValue(/* valueOf */new String(value).toString());
                }

                constructor() {
                    super();
                }
            }
            Adapter["__class"] = "io.nem.xpx.model.GenericResponseMessage.StatusEnum.Adapter";

        }


        export namespace StatusEnum {

            /**
             * The Class Adapter.
             * @class
             * @extends com.google.gson.TypeAdapter
             */
            export class Adapter extends com.google.gson.TypeAdapter<GenericResponseMessage.StatusEnum> {
                /**
                 * 
                 * @param {com.google.gson.stream.JsonWriter} jsonWriter
                 * @param {io.nem.xpx.model.GenericResponseMessage.StatusEnum} enumeration
                 */
                public write(jsonWriter : com.google.gson.stream.JsonWriter, enumeration : GenericResponseMessage.StatusEnum) {
                    jsonWriter.value(io.nem.xpx.model.GenericResponseMessage.StatusEnum["_$wrappers"][enumeration].getValue());
                }

                /**
                 * 
                 * @param {com.google.gson.stream.JsonReader} jsonReader
                 * @return {io.nem.xpx.model.GenericResponseMessage.StatusEnum}
                 */
                public read(jsonReader : com.google.gson.stream.JsonReader) : GenericResponseMessage.StatusEnum {
                    let value : string = jsonReader.nextString();
                    return GenericResponseMessage.StatusEnum_$WRAPPER.fromValue(/* valueOf */new String(value).toString());
                }

                constructor() {
                    super();
                }
            }
            Adapter["__class"] = "io.nem.xpx.model.GenericResponseMessage.StatusEnum.Adapter";

        }

        StatusEnum["_$wrappers"] = [new StatusEnum_$WRAPPER(0, "_100", "100"), new StatusEnum_$WRAPPER(1, "_101", "101"), new StatusEnum_$WRAPPER(2, "_102", "102"), new StatusEnum_$WRAPPER(3, "_103", "103"), new StatusEnum_$WRAPPER(4, "_200", "200"), new StatusEnum_$WRAPPER(5, "_201", "201"), new StatusEnum_$WRAPPER(6, "_202", "202"), new StatusEnum_$WRAPPER(7, "_203", "203"), new StatusEnum_$WRAPPER(8, "_204", "204"), new StatusEnum_$WRAPPER(9, "_205", "205"), new StatusEnum_$WRAPPER(10, "_206", "206"), new StatusEnum_$WRAPPER(11, "_207", "207"), new StatusEnum_$WRAPPER(12, "_208", "208"), new StatusEnum_$WRAPPER(13, "_226", "226"), new StatusEnum_$WRAPPER(14, "_300", "300"), new StatusEnum_$WRAPPER(15, "_301", "301"), new StatusEnum_$WRAPPER(16, "_302", "302"), new StatusEnum_$WRAPPER(17, "_303", "303"), new StatusEnum_$WRAPPER(18, "_304", "304"), new StatusEnum_$WRAPPER(19, "_305", "305"), new StatusEnum_$WRAPPER(20, "_307", "307"), new StatusEnum_$WRAPPER(21, "_308", "308"), new StatusEnum_$WRAPPER(22, "_400", "400"), new StatusEnum_$WRAPPER(23, "_401", "401"), new StatusEnum_$WRAPPER(24, "_402", "402"), new StatusEnum_$WRAPPER(25, "_403", "403"), new StatusEnum_$WRAPPER(26, "_404", "404"), new StatusEnum_$WRAPPER(27, "_405", "405"), new StatusEnum_$WRAPPER(28, "_406", "406"), new StatusEnum_$WRAPPER(29, "_407", "407"), new StatusEnum_$WRAPPER(30, "_408", "408"), new StatusEnum_$WRAPPER(31, "_409", "409"), new StatusEnum_$WRAPPER(32, "_410", "410"), new StatusEnum_$WRAPPER(33, "_411", "411"), new StatusEnum_$WRAPPER(34, "_412", "412"), new StatusEnum_$WRAPPER(35, "_413", "413"), new StatusEnum_$WRAPPER(36, "_414", "414"), new StatusEnum_$WRAPPER(37, "_415", "415"), new StatusEnum_$WRAPPER(38, "_416", "416"), new StatusEnum_$WRAPPER(39, "_417", "417"), new StatusEnum_$WRAPPER(40, "_418", "418"), new StatusEnum_$WRAPPER(41, "_419", "419"), new StatusEnum_$WRAPPER(42, "_420", "420"), new StatusEnum_$WRAPPER(43, "_421", "421"), new StatusEnum_$WRAPPER(44, "_422", "422"), new StatusEnum_$WRAPPER(45, "_423", "423"), new StatusEnum_$WRAPPER(46, "_424", "424"), new StatusEnum_$WRAPPER(47, "_426", "426"), new StatusEnum_$WRAPPER(48, "_428", "428"), new StatusEnum_$WRAPPER(49, "_429", "429"), new StatusEnum_$WRAPPER(50, "_431", "431"), new StatusEnum_$WRAPPER(51, "_451", "451"), new StatusEnum_$WRAPPER(52, "_500", "500"), new StatusEnum_$WRAPPER(53, "_501", "501"), new StatusEnum_$WRAPPER(54, "_502", "502"), new StatusEnum_$WRAPPER(55, "_503", "503"), new StatusEnum_$WRAPPER(56, "_504", "504"), new StatusEnum_$WRAPPER(57, "_505", "505"), new StatusEnum_$WRAPPER(58, "_506", "506"), new StatusEnum_$WRAPPER(59, "_507", "507"), new StatusEnum_$WRAPPER(60, "_508", "508"), new StatusEnum_$WRAPPER(61, "_509", "509"), new StatusEnum_$WRAPPER(62, "_510", "510"), new StatusEnum_$WRAPPER(63, "_511", "511")];

    }

}
namespace io.nem.xpx.model {
    /**
     * InputStream.
     * @class
     */
    export class InputStream {
        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            return true;
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class InputStream {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    InputStream["__class"] = "io.nem.xpx.model.InputStream";

}
namespace io.nem.xpx.model {
    /**
     * KeyPair.
     * @class
     */
    export class KeyPair {
        /**
         * The private key.
         */
        /*private*/ __privateKey : io.nem.xpx.model.PrivateKey = null;

        /**
         * The public key.
         */
        /*private*/ __publicKey : io.nem.xpx.model.PublicKey = null;

        /**
         * Private key.
         * 
         * @param {io.nem.xpx.model.PrivateKey} privateKey the private key
         * @return {io.nem.xpx.model.KeyPair} the key pair
         */
        public privateKey(privateKey : io.nem.xpx.model.PrivateKey) : KeyPair {
            this.__privateKey = privateKey;
            return this;
        }

        /**
         * Get privateKey.
         * 
         * @return {io.nem.xpx.model.PrivateKey} privateKey
         */
        public getPrivateKey() : io.nem.xpx.model.PrivateKey {
            return this.__privateKey;
        }

        /**
         * Sets the private key.
         * 
         * @param {io.nem.xpx.model.PrivateKey} privateKey the new private key
         */
        public setPrivateKey(privateKey : io.nem.xpx.model.PrivateKey) {
            this.__privateKey = privateKey;
        }

        /**
         * Public key.
         * 
         * @param {io.nem.xpx.model.PublicKey} publicKey the public key
         * @return {io.nem.xpx.model.KeyPair} the key pair
         */
        public publicKey(publicKey : io.nem.xpx.model.PublicKey) : KeyPair {
            this.__publicKey = publicKey;
            return this;
        }

        /**
         * Get publicKey.
         * 
         * @return {io.nem.xpx.model.PublicKey} publicKey
         */
        public getPublicKey() : io.nem.xpx.model.PublicKey {
            return this.__publicKey;
        }

        /**
         * Sets the public key.
         * 
         * @param {io.nem.xpx.model.PublicKey} publicKey the new public key
         */
        public setPublicKey(publicKey : io.nem.xpx.model.PublicKey) {
            this.__publicKey = publicKey;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let keyPair : KeyPair = <KeyPair>o;
            return java.util.Objects.equals(this.__privateKey, keyPair.__privateKey) && java.util.Objects.equals(this.__publicKey, keyPair.__publicKey);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class KeyPair {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__privateKey)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    privateKey: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__publicKey)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    publicKey: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    KeyPair["__class"] = "io.nem.xpx.model.KeyPair";

}
namespace io.nem.xpx.model {
    /**
     * MultisigInfo.
     * @class
     */
    export class MultisigInfo {
        /**
         * The cosignatories count.
         */
        /*private*/ __cosignatoriesCount : number = null;

        /**
         * The min cosignatories.
         */
        /*private*/ __minCosignatories : number = null;

        /**
         * Cosignatories count.
         * 
         * @param {number} cosignatoriesCount the cosignatories count
         * @return {io.nem.xpx.model.MultisigInfo} the multisig info
         */
        public cosignatoriesCount(cosignatoriesCount : number) : MultisigInfo {
            this.__cosignatoriesCount = cosignatoriesCount;
            return this;
        }

        /**
         * Get cosignatoriesCount.
         * 
         * @return {number} cosignatoriesCount
         */
        public getCosignatoriesCount() : number {
            return this.__cosignatoriesCount;
        }

        /**
         * Sets the cosignatories count.
         * 
         * @param {number} cosignatoriesCount the new cosignatories count
         */
        public setCosignatoriesCount(cosignatoriesCount : number) {
            this.__cosignatoriesCount = cosignatoriesCount;
        }

        /**
         * Min cosignatories.
         * 
         * @param {number} minCosignatories the min cosignatories
         * @return {io.nem.xpx.model.MultisigInfo} the multisig info
         */
        public minCosignatories(minCosignatories : number) : MultisigInfo {
            this.__minCosignatories = minCosignatories;
            return this;
        }

        /**
         * Get minCosignatories.
         * 
         * @return {number} minCosignatories
         */
        public getMinCosignatories() : number {
            return this.__minCosignatories;
        }

        /**
         * Sets the min cosignatories.
         * 
         * @param {number} minCosignatories the new min cosignatories
         */
        public setMinCosignatories(minCosignatories : number) {
            this.__minCosignatories = minCosignatories;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let multisigInfo : MultisigInfo = <MultisigInfo>o;
            return java.util.Objects.equals(this.__cosignatoriesCount, multisigInfo.__cosignatoriesCount) && java.util.Objects.equals(this.__minCosignatories, multisigInfo.__minCosignatories);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class MultisigInfo {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__cosignatoriesCount)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    cosignatoriesCount: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__minCosignatories)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    minCosignatories: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    MultisigInfo["__class"] = "io.nem.xpx.model.MultisigInfo";

}
namespace io.nem.xpx.model {
    /**
     * The Enum NemMessageType.
     * @enum
     * @property {io.nem.xpx.model.NemMessageType} PLAIN
     * The plain.
     * @property {io.nem.xpx.model.NemMessageType} SECURE
     * The secure.
     * @class
     */
    export enum NemMessageType {
        
        /**
         * The plain.
         */
        PLAIN, 
        /**
         * The secure.
         */
        SECURE
    }

    /** @ignore */
    export class NemMessageType_$WRAPPER {
        /**
         * The value.
         */
        /*private*/ value;

        constructor(protected _$ordinal : number, protected _$name : string, value) {
            if(this.value===undefined) this.value = 0;
            this.value = value;
        }

        /**
         * Gets the value.
         * 
         * @return {number} the value
         */
        public getValue() : number {
            return this.value;
        }

        /**
         * From int.
         * 
         * @param {number} type the type
         * @return {io.nem.xpx.model.NemMessageType} the nem message type
         */
        public static fromInt(type) : NemMessageType {
            return java.util.stream.Stream.of<any>(NemMessageType_$WRAPPER.values()).filter((messageType) => io.nem.xpx.model.NemMessageType["_$wrappers"][messageType].getValue() === type).findFirst().orElse(null);
        }
        public name() : string { return this._$name; }
        public ordinal() : number { return this._$ordinal; }
    }
    NemMessageType["__class"] = "io.nem.xpx.model.NemMessageType";
    NemMessageType["__interfaces"] = ["java.lang.Comparable","java.io.Serializable"];

    NemMessageType["_$wrappers"] = [new NemMessageType_$WRAPPER(0, "PLAIN", org.nem.core.model.MessageTypes.PLAIN), new NemMessageType_$WRAPPER(1, "SECURE", org.nem.core.model.MessageTypes.SECURE)];

}
namespace io.nem.xpx.model {
    /**
     * The Class NemTransactionInfo.
     * @class
     */
    export class NemTransactionInfo {
        /**
         * The nem hash.
         */
        /*private*/ nemHash : string;

        /**
         * The sender.
         */
        /*private*/ sender : string;

        /**
         * The receiver.
         */
        /*private*/ receiver : string;

        /**
         * The payload.
         */
        /*private*/ payload : string;

        /**
         * Gets the nem hash.
         * 
         * @return {string} the nem hash
         */
        public getNemHash() : string {
            return this.nemHash;
        }

        /**
         * Sets the nem hash.
         * 
         * @param {string} nemHash the new nem hash
         */
        public setNemHash(nemHash : string) {
            this.nemHash = nemHash;
        }

        /**
         * Gets the sender.
         * 
         * @return {string} the sender
         */
        public getSender() : string {
            return this.sender;
        }

        /**
         * Sets the sender.
         * 
         * @param {string} sender the new sender
         */
        public setSender(sender : string) {
            this.sender = sender;
        }

        /**
         * Gets the receiver.
         * 
         * @return {string} the receiver
         */
        public getReceiver() : string {
            return this.receiver;
        }

        /**
         * Sets the receiver.
         * 
         * @param {string} receiver the new receiver
         */
        public setReceiver(receiver : string) {
            this.receiver = receiver;
        }

        /**
         * Gets the payload.
         * 
         * @return {string} the payload
         */
        public getPayload() : string {
            return this.payload;
        }

        /**
         * Sets the payload.
         * 
         * @param {string} payload the new payload
         */
        public setPayload(payload : string) {
            this.payload = payload;
        }

        constructor() {
            if(this.nemHash===undefined) this.nemHash = null;
            if(this.sender===undefined) this.sender = null;
            if(this.receiver===undefined) this.receiver = null;
            if(this.payload===undefined) this.payload = null;
        }
    }
    NemTransactionInfo["__class"] = "io.nem.xpx.model.NemTransactionInfo";
    NemTransactionInfo["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.model {
    /**
     * NodeInfo.
     * @class
     */
    export class NodeInfo {
        /**
         * The context uri.
         */
        /*private*/ __contextUri : string = null;

        /**
         * The nem address.
         */
        /*private*/ __nemAddress : string = null;

        /**
         * The network.
         */
        /*private*/ __network : string = null;

        /**
         * The network address.
         */
        /*private*/ __networkAddress : string = null;

        /**
         * The network port.
         */
        /*private*/ __networkPort : string = null;

        /**
         * The peer id.
         */
        /*private*/ __peerId : string = null;

        /**
         * Tlist of gateway URLs where uploads will be sync.
         */
        /*private*/ syncGateways : Array<string> = null;

        /**
         * Context uri.
         * 
         * @param {string} contextUri the context uri
         * @return {io.nem.xpx.model.NodeInfo} the node info
         */
        public contextUri(contextUri : string) : NodeInfo {
            this.__contextUri = contextUri;
            return this;
        }

        /**
         * Get contextUri.
         * 
         * @return {string} contextUri
         */
        public getContextUri() : string {
            return this.__contextUri;
        }

        /**
         * Sets the context uri.
         * 
         * @param {string} contextUri the new context uri
         */
        public setContextUri(contextUri : string) {
            this.__contextUri = contextUri;
        }

        /**
         * Nem address.
         * 
         * @param {string} nemAddress the nem address
         * @return {io.nem.xpx.model.NodeInfo} the node info
         */
        public nemAddress(nemAddress : string) : NodeInfo {
            this.__nemAddress = nemAddress;
            return this;
        }

        /**
         * Get nemAddress.
         * 
         * @return {string} nemAddress
         */
        public getNemAddress() : string {
            return this.__nemAddress;
        }

        /**
         * Sets the nem address.
         * 
         * @param {string} nemAddress the new nem address
         */
        public setNemAddress(nemAddress : string) {
            this.__nemAddress = nemAddress;
        }

        /**
         * Network.
         * 
         * @param {string} network the network
         * @return {io.nem.xpx.model.NodeInfo} the node info
         */
        public network(network : string) : NodeInfo {
            this.__network = network;
            return this;
        }

        /**
         * Get network.
         * 
         * @return {string} network
         */
        public getNetwork() : string {
            return this.__network;
        }

        /**
         * Sets the network.
         * 
         * @param {string} network the new network
         */
        public setNetwork(network : string) {
            this.__network = network;
        }

        /**
         * Network address.
         * 
         * @param {string} networkAddress the network address
         * @return {io.nem.xpx.model.NodeInfo} the node info
         */
        public networkAddress(networkAddress : string) : NodeInfo {
            this.__networkAddress = networkAddress;
            return this;
        }

        /**
         * Get networkAddress.
         * 
         * @return {string} networkAddress
         */
        public getNetworkAddress() : string {
            return this.__networkAddress;
        }

        /**
         * Sets the network address.
         * 
         * @param {string} networkAddress the new network address
         */
        public setNetworkAddress(networkAddress : string) {
            this.__networkAddress = networkAddress;
        }

        /**
         * Network port.
         * 
         * @param {string} networkPort the network port
         * @return {io.nem.xpx.model.NodeInfo} the node info
         */
        public networkPort(networkPort : string) : NodeInfo {
            this.__networkPort = networkPort;
            return this;
        }

        /**
         * Get networkPort.
         * 
         * @return {string} networkPort
         */
        public getNetworkPort() : string {
            return this.__networkPort;
        }

        /**
         * Sets the network port.
         * 
         * @param {string} networkPort the new network port
         */
        public setNetworkPort(networkPort : string) {
            this.__networkPort = networkPort;
        }

        /**
         * Peer id.
         * 
         * @param {string} peerId the peer id
         * @return {io.nem.xpx.model.NodeInfo} the node info
         */
        public peerId(peerId : string) : NodeInfo {
            this.__peerId = peerId;
            return this;
        }

        /**
         * Get peerId.
         * 
         * @return {string} peerId
         */
        public getPeerId() : string {
            return this.__peerId;
        }

        /**
         * Sets the peer id.
         * 
         * @param {string} peerId the new peer id
         */
        public setPeerId(peerId : string) {
            this.__peerId = peerId;
        }

        public getSyncGateways() : Array<string> {
            return this.syncGateways;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let nodeInfo : NodeInfo = <NodeInfo>o;
            return java.util.Objects.equals(this.__contextUri, nodeInfo.__contextUri) && java.util.Objects.equals(this.__nemAddress, nodeInfo.__nemAddress) && java.util.Objects.equals(this.__network, nodeInfo.__network) && java.util.Objects.equals(this.__networkAddress, nodeInfo.__networkAddress) && java.util.Objects.equals(this.__networkPort, nodeInfo.__networkPort) && java.util.Objects.equals(this.__peerId, nodeInfo.__peerId);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class NodeInfo {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__contextUri)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    contextUri: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__nemAddress)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    nemAddress: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__network)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    network: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__networkAddress)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    networkAddress: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__networkPort)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    networkPort: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__peerId)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    peerId: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    NodeInfo["__class"] = "io.nem.xpx.model.NodeInfo";

}
namespace io.nem.xpx.model {
    /**
     * BinaryTransactionEncryptedMessage.
     * @class
     */
    export class PathTransactionEncryptedMessage {
        /**
         * The digest.
         */
        /*private*/ __digest : string = null;

        /**
         * The hash.
         */
        /*private*/ __hash : string = null;

        /**
         * The keywords.
         */
        /*private*/ __keywords : string = null;

        /**
         * The meta data.
         */
        /*private*/ __metaData : string = null;

        /**
         * The name.
         */
        /*private*/ __name : string = null;

        /**
         * The size.
         */
        /*private*/ __size : number = null;

        /**
         * The timestamp.
         */
        /*private*/ __timestamp : number = null;

        /**
         * The type.
         */
        /*private*/ __type : string = null;

        /**
         * Digest.
         * 
         * @param {string} digest the digest
         * @return {io.nem.xpx.model.PathTransactionEncryptedMessage} the path transaction encrypted message
         */
        public digest(digest : string) : PathTransactionEncryptedMessage {
            this.__digest = digest;
            return this;
        }

        /**
         * Get digest.
         * 
         * @return {string} digest
         */
        public getDigest() : string {
            return this.__digest;
        }

        /**
         * Sets the digest.
         * 
         * @param {string} digest the new digest
         */
        public setDigest(digest : string) {
            this.__digest = digest;
        }

        /**
         * Hash.
         * 
         * @param {string} hash the hash
         * @return {io.nem.xpx.model.PathTransactionEncryptedMessage} the path transaction encrypted message
         */
        public hash(hash : string) : PathTransactionEncryptedMessage {
            this.__hash = hash;
            return this;
        }

        /**
         * Get hash.
         * 
         * @return {string} hash
         */
        public getHash() : string {
            return this.__hash;
        }

        /**
         * Sets the hash.
         * 
         * @param {string} hash the new hash
         */
        public setHash(hash : string) {
            this.__hash = hash;
        }

        /**
         * Keywords.
         * 
         * @param {string} keywords the keywords
         * @return {io.nem.xpx.model.PathTransactionEncryptedMessage} the path transaction encrypted message
         */
        public keywords(keywords : string) : PathTransactionEncryptedMessage {
            this.__keywords = keywords;
            return this;
        }

        /**
         * Get keywords.
         * 
         * @return {string} keywords
         */
        public getKeywords() : string {
            return this.__keywords;
        }

        /**
         * Sets the keywords.
         * 
         * @param {string} keywords the new keywords
         */
        public setKeywords(keywords : string) {
            this.__keywords = keywords;
        }

        /**
         * Meta data.
         * 
         * @param {string} metaData the meta data
         * @return {io.nem.xpx.model.PathTransactionEncryptedMessage} the path transaction encrypted message
         */
        public metaData(metaData : string) : PathTransactionEncryptedMessage {
            this.__metaData = metaData;
            return this;
        }

        /**
         * Get metaData.
         * 
         * @return {string} metaData
         */
        public getMetaData() : string {
            return this.__metaData;
        }

        /**
         * Sets the meta data.
         * 
         * @param {string} metaData the new meta data
         */
        public setMetaData(metaData : string) {
            this.__metaData = metaData;
        }

        /**
         * Name.
         * 
         * @param {string} name the name
         * @return {io.nem.xpx.model.PathTransactionEncryptedMessage} the path transaction encrypted message
         */
        public name(name : string) : PathTransactionEncryptedMessage {
            this.__name = name;
            return this;
        }

        /**
         * Get name.
         * 
         * @return {string} name
         */
        public getName() : string {
            return this.__name;
        }

        /**
         * Sets the name.
         * 
         * @param {string} name the new name
         */
        public setName(name : string) {
            this.__name = name;
        }

        /**
         * Size.
         * 
         * @param {number} size the size
         * @return {io.nem.xpx.model.PathTransactionEncryptedMessage} the path transaction encrypted message
         */
        public size(size : number) : PathTransactionEncryptedMessage {
            this.__size = size;
            return this;
        }

        /**
         * Get size.
         * 
         * @return {number} size
         */
        public getSize() : number {
            return this.__size;
        }

        /**
         * Sets the size.
         * 
         * @param {number} size the new size
         */
        public setSize(size : number) {
            this.__size = size;
        }

        /**
         * Timestamp.
         * 
         * @param {number} timestamp the timestamp
         * @return {io.nem.xpx.model.PathTransactionEncryptedMessage} the path transaction encrypted message
         */
        public timestamp(timestamp : number) : PathTransactionEncryptedMessage {
            this.__timestamp = timestamp;
            return this;
        }

        /**
         * Get timestamp.
         * 
         * @return {number} timestamp
         */
        public getTimestamp() : number {
            return this.__timestamp;
        }

        /**
         * Sets the timestamp.
         * 
         * @param {number} timestamp the new timestamp
         */
        public setTimestamp(timestamp : number) {
            this.__timestamp = timestamp;
        }

        /**
         * Type.
         * 
         * @param {string} type the type
         * @return {io.nem.xpx.model.PathTransactionEncryptedMessage} the path transaction encrypted message
         */
        public type(type : string) : PathTransactionEncryptedMessage {
            this.__type = type;
            return this;
        }

        /**
         * Get type.
         * 
         * @return {string} type
         */
        public getType() : string {
            return this.__type;
        }

        /**
         * Sets the type.
         * 
         * @param {string} type the new type
         */
        public setType(type : string) {
            this.__type = type;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let binaryTransactionEncryptedMessage : PathTransactionEncryptedMessage = <PathTransactionEncryptedMessage>o;
            return java.util.Objects.equals(this.__digest, binaryTransactionEncryptedMessage.__digest) && java.util.Objects.equals(this.__hash, binaryTransactionEncryptedMessage.__hash) && java.util.Objects.equals(this.__keywords, binaryTransactionEncryptedMessage.__keywords) && java.util.Objects.equals(this.__metaData, binaryTransactionEncryptedMessage.__metaData) && java.util.Objects.equals(this.__name, binaryTransactionEncryptedMessage.__name) && java.util.Objects.equals(this.__size, binaryTransactionEncryptedMessage.__size) && java.util.Objects.equals(this.__timestamp, binaryTransactionEncryptedMessage.__timestamp) && java.util.Objects.equals(this.__type, binaryTransactionEncryptedMessage.__type);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class BinaryTransactionEncryptedMessage {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__digest)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    digest: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__hash)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    hash: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__keywords)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    keywords: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__metaData)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    metaData: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__name)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    name: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__size)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    size: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__timestamp)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    timestamp: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__type)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    type: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    PathTransactionEncryptedMessage["__class"] = "io.nem.xpx.model.PathTransactionEncryptedMessage";

}
namespace io.nem.xpx.model {
    /**
     * PrivateKey.
     * @class
     */
    export class PrivateKey {
        /**
         * The raw.
         */
        /*private*/ __raw : number = null;

        /**
         * Raw.
         * 
         * @param {number} raw the raw
         * @return {io.nem.xpx.model.PrivateKey} the private key
         */
        public raw(raw : number) : PrivateKey {
            this.__raw = raw;
            return this;
        }

        /**
         * Get raw.
         * 
         * @return {number} raw
         */
        public getRaw() : number {
            return this.__raw;
        }

        /**
         * Sets the raw.
         * 
         * @param {number} raw the new raw
         */
        public setRaw(raw : number) {
            this.__raw = raw;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let privateKey : PrivateKey = <PrivateKey>o;
            return java.util.Objects.equals(this.__raw, privateKey.__raw);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class PrivateKey {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__raw)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    raw: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    PrivateKey["__class"] = "io.nem.xpx.model.PrivateKey";

}
namespace io.nem.xpx.model {
    /**
     * PublicKey.
     * @class
     */
    export class PublicKey {
        /**
         * The raw.
         */
        /*private*/ __raw : number[] = null;

        /**
         * Raw.
         * 
         * @param {Array} raw the raw
         * @return {io.nem.xpx.model.PublicKey} the public key
         */
        public raw(raw : number[]) : PublicKey {
            this.__raw = raw;
            return this;
        }

        /**
         * Get raw.
         * 
         * @return {Array} raw
         */
        public getRaw() : number[] {
            return this.__raw;
        }

        /**
         * Sets the raw.
         * 
         * @param {Array} raw the new raw
         */
        public setRaw(raw : number[]) {
            this.__raw = raw;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let publicKey : PublicKey = <PublicKey>o;
            return java.util.Objects.equals(this.__raw, publicKey.__raw);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class PublicKey {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__raw)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    raw: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    PublicKey["__class"] = "io.nem.xpx.model.PublicKey";

}
namespace io.nem.xpx.model {
    /**
     * The Class PublishResult.
     * @class
     */
    export class PublishResult {
        /**
         * The id.
         */
        /*private*/ id : string;

        /**
         * The Constant serialVersionUID.
         */
        static serialVersionUID : number = 1;

        /**
         * The merkle node.
         */
        /*private*/ merkleNode : Array<io.ipfs.api.MerkleNode>;

        /**
         * The multi hash.
         */
        /*private*/ multiHash : Array<io.ipfs.multihash.Multihash>;

        /**
         * The nem announce result.
         */
        /*private*/ nemAnnounceResult : org.nem.core.model.ncc.NemAnnounceResult;

        /**
         * The challenge message.
         */
        /*private*/ challengeMessage : string;

        /**
         * The created date.
         */
        /*private*/ createdDate : Date = new Date();

        /**
         * The asset id.
         */
        /*private*/ assetId : string;

        /**
         * The block id.
         */
        /*private*/ blockId : string;

        /**
         * The bd transaction.
         */
        /*private*/ bdTransaction : string;

        /**
         * The db hash.
         */
        /*private*/ dbHash : string;

        /**
         * Gets the multi hash.
         * 
         * @return {io.ipfs.multihash.Multihash[]} the multi hash
         */
        public getMultiHash() : Array<io.ipfs.multihash.Multihash> {
            return this.multiHash;
        }

        /**
         * Sets the multi hash.
         * 
         * @param {io.ipfs.multihash.Multihash[]} multiHash the new multi hash
         */
        public setMultiHash(multiHash : Array<io.ipfs.multihash.Multihash>) {
            this.multiHash = multiHash;
        }

        /**
         * Gets the asset id.
         * 
         * @return {string} the asset id
         */
        public getAssetId() : string {
            return this.assetId;
        }

        /**
         * Sets the asset id.
         * 
         * @param {string} assetId
         * the new asset id
         */
        public setAssetId(assetId : string) {
            this.assetId = assetId;
        }

        /**
         * Gets the block id.
         * 
         * @return {string} the block id
         */
        public getBlockId() : string {
            return this.blockId;
        }

        /**
         * Sets the block id.
         * 
         * @param {string} blockId
         * the new block id
         */
        public setBlockId(blockId : string) {
            this.blockId = blockId;
        }

        /**
         * Gets the bd transaction.
         * 
         * @return {string} the bd transaction
         */
        public getBdTransaction() : string {
            return this.bdTransaction;
        }

        /**
         * Sets the bd transaction.
         * 
         * @param {string} bdTransaction
         * the new bd transaction
         */
        public setBdTransaction(bdTransaction : string) {
            this.bdTransaction = bdTransaction;
        }

        /**
         * Gets the created date.
         * 
         * @return {java.util.Date} the created date
         */
        public getCreatedDate() : Date {
            return this.createdDate;
        }

        /**
         * Sets the created date.
         * 
         * @param {java.util.Date} createdDate
         * the new created date
         */
        public setCreatedDate(createdDate : Date) {
            this.createdDate = createdDate;
        }

        /**
         * Gets the db hash.
         * 
         * @return {string} the db hash
         */
        public getDbHash() : string {
            return this.dbHash;
        }

        /**
         * Sets the db hash.
         * 
         * @param {string} dbHash
         * the new db hash
         */
        public setDbHash(dbHash : string) {
            this.dbHash = dbHash;
        }

        /**
         * Gets the serialversionuid.
         * 
         * @return {number} the serialversionuid
         */
        public static getSerialversionuid() : number {
            return PublishResult.serialVersionUID;
        }

        /**
         * Gets the id.
         * 
         * @return {string} the id
         */
        public getId() : string {
            return this.id;
        }

        /**
         * Sets the id.
         * 
         * @param {string} id
         * the new id
         */
        public setId(id : string) {
            this.id = id;
        }

        /**
         * Gets the challenge message.
         * 
         * @return {string} the challenge message
         */
        public getChallengeMessage() : string {
            return this.challengeMessage;
        }

        /**
         * Sets the challenge message.
         * 
         * @param {string} challengeMessage
         * the new challenge message
         */
        public setChallengeMessage(challengeMessage : string) {
            this.challengeMessage = challengeMessage;
        }

        /**
         * Gets the nem announce result.
         * 
         * @return {org.nem.core.model.ncc.NemAnnounceResult} the nem announce result
         */
        public getNemAnnounceResult() : org.nem.core.model.ncc.NemAnnounceResult {
            return this.nemAnnounceResult;
        }

        /**
         * Sets the nem announce result.
         * 
         * @param {org.nem.core.model.ncc.NemAnnounceResult} nemAnnounceResult
         * the new nem announce result
         */
        public setNemAnnounceResult(nemAnnounceResult : org.nem.core.model.ncc.NemAnnounceResult) {
            this.nemAnnounceResult = nemAnnounceResult;
        }

        /**
         * Gets the merkle node.
         * 
         * @return {io.ipfs.api.MerkleNode[]} the merkle node
         */
        public getMerkleNode() : Array<io.ipfs.api.MerkleNode> {
            return this.merkleNode;
        }

        /**
         * Sets the merkle node.
         * 
         * @param {io.ipfs.api.MerkleNode[]} merkleNode
         * the new merkle node
         */
        public setMerkleNode(merkleNode : Array<io.ipfs.api.MerkleNode>) {
            this.merkleNode = merkleNode;
        }

        constructor() {
            if(this.id===undefined) this.id = null;
            if(this.merkleNode===undefined) this.merkleNode = null;
            if(this.multiHash===undefined) this.multiHash = null;
            if(this.nemAnnounceResult===undefined) this.nemAnnounceResult = null;
            if(this.challengeMessage===undefined) this.challengeMessage = null;
            if(this.assetId===undefined) this.assetId = null;
            if(this.blockId===undefined) this.blockId = null;
            if(this.bdTransaction===undefined) this.bdTransaction = null;
            if(this.dbHash===undefined) this.dbHash = null;
        }
    }
    PublishResult["__class"] = "io.nem.xpx.model.PublishResult";
    PublishResult["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.model {
    /**
     * RequestAnnounceDataSignature.
     * @class
     */
    export class RequestAnnounceDataSignature {
        /**
         * The data.
         */
        /*private*/ __data : string = null;

        /**
         * The signature.
         */
        /*private*/ __signature : string = null;

        /**
         * Data.
         * 
         * @param {string} data the data
         * @return {io.nem.xpx.model.RequestAnnounceDataSignature} the request announce data signature
         */
        public data(data : string) : RequestAnnounceDataSignature {
            this.__data = data;
            return this;
        }

        /**
         * Get data.
         * 
         * @return {string} data
         */
        public getData() : string {
            return this.__data;
        }

        /**
         * Sets the data.
         * 
         * @param {string} data the new data
         */
        public setData(data : string) {
            this.__data = data;
        }

        /**
         * Signature.
         * 
         * @param {string} signature the signature
         * @return {io.nem.xpx.model.RequestAnnounceDataSignature} the request announce data signature
         */
        public signature(signature : string) : RequestAnnounceDataSignature {
            this.__signature = signature;
            return this;
        }

        /**
         * Get signature.
         * 
         * @return {string} signature
         */
        public getSignature() : string {
            return this.__signature;
        }

        /**
         * Sets the signature.
         * 
         * @param {string} signature the new signature
         */
        public setSignature(signature : string) {
            this.__signature = signature;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let requestAnnounceDataSignature : RequestAnnounceDataSignature = <RequestAnnounceDataSignature>o;
            return java.util.Objects.equals(this.__data, requestAnnounceDataSignature.__data) && java.util.Objects.equals(this.__signature, requestAnnounceDataSignature.__signature);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class RequestAnnounceDataSignature {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__data)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    data: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__signature)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    signature: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    RequestAnnounceDataSignature["__class"] = "io.nem.xpx.model.RequestAnnounceDataSignature";

}
namespace io.nem.xpx.model {
    /**
     * Resource.
     * @class
     */
    export class Resource {
        /**
         * The description.
         */
        /*private*/ __description : string = null;

        /**
         * The file.
         */
        /*private*/ __file : java.io.File = null;

        /**
         * The filename.
         */
        /*private*/ __filename : string = null;

        /**
         * The input stream.
         */
        /*private*/ __inputStream : io.nem.xpx.model.InputStream = null;

        /**
         * The open.
         */
        /*private*/ __open : boolean = null;

        /**
         * The readable.
         */
        /*private*/ __readable : boolean = null;

        /**
         * The uri.
         */
        /*private*/ __uri : io.nem.xpx.model.URI = null;

        /**
         * The url.
         */
        /*private*/ __url : io.nem.xpx.model.URL = null;

        /**
         * Description.
         * 
         * @param {string} description the description
         * @return {io.nem.xpx.model.Resource} the resource
         */
        public description(description : string) : Resource {
            this.__description = description;
            return this;
        }

        /**
         * Get description.
         * 
         * @return {string} description
         */
        public getDescription() : string {
            return this.__description;
        }

        /**
         * Sets the description.
         * 
         * @param {string} description the new description
         */
        public setDescription(description : string) {
            this.__description = description;
        }

        /**
         * File.
         * 
         * @param {java.io.File} file the file
         * @return {io.nem.xpx.model.Resource} the resource
         */
        public file(file : java.io.File) : Resource {
            this.__file = file;
            return this;
        }

        /**
         * Get file.
         * 
         * @return {java.io.File} file
         */
        public getFile() : java.io.File {
            return this.__file;
        }

        /**
         * Sets the file.
         * 
         * @param {java.io.File} file the new file
         */
        public setFile(file : java.io.File) {
            this.__file = file;
        }

        /**
         * Filename.
         * 
         * @param {string} filename the filename
         * @return {io.nem.xpx.model.Resource} the resource
         */
        public filename(filename : string) : Resource {
            this.__filename = filename;
            return this;
        }

        /**
         * Get filename.
         * 
         * @return {string} filename
         */
        public getFilename() : string {
            return this.__filename;
        }

        /**
         * Sets the filename.
         * 
         * @param {string} filename the new filename
         */
        public setFilename(filename : string) {
            this.__filename = filename;
        }

        /**
         * Input stream.
         * 
         * @param {io.nem.xpx.model.InputStream} inputStream the input stream
         * @return {io.nem.xpx.model.Resource} the resource
         */
        public inputStream(inputStream : io.nem.xpx.model.InputStream) : Resource {
            this.__inputStream = inputStream;
            return this;
        }

        /**
         * Get inputStream.
         * 
         * @return {io.nem.xpx.model.InputStream} inputStream
         */
        public getInputStream() : io.nem.xpx.model.InputStream {
            return this.__inputStream;
        }

        /**
         * Sets the input stream.
         * 
         * @param {io.nem.xpx.model.InputStream} inputStream the new input stream
         */
        public setInputStream(inputStream : io.nem.xpx.model.InputStream) {
            this.__inputStream = inputStream;
        }

        /**
         * Open.
         * 
         * @param {boolean} open the open
         * @return {io.nem.xpx.model.Resource} the resource
         */
        public open(open : boolean) : Resource {
            this.__open = open;
            return this;
        }

        /**
         * Get open.
         * 
         * @return {boolean} open
         */
        public getOpen() : boolean {
            return this.__open;
        }

        /**
         * Sets the open.
         * 
         * @param {boolean} open the new open
         */
        public setOpen(open : boolean) {
            this.__open = open;
        }

        /**
         * Readable.
         * 
         * @param {boolean} readable the readable
         * @return {io.nem.xpx.model.Resource} the resource
         */
        public readable(readable : boolean) : Resource {
            this.__readable = readable;
            return this;
        }

        /**
         * Get readable.
         * 
         * @return {boolean} readable
         */
        public getReadable() : boolean {
            return this.__readable;
        }

        /**
         * Sets the readable.
         * 
         * @param {boolean} readable the new readable
         */
        public setReadable(readable : boolean) {
            this.__readable = readable;
        }

        /**
         * Uri.
         * 
         * @param {io.nem.xpx.model.URI} uri the uri
         * @return {io.nem.xpx.model.Resource} the resource
         */
        public uri(uri : io.nem.xpx.model.URI) : Resource {
            this.__uri = uri;
            return this;
        }

        /**
         * Get uri.
         * 
         * @return {io.nem.xpx.model.URI} uri
         */
        public getUri() : io.nem.xpx.model.URI {
            return this.__uri;
        }

        /**
         * Sets the uri.
         * 
         * @param {io.nem.xpx.model.URI} uri the new uri
         */
        public setUri(uri : io.nem.xpx.model.URI) {
            this.__uri = uri;
        }

        /**
         * Url.
         * 
         * @param {io.nem.xpx.model.URL} url the url
         * @return {io.nem.xpx.model.Resource} the resource
         */
        public url(url : io.nem.xpx.model.URL) : Resource {
            this.__url = url;
            return this;
        }

        /**
         * Get url.
         * 
         * @return {io.nem.xpx.model.URL} url
         */
        public getUrl() : io.nem.xpx.model.URL {
            return this.__url;
        }

        /**
         * Sets the url.
         * 
         * @param {io.nem.xpx.model.URL} url the new url
         */
        public setUrl(url : io.nem.xpx.model.URL) {
            this.__url = url;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let resource : Resource = <Resource>o;
            return java.util.Objects.equals(this.__description, resource.__description) && java.util.Objects.equals(this.__file, resource.__file) && java.util.Objects.equals(this.__filename, resource.__filename) && java.util.Objects.equals(this.__inputStream, resource.__inputStream) && java.util.Objects.equals(this.__open, resource.__open) && java.util.Objects.equals(this.__readable, resource.__readable) && java.util.Objects.equals(this.__uri, resource.__uri) && java.util.Objects.equals(this.__url, resource.__url);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class Resource {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__description)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    description: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__file)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    file: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__filename)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    filename: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__inputStream)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    inputStream: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__open)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    open: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__readable)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    readable: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__uri)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    uri: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__url)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    url: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    Resource["__class"] = "io.nem.xpx.model.Resource";

}
namespace io.nem.xpx.model {
    /**
     * ResponseEntity.
     * @class
     */
    export class ResponseEntity {
        /**
         * The body.
         */
        /*private*/ __body : any = null;

        /**
         * The status code.
         */
        /*private*/ __statusCode : ResponseEntity.StatusCodeEnum = null;

        /**
         * The status code value.
         */
        /*private*/ __statusCodeValue : number = null;

        /**
         * Body.
         * 
         * @param {*} body the body
         * @return {io.nem.xpx.model.ResponseEntity} the response entity
         */
        public body(body : any) : ResponseEntity {
            this.__body = body;
            return this;
        }

        /**
         * Get body.
         * 
         * @return {*} body
         */
        public getBody() : any {
            return this.__body;
        }

        /**
         * Sets the body.
         * 
         * @param {*} body the new body
         */
        public setBody(body : any) {
            this.__body = body;
        }

        /**
         * Status code.
         * 
         * @param {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} statusCode the status code
         * @return {io.nem.xpx.model.ResponseEntity} the response entity
         */
        public statusCode(statusCode : ResponseEntity.StatusCodeEnum) : ResponseEntity {
            this.__statusCode = statusCode;
            return this;
        }

        /**
         * Get statusCode.
         * 
         * @return {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} statusCode
         */
        public getStatusCode() : ResponseEntity.StatusCodeEnum {
            return this.__statusCode;
        }

        /**
         * Sets the status code.
         * 
         * @param {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} statusCode the new status code
         */
        public setStatusCode(statusCode : ResponseEntity.StatusCodeEnum) {
            this.__statusCode = statusCode;
        }

        /**
         * Status code value.
         * 
         * @param {number} statusCodeValue the status code value
         * @return {io.nem.xpx.model.ResponseEntity} the response entity
         */
        public statusCodeValue(statusCodeValue : number) : ResponseEntity {
            this.__statusCodeValue = statusCodeValue;
            return this;
        }

        /**
         * Get statusCodeValue.
         * 
         * @return {number} statusCodeValue
         */
        public getStatusCodeValue() : number {
            return this.__statusCodeValue;
        }

        /**
         * Sets the status code value.
         * 
         * @param {number} statusCodeValue the new status code value
         */
        public setStatusCodeValue(statusCodeValue : number) {
            this.__statusCodeValue = statusCodeValue;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let responseEntity : ResponseEntity = <ResponseEntity>o;
            return java.util.Objects.equals(this.__body, responseEntity.__body) && java.util.Objects.equals(this.__statusCode, responseEntity.__statusCode) && java.util.Objects.equals(this.__statusCodeValue, responseEntity.__statusCodeValue);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class ResponseEntity {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__body)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    body: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__statusCode)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    statusCode: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__statusCodeValue)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    statusCodeValue: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    ResponseEntity["__class"] = "io.nem.xpx.model.ResponseEntity";


    export namespace ResponseEntity {

        /**
         * Gets or Sets statusCode.
         * @enum
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _100
         * The  100.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _101
         * The  101.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _102
         * The  102.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _103
         * The  103.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _200
         * The  200.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _201
         * The  201.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _202
         * The  202.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _203
         * The  203.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _204
         * The  204.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _205
         * The  205.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _206
         * The  206.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _207
         * The  207.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _208
         * The  208.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _226
         * The  226.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _300
         * The  300.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _301
         * The  301.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _302
         * The  302.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _303
         * The  303.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _304
         * The  304.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _305
         * The  305.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _307
         * The  307.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _308
         * The  308.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _400
         * The  400.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _401
         * The  401.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _402
         * The  402.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _403
         * The  403.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _404
         * The  404.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _405
         * The  405.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _406
         * The  406.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _407
         * The  407.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _408
         * The  408.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _409
         * The  409.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _410
         * The  410.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _411
         * The  411.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _412
         * The  412.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _413
         * The  413.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _414
         * The  414.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _415
         * The  415.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _416
         * The  416.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _417
         * The  417.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _418
         * The  418.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _419
         * The  419.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _420
         * The  420.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _421
         * The  421.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _422
         * The  422.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _423
         * The  423.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _424
         * The  424.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _426
         * The  426.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _428
         * The  428.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _429
         * The  429.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _431
         * The  431.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _451
         * The  451.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _500
         * The  500.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _501
         * The  501.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _502
         * The  502.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _503
         * The  503.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _504
         * The  504.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _505
         * The  505.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _506
         * The  506.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _507
         * The  507.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _508
         * The  508.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _509
         * The  509.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _510
         * The  510.
         * @property {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} _511
         * The  511.
         * @class
         */
        export enum StatusCodeEnum {
            
            /**
             * The  100.
             */
            _100, 
            /**
             * The  101.
             */
            _101, 
            /**
             * The  102.
             */
            _102, 
            /**
             * The  103.
             */
            _103, 
            /**
             * The  200.
             */
            _200, 
            /**
             * The  201.
             */
            _201, 
            /**
             * The  202.
             */
            _202, 
            /**
             * The  203.
             */
            _203, 
            /**
             * The  204.
             */
            _204, 
            /**
             * The  205.
             */
            _205, 
            /**
             * The  206.
             */
            _206, 
            /**
             * The  207.
             */
            _207, 
            /**
             * The  208.
             */
            _208, 
            /**
             * The  226.
             */
            _226, 
            /**
             * The  300.
             */
            _300, 
            /**
             * The  301.
             */
            _301, 
            /**
             * The  302.
             */
            _302, 
            /**
             * The  303.
             */
            _303, 
            /**
             * The  304.
             */
            _304, 
            /**
             * The  305.
             */
            _305, 
            /**
             * The  307.
             */
            _307, 
            /**
             * The  308.
             */
            _308, 
            /**
             * The  400.
             */
            _400, 
            /**
             * The  401.
             */
            _401, 
            /**
             * The  402.
             */
            _402, 
            /**
             * The  403.
             */
            _403, 
            /**
             * The  404.
             */
            _404, 
            /**
             * The  405.
             */
            _405, 
            /**
             * The  406.
             */
            _406, 
            /**
             * The  407.
             */
            _407, 
            /**
             * The  408.
             */
            _408, 
            /**
             * The  409.
             */
            _409, 
            /**
             * The  410.
             */
            _410, 
            /**
             * The  411.
             */
            _411, 
            /**
             * The  412.
             */
            _412, 
            /**
             * The  413.
             */
            _413, 
            /**
             * The  414.
             */
            _414, 
            /**
             * The  415.
             */
            _415, 
            /**
             * The  416.
             */
            _416, 
            /**
             * The  417.
             */
            _417, 
            /**
             * The  418.
             */
            _418, 
            /**
             * The  419.
             */
            _419, 
            /**
             * The  420.
             */
            _420, 
            /**
             * The  421.
             */
            _421, 
            /**
             * The  422.
             */
            _422, 
            /**
             * The  423.
             */
            _423, 
            /**
             * The  424.
             */
            _424, 
            /**
             * The  426.
             */
            _426, 
            /**
             * The  428.
             */
            _428, 
            /**
             * The  429.
             */
            _429, 
            /**
             * The  431.
             */
            _431, 
            /**
             * The  451.
             */
            _451, 
            /**
             * The  500.
             */
            _500, 
            /**
             * The  501.
             */
            _501, 
            /**
             * The  502.
             */
            _502, 
            /**
             * The  503.
             */
            _503, 
            /**
             * The  504.
             */
            _504, 
            /**
             * The  505.
             */
            _505, 
            /**
             * The  506.
             */
            _506, 
            /**
             * The  507.
             */
            _507, 
            /**
             * The  508.
             */
            _508, 
            /**
             * The  509.
             */
            _509, 
            /**
             * The  510.
             */
            _510, 
            /**
             * The  511.
             */
            _511
        }

        /** @ignore */
        export class StatusCodeEnum_$WRAPPER {
            /**
             * The value.
             */
            value;

            constructor(protected _$ordinal : number, protected _$name : string, value) {
                if(this.value===undefined) this.value = null;
                this.value = value;
            }

            /**
             * Gets the value.
             * 
             * @return {string} the value
             */
            public getValue() : string {
                return this.value;
            }

            /**
             * 
             * @return {string}
             */
            public toString() : string {
                return /* valueOf */new String(this.value).toString();
            }

            /**
             * From value.
             * 
             * @param {string} text the text
             * @return {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} the status code enum
             */
            public static fromValue(text) : ResponseEntity.StatusCodeEnum {
                {
                    let array159 = /* Enum.values */function() { let result: number[] = []; for(let val in io.nem.xpx.model.ResponseEntity.StatusCodeEnum) { if(!isNaN(<any>val)) { result.push(parseInt(val,10)); } } return result; }();
                    for(let index158=0; index158 < array159.length; index158++) {
                        let b = array159[index158];
                        {
                            if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(/* valueOf */new String(io.nem.xpx.model.ResponseEntity.StatusCodeEnum["_$wrappers"][b].value).toString(),text))) {
                                return b;
                            }
                        }
                    }
                }
                return null;
            }
            public name() : string { return this._$name; }
            public ordinal() : number { return this._$ordinal; }
        }
        StatusCodeEnum["__class"] = "io.nem.xpx.model.ResponseEntity.StatusCodeEnum";
        StatusCodeEnum["__interfaces"] = ["java.lang.Comparable","java.io.Serializable"];


        export namespace StatusCodeEnum {

            /**
             * The Class Adapter.
             * @class
             * @extends com.google.gson.TypeAdapter
             */
            export class Adapter extends com.google.gson.TypeAdapter<ResponseEntity.StatusCodeEnum> {
                /**
                 * 
                 * @param {com.google.gson.stream.JsonWriter} jsonWriter
                 * @param {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} enumeration
                 */
                public write(jsonWriter : com.google.gson.stream.JsonWriter, enumeration : ResponseEntity.StatusCodeEnum) {
                    jsonWriter.value(io.nem.xpx.model.ResponseEntity.StatusCodeEnum["_$wrappers"][enumeration].getValue());
                }

                /**
                 * 
                 * @param {com.google.gson.stream.JsonReader} jsonReader
                 * @return {io.nem.xpx.model.ResponseEntity.StatusCodeEnum}
                 */
                public read(jsonReader : com.google.gson.stream.JsonReader) : ResponseEntity.StatusCodeEnum {
                    let value : string = jsonReader.nextString();
                    return ResponseEntity.StatusCodeEnum_$WRAPPER.fromValue(/* valueOf */new String(value).toString());
                }

                constructor() {
                    super();
                }
            }
            Adapter["__class"] = "io.nem.xpx.model.ResponseEntity.StatusCodeEnum.Adapter";

        }


        export namespace StatusCodeEnum {

            /**
             * The Class Adapter.
             * @class
             * @extends com.google.gson.TypeAdapter
             */
            export class Adapter extends com.google.gson.TypeAdapter<ResponseEntity.StatusCodeEnum> {
                /**
                 * 
                 * @param {com.google.gson.stream.JsonWriter} jsonWriter
                 * @param {io.nem.xpx.model.ResponseEntity.StatusCodeEnum} enumeration
                 */
                public write(jsonWriter : com.google.gson.stream.JsonWriter, enumeration : ResponseEntity.StatusCodeEnum) {
                    jsonWriter.value(io.nem.xpx.model.ResponseEntity.StatusCodeEnum["_$wrappers"][enumeration].getValue());
                }

                /**
                 * 
                 * @param {com.google.gson.stream.JsonReader} jsonReader
                 * @return {io.nem.xpx.model.ResponseEntity.StatusCodeEnum}
                 */
                public read(jsonReader : com.google.gson.stream.JsonReader) : ResponseEntity.StatusCodeEnum {
                    let value : string = jsonReader.nextString();
                    return ResponseEntity.StatusCodeEnum_$WRAPPER.fromValue(/* valueOf */new String(value).toString());
                }

                constructor() {
                    super();
                }
            }
            Adapter["__class"] = "io.nem.xpx.model.ResponseEntity.StatusCodeEnum.Adapter";

        }

        StatusCodeEnum["_$wrappers"] = [new StatusCodeEnum_$WRAPPER(0, "_100", "100"), new StatusCodeEnum_$WRAPPER(1, "_101", "101"), new StatusCodeEnum_$WRAPPER(2, "_102", "102"), new StatusCodeEnum_$WRAPPER(3, "_103", "103"), new StatusCodeEnum_$WRAPPER(4, "_200", "200"), new StatusCodeEnum_$WRAPPER(5, "_201", "201"), new StatusCodeEnum_$WRAPPER(6, "_202", "202"), new StatusCodeEnum_$WRAPPER(7, "_203", "203"), new StatusCodeEnum_$WRAPPER(8, "_204", "204"), new StatusCodeEnum_$WRAPPER(9, "_205", "205"), new StatusCodeEnum_$WRAPPER(10, "_206", "206"), new StatusCodeEnum_$WRAPPER(11, "_207", "207"), new StatusCodeEnum_$WRAPPER(12, "_208", "208"), new StatusCodeEnum_$WRAPPER(13, "_226", "226"), new StatusCodeEnum_$WRAPPER(14, "_300", "300"), new StatusCodeEnum_$WRAPPER(15, "_301", "301"), new StatusCodeEnum_$WRAPPER(16, "_302", "302"), new StatusCodeEnum_$WRAPPER(17, "_303", "303"), new StatusCodeEnum_$WRAPPER(18, "_304", "304"), new StatusCodeEnum_$WRAPPER(19, "_305", "305"), new StatusCodeEnum_$WRAPPER(20, "_307", "307"), new StatusCodeEnum_$WRAPPER(21, "_308", "308"), new StatusCodeEnum_$WRAPPER(22, "_400", "400"), new StatusCodeEnum_$WRAPPER(23, "_401", "401"), new StatusCodeEnum_$WRAPPER(24, "_402", "402"), new StatusCodeEnum_$WRAPPER(25, "_403", "403"), new StatusCodeEnum_$WRAPPER(26, "_404", "404"), new StatusCodeEnum_$WRAPPER(27, "_405", "405"), new StatusCodeEnum_$WRAPPER(28, "_406", "406"), new StatusCodeEnum_$WRAPPER(29, "_407", "407"), new StatusCodeEnum_$WRAPPER(30, "_408", "408"), new StatusCodeEnum_$WRAPPER(31, "_409", "409"), new StatusCodeEnum_$WRAPPER(32, "_410", "410"), new StatusCodeEnum_$WRAPPER(33, "_411", "411"), new StatusCodeEnum_$WRAPPER(34, "_412", "412"), new StatusCodeEnum_$WRAPPER(35, "_413", "413"), new StatusCodeEnum_$WRAPPER(36, "_414", "414"), new StatusCodeEnum_$WRAPPER(37, "_415", "415"), new StatusCodeEnum_$WRAPPER(38, "_416", "416"), new StatusCodeEnum_$WRAPPER(39, "_417", "417"), new StatusCodeEnum_$WRAPPER(40, "_418", "418"), new StatusCodeEnum_$WRAPPER(41, "_419", "419"), new StatusCodeEnum_$WRAPPER(42, "_420", "420"), new StatusCodeEnum_$WRAPPER(43, "_421", "421"), new StatusCodeEnum_$WRAPPER(44, "_422", "422"), new StatusCodeEnum_$WRAPPER(45, "_423", "423"), new StatusCodeEnum_$WRAPPER(46, "_424", "424"), new StatusCodeEnum_$WRAPPER(47, "_426", "426"), new StatusCodeEnum_$WRAPPER(48, "_428", "428"), new StatusCodeEnum_$WRAPPER(49, "_429", "429"), new StatusCodeEnum_$WRAPPER(50, "_431", "431"), new StatusCodeEnum_$WRAPPER(51, "_451", "451"), new StatusCodeEnum_$WRAPPER(52, "_500", "500"), new StatusCodeEnum_$WRAPPER(53, "_501", "501"), new StatusCodeEnum_$WRAPPER(54, "_502", "502"), new StatusCodeEnum_$WRAPPER(55, "_503", "503"), new StatusCodeEnum_$WRAPPER(56, "_504", "504"), new StatusCodeEnum_$WRAPPER(57, "_505", "505"), new StatusCodeEnum_$WRAPPER(58, "_506", "506"), new StatusCodeEnum_$WRAPPER(59, "_507", "507"), new StatusCodeEnum_$WRAPPER(60, "_508", "508"), new StatusCodeEnum_$WRAPPER(61, "_509", "509"), new StatusCodeEnum_$WRAPPER(62, "_510", "510"), new StatusCodeEnum_$WRAPPER(63, "_511", "511")];

    }

}
namespace io.nem.xpx.model {
    /**
     * StackTraceElement.
     * @class
     */
    export class StackTraceElement {
        /**
         * The class name.
         */
        /*private*/ __className : string = null;

        /**
         * The file name.
         */
        /*private*/ __fileName : string = null;

        /**
         * The line number.
         */
        /*private*/ __lineNumber : number = null;

        /**
         * The method name.
         */
        /*private*/ __methodName : string = null;

        /**
         * The native method.
         */
        /*private*/ __nativeMethod : boolean = null;

        /**
         * Class name.
         * 
         * @param {string} className the class name
         * @return {io.nem.xpx.model.StackTraceElement} the stack trace element
         */
        public className(className : string) : StackTraceElement {
            this.__className = className;
            return this;
        }

        /**
         * Get className.
         * 
         * @return {string} className
         */
        public getClassName() : string {
            return this.__className;
        }

        /**
         * Sets the class name.
         * 
         * @param {string} className the new class name
         */
        public setClassName(className : string) {
            this.__className = className;
        }

        /**
         * File name.
         * 
         * @param {string} fileName the file name
         * @return {io.nem.xpx.model.StackTraceElement} the stack trace element
         */
        public fileName(fileName : string) : StackTraceElement {
            this.__fileName = fileName;
            return this;
        }

        /**
         * Get fileName.
         * 
         * @return {string} fileName
         */
        public getFileName() : string {
            return this.__fileName;
        }

        /**
         * Sets the file name.
         * 
         * @param {string} fileName the new file name
         */
        public setFileName(fileName : string) {
            this.__fileName = fileName;
        }

        /**
         * Line number.
         * 
         * @param {number} lineNumber the line number
         * @return {io.nem.xpx.model.StackTraceElement} the stack trace element
         */
        public lineNumber(lineNumber : number) : StackTraceElement {
            this.__lineNumber = lineNumber;
            return this;
        }

        /**
         * Get lineNumber.
         * 
         * @return {number} lineNumber
         */
        public getLineNumber() : number {
            return this.__lineNumber;
        }

        /**
         * Sets the line number.
         * 
         * @param {number} lineNumber the new line number
         */
        public setLineNumber(lineNumber : number) {
            this.__lineNumber = lineNumber;
        }

        /**
         * Method name.
         * 
         * @param {string} methodName the method name
         * @return {io.nem.xpx.model.StackTraceElement} the stack trace element
         */
        public methodName(methodName : string) : StackTraceElement {
            this.__methodName = methodName;
            return this;
        }

        /**
         * Get methodName.
         * 
         * @return {string} methodName
         */
        public getMethodName() : string {
            return this.__methodName;
        }

        /**
         * Sets the method name.
         * 
         * @param {string} methodName the new method name
         */
        public setMethodName(methodName : string) {
            this.__methodName = methodName;
        }

        /**
         * Native method.
         * 
         * @param {boolean} nativeMethod the native method
         * @return {io.nem.xpx.model.StackTraceElement} the stack trace element
         */
        public nativeMethod(nativeMethod : boolean) : StackTraceElement {
            this.__nativeMethod = nativeMethod;
            return this;
        }

        /**
         * Get nativeMethod.
         * 
         * @return {boolean} nativeMethod
         */
        public getNativeMethod() : boolean {
            return this.__nativeMethod;
        }

        /**
         * Sets the native method.
         * 
         * @param {boolean} nativeMethod the new native method
         */
        public setNativeMethod(nativeMethod : boolean) {
            this.__nativeMethod = nativeMethod;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let stackTraceElement : StackTraceElement = <StackTraceElement>o;
            return java.util.Objects.equals(this.__className, stackTraceElement.__className) && java.util.Objects.equals(this.__fileName, stackTraceElement.__fileName) && java.util.Objects.equals(this.__lineNumber, stackTraceElement.__lineNumber) && java.util.Objects.equals(this.__methodName, stackTraceElement.__methodName) && java.util.Objects.equals(this.__nativeMethod, stackTraceElement.__nativeMethod);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class StackTraceElement {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__className)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    className: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__fileName)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    fileName: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__lineNumber)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    lineNumber: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__methodName)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    methodName: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__nativeMethod)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    nativeMethod: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    StackTraceElement["__class"] = "io.nem.xpx.model.StackTraceElement";

}
namespace io.nem.xpx.model {
    /**
     * Throwable.
     * @class
     */
    export class Throwable {
        /**
         * The cause.
         */
        /*private*/ __cause : Throwable = null;

        /**
         * The localized message.
         */
        /*private*/ __localizedMessage : string = null;

        /**
         * The message.
         */
        /*private*/ __message : string = null;

        /**
         * The stack trace.
         */
        /*private*/ __stackTrace : Array<io.nem.xpx.model.StackTraceElement> = null;

        /**
         * The suppressed.
         */
        /*private*/ __suppressed : Array<Throwable> = null;

        /**
         * Cause.
         * 
         * @param {io.nem.xpx.model.Throwable} cause the cause
         * @return {io.nem.xpx.model.Throwable} the throwable
         */
        public cause(cause : Throwable) : Throwable {
            this.__cause = cause;
            return this;
        }

        /**
         * Get cause.
         * 
         * @return {io.nem.xpx.model.Throwable} cause
         */
        public getCause() : Throwable {
            return this.__cause;
        }

        /**
         * Sets the cause.
         * 
         * @param {io.nem.xpx.model.Throwable} cause the new cause
         */
        public setCause(cause : Throwable) {
            this.__cause = cause;
        }

        /**
         * Localized message.
         * 
         * @param {string} localizedMessage the localized message
         * @return {io.nem.xpx.model.Throwable} the throwable
         */
        public localizedMessage(localizedMessage : string) : Throwable {
            this.__localizedMessage = localizedMessage;
            return this;
        }

        /**
         * Get localizedMessage.
         * 
         * @return {string} localizedMessage
         */
        public getLocalizedMessage() : string {
            return this.__localizedMessage;
        }

        /**
         * Sets the localized message.
         * 
         * @param {string} localizedMessage the new localized message
         */
        public setLocalizedMessage(localizedMessage : string) {
            this.__localizedMessage = localizedMessage;
        }

        /**
         * Message.
         * 
         * @param {string} message the message
         * @return {io.nem.xpx.model.Throwable} the throwable
         */
        public message(message : string) : Throwable {
            this.__message = message;
            return this;
        }

        /**
         * Get message.
         * 
         * @return {string} message
         */
        public getMessage() : string {
            return this.__message;
        }

        /**
         * Sets the message.
         * 
         * @param {string} message the new message
         */
        public setMessage(message : string) {
            this.__message = message;
        }

        /**
         * Stack trace.
         * 
         * @param {io.nem.xpx.model.StackTraceElement[]} stackTrace the stack trace
         * @return {io.nem.xpx.model.Throwable} the throwable
         */
        public stackTrace(stackTrace : Array<io.nem.xpx.model.StackTraceElement>) : Throwable {
            this.__stackTrace = stackTrace;
            return this;
        }

        /**
         * Adds the stack trace item.
         * 
         * @param {io.nem.xpx.model.StackTraceElement} stackTraceItem the stack trace item
         * @return {io.nem.xpx.model.Throwable} the throwable
         */
        public addStackTraceItem(stackTraceItem : io.nem.xpx.model.StackTraceElement) : Throwable {
            if(this.__stackTrace == null) {
                this.__stackTrace = <any>([]);
            }
            /* add */(this.__stackTrace.push(stackTraceItem)>0);
            return this;
        }

        /**
         * Get stackTrace.
         * 
         * @return {io.nem.xpx.model.StackTraceElement[]} stackTrace
         */
        public getStackTrace() : Array<io.nem.xpx.model.StackTraceElement> {
            return this.__stackTrace;
        }

        /**
         * Sets the stack trace.
         * 
         * @param {io.nem.xpx.model.StackTraceElement[]} stackTrace the new stack trace
         */
        public setStackTrace(stackTrace : Array<io.nem.xpx.model.StackTraceElement>) {
            this.__stackTrace = stackTrace;
        }

        /**
         * Suppressed.
         * 
         * @param {io.nem.xpx.model.Throwable[]} suppressed the suppressed
         * @return {io.nem.xpx.model.Throwable} the throwable
         */
        public suppressed(suppressed : Array<Throwable>) : Throwable {
            this.__suppressed = suppressed;
            return this;
        }

        /**
         * Adds the suppressed item.
         * 
         * @param {io.nem.xpx.model.Throwable} suppressedItem the suppressed item
         * @return {io.nem.xpx.model.Throwable} the throwable
         */
        public addSuppressedItem(suppressedItem : Throwable) : Throwable {
            if(this.__suppressed == null) {
                this.__suppressed = <any>([]);
            }
            /* add */(this.__suppressed.push(suppressedItem)>0);
            return this;
        }

        /**
         * Get suppressed.
         * 
         * @return {io.nem.xpx.model.Throwable[]} suppressed
         */
        public getSuppressed() : Array<Throwable> {
            return this.__suppressed;
        }

        /**
         * Sets the suppressed.
         * 
         * @param {io.nem.xpx.model.Throwable[]} suppressed the new suppressed
         */
        public setSuppressed(suppressed : Array<Throwable>) {
            this.__suppressed = suppressed;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let throwable : Throwable = <Throwable>o;
            return java.util.Objects.equals(this.__cause, throwable.__cause) && java.util.Objects.equals(this.__localizedMessage, throwable.__localizedMessage) && java.util.Objects.equals(this.__message, throwable.__message) && java.util.Objects.equals(this.__stackTrace, throwable.__stackTrace) && java.util.Objects.equals(this.__suppressed, throwable.__suppressed);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class Throwable {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__cause)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    cause: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__localizedMessage)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    localizedMessage: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__message)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    message: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__stackTrace)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    stackTrace: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__suppressed)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    suppressed: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    Throwable["__class"] = "io.nem.xpx.model.Throwable";

}
namespace io.nem.xpx.model {
    /**
     * UploadBase64BinaryRequestParameter.
     * @class
     */
    export class UploadBase64BinaryRequestParameter {
        /**
         * The content type.
         */
        /*private*/ __contentType : string = null;

        /**
         * The data.
         */
        /*private*/ __data : string = null;

        /**
         * The keywords.
         */
        /*private*/ __keywords : string = null;

        /**
         * The metadata.
         */
        /*private*/ __metadata : string = null;

        /**
         * The name.
         */
        /*private*/ __name : string = null;

        /**
         * Content type.
         * 
         * @param {string} contentType the content type
         * @return {io.nem.xpx.model.UploadBase64BinaryRequestParameter} the upload base 64 binary request parameter
         */
        public contentType(contentType : string) : UploadBase64BinaryRequestParameter {
            this.__contentType = contentType;
            return this;
        }

        /**
         * Get contentType.
         * 
         * @return {string} contentType
         */
        public getContentType() : string {
            return this.__contentType;
        }

        /**
         * Sets the content type.
         * 
         * @param {string} contentType the new content type
         */
        public setContentType(contentType : string) {
            this.__contentType = contentType;
        }

        /**
         * Data.
         * 
         * @param {string} data the data
         * @return {io.nem.xpx.model.UploadBase64BinaryRequestParameter} the upload base 64 binary request parameter
         */
        public data(data : string) : UploadBase64BinaryRequestParameter {
            this.__data = data;
            return this;
        }

        /**
         * Get data.
         * 
         * @return {string} data
         */
        public getData() : string {
            return this.__data;
        }

        /**
         * Sets the data.
         * 
         * @param {string} data the new data
         */
        public setData(data : string) {
            this.__data = data;
        }

        /**
         * Keywords.
         * 
         * @param {string} keywords the keywords
         * @return {io.nem.xpx.model.UploadBase64BinaryRequestParameter} the upload base 64 binary request parameter
         */
        public keywords(keywords : string) : UploadBase64BinaryRequestParameter {
            this.__keywords = keywords;
            return this;
        }

        /**
         * Get keywords.
         * 
         * @return {string} keywords
         */
        public getKeywords() : string {
            return this.__keywords;
        }

        /**
         * Sets the keywords.
         * 
         * @param {string} keywords the new keywords
         */
        public setKeywords(keywords : string) {
            this.__keywords = keywords;
        }

        /**
         * Metadata.
         * 
         * @param {string} metadata the metadata
         * @return {io.nem.xpx.model.UploadBase64BinaryRequestParameter} the upload base 64 binary request parameter
         */
        public metadata(metadata : string) : UploadBase64BinaryRequestParameter {
            this.__metadata = metadata;
            return this;
        }

        /**
         * Get metadata.
         * 
         * @return {string} metadata
         */
        public getMetadata() : string {
            return this.__metadata;
        }

        /**
         * Sets the metadata.
         * 
         * @param {string} metadata the new metadata
         */
        public setMetadata(metadata : string) {
            this.__metadata = metadata;
        }

        /**
         * Name.
         * 
         * @param {string} name the name
         * @return {io.nem.xpx.model.UploadBase64BinaryRequestParameter} the upload base 64 binary request parameter
         */
        public name(name : string) : UploadBase64BinaryRequestParameter {
            this.__name = name;
            return this;
        }

        /**
         * Get name.
         * 
         * @return {string} name
         */
        public getName() : string {
            return this.__name;
        }

        /**
         * Sets the name.
         * 
         * @param {string} name the new name
         */
        public setName(name : string) {
            this.__name = name;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let uploadBase64BinaryRequestParameter : UploadBase64BinaryRequestParameter = <UploadBase64BinaryRequestParameter>o;
            return java.util.Objects.equals(this.__contentType, uploadBase64BinaryRequestParameter.__contentType) && java.util.Objects.equals(this.__data, uploadBase64BinaryRequestParameter.__data) && java.util.Objects.equals(this.__keywords, uploadBase64BinaryRequestParameter.__keywords) && java.util.Objects.equals(this.__metadata, uploadBase64BinaryRequestParameter.__metadata) && java.util.Objects.equals(this.__name, uploadBase64BinaryRequestParameter.__name);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class UploadBase64BinaryRequestParameter {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__contentType)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    contentType: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__data)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    data: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__keywords)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    keywords: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__metadata)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    metadata: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__name)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    name: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    UploadBase64BinaryRequestParameter["__class"] = "io.nem.xpx.model.UploadBase64BinaryRequestParameter";

}
namespace io.nem.xpx.model {
    /**
     * UploadBytesBinaryRequestParameter.
     * @class
     */
    export class UploadBytesBinaryRequestParameter {
        /**
         * The content type.
         */
        /*private*/ __contentType : string = null;

        /**
         * The data.
         */
        /*private*/ __data : number[] = null;

        /**
         * The keywords.
         */
        /*private*/ __keywords : string = null;

        /**
         * The metadata.
         */
        /*private*/ __metadata : string = null;

        /**
         * The name.
         */
        /*private*/ __name : string = null;

        /**
         * Content type.
         * 
         * @param {string} contentType the content type
         * @return {io.nem.xpx.model.UploadBytesBinaryRequestParameter} the upload bytes binary request parameter
         */
        public contentType(contentType : string) : UploadBytesBinaryRequestParameter {
            this.__contentType = contentType;
            return this;
        }

        /**
         * Get contentType.
         * 
         * @return {string} contentType
         */
        public getContentType() : string {
            return this.__contentType;
        }

        /**
         * Sets the content type.
         * 
         * @param {string} contentType the new content type
         */
        public setContentType(contentType : string) {
            this.__contentType = contentType;
        }

        /**
         * Data.
         * 
         * @param {Array} data the data
         * @return {io.nem.xpx.model.UploadBytesBinaryRequestParameter} the upload bytes binary request parameter
         */
        public data(data : number[]) : UploadBytesBinaryRequestParameter {
            this.__data = org.apache.commons.codec.binary.Base64.encodeBase64(data);
            return this;
        }

        /**
         * Get data.
         * 
         * @return {Array} data
         */
        public getData() : number[] {
            return this.__data;
        }

        /**
         * Sets the data.
         * 
         * @param {Array} data the new data
         */
        public setData(data : number[]) {
            this.__data = data;
        }

        /**
         * Keywords.
         * 
         * @param {string} keywords the keywords
         * @return {io.nem.xpx.model.UploadBytesBinaryRequestParameter} the upload bytes binary request parameter
         */
        public keywords(keywords : string) : UploadBytesBinaryRequestParameter {
            this.__keywords = keywords;
            return this;
        }

        /**
         * Get keywords.
         * 
         * @return {string} keywords
         */
        public getKeywords() : string {
            return this.__keywords;
        }

        /**
         * Sets the keywords.
         * 
         * @param {string} keywords the new keywords
         */
        public setKeywords(keywords : string) {
            this.__keywords = keywords;
        }

        /**
         * Metadata.
         * 
         * @param {string} metadata the metadata
         * @return {io.nem.xpx.model.UploadBytesBinaryRequestParameter} the upload bytes binary request parameter
         */
        public metadata(metadata : string) : UploadBytesBinaryRequestParameter {
            this.__metadata = metadata;
            return this;
        }

        /**
         * Get metadata.
         * 
         * @return {string} metadata
         */
        public getMetadata() : string {
            return this.__metadata;
        }

        /**
         * Sets the metadata.
         * 
         * @param {string} metadata the new metadata
         */
        public setMetadata(metadata : string) {
            this.__metadata = metadata;
        }

        /**
         * Name.
         * 
         * @param {string} name the name
         * @return {io.nem.xpx.model.UploadBytesBinaryRequestParameter} the upload bytes binary request parameter
         */
        public name(name : string) : UploadBytesBinaryRequestParameter {
            this.__name = name;
            return this;
        }

        /**
         * Get name.
         * 
         * @return {string} name
         */
        public getName() : string {
            return this.__name;
        }

        /**
         * Sets the name.
         * 
         * @param {string} name the new name
         */
        public setName(name : string) {
            this.__name = name;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let uploadBytesBinaryRequestParameter : UploadBytesBinaryRequestParameter = <UploadBytesBinaryRequestParameter>o;
            return java.util.Objects.equals(this.__contentType, uploadBytesBinaryRequestParameter.__contentType) && java.util.Objects.equals(this.__data, uploadBytesBinaryRequestParameter.__data) && java.util.Objects.equals(this.__keywords, uploadBytesBinaryRequestParameter.__keywords) && java.util.Objects.equals(this.__metadata, uploadBytesBinaryRequestParameter.__metadata) && java.util.Objects.equals(this.__name, uploadBytesBinaryRequestParameter.__name);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class UploadBytesBinaryRequestParameter {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__contentType)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    contentType: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__data)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    data: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__keywords)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    keywords: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__metadata)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    metadata: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__name)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    name: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    UploadBytesBinaryRequestParameter["__class"] = "io.nem.xpx.model.UploadBytesBinaryRequestParameter";

}
namespace io.nem.xpx.model {
    /**
     * UploadTextRequestParameter.
     * @class
     */
    export class UploadTextRequestParameter {
        /**
         * The content type.
         */
        /*private*/ __contentType : string = null;

        /**
         * The encoding.
         */
        /*private*/ __encoding : string = null;

        /**
         * The keywords.
         */
        /*private*/ __keywords : string = null;

        /**
         * The metadata.
         */
        /*private*/ __metadata : string = null;

        /**
         * The name.
         */
        /*private*/ __name : string = null;

        /**
         * The text.
         */
        /*private*/ __text : string = null;

        /**
         * Content type.
         * 
         * @param {string} contentType the content type
         * @return {io.nem.xpx.model.UploadTextRequestParameter} the upload text request parameter
         */
        public contentType(contentType : string) : UploadTextRequestParameter {
            this.__contentType = contentType;
            return this;
        }

        /**
         * Get contentType.
         * 
         * @return {string} contentType
         */
        public getContentType() : string {
            return this.__contentType;
        }

        /**
         * Sets the content type.
         * 
         * @param {string} contentType the new content type
         */
        public setContentType(contentType : string) {
            this.__contentType = contentType;
        }

        /**
         * Encoding.
         * 
         * @param {string} encoding the encoding
         * @return {io.nem.xpx.model.UploadTextRequestParameter} the upload text request parameter
         */
        public encoding(encoding : string) : UploadTextRequestParameter {
            this.__encoding = encoding;
            return this;
        }

        /**
         * Get encoding.
         * 
         * @return {string} encoding
         */
        public getEncoding() : string {
            return this.__encoding;
        }

        /**
         * Sets the encoding.
         * 
         * @param {string} encoding the new encoding
         */
        public setEncoding(encoding : string) {
            this.__encoding = encoding;
        }

        /**
         * Keywords.
         * 
         * @param {string} keywords the keywords
         * @return {io.nem.xpx.model.UploadTextRequestParameter} the upload text request parameter
         */
        public keywords(keywords : string) : UploadTextRequestParameter {
            this.__keywords = keywords;
            return this;
        }

        /**
         * Get keywords.
         * 
         * @return {string} keywords
         */
        public getKeywords() : string {
            return this.__keywords;
        }

        /**
         * Sets the keywords.
         * 
         * @param {string} keywords the new keywords
         */
        public setKeywords(keywords : string) {
            this.__keywords = keywords;
        }

        /**
         * Metadata.
         * 
         * @param {string} metadata the metadata
         * @return {io.nem.xpx.model.UploadTextRequestParameter} the upload text request parameter
         */
        public metadata(metadata : string) : UploadTextRequestParameter {
            this.__metadata = metadata;
            return this;
        }

        /**
         * Get metadata.
         * 
         * @return {string} metadata
         */
        public getMetadata() : string {
            return this.__metadata;
        }

        /**
         * Sets the metadata.
         * 
         * @param {string} metadata the new metadata
         */
        public setMetadata(metadata : string) {
            this.__metadata = metadata;
        }

        /**
         * Name.
         * 
         * @param {string} name the name
         * @return {io.nem.xpx.model.UploadTextRequestParameter} the upload text request parameter
         */
        public name(name : string) : UploadTextRequestParameter {
            this.__name = name;
            return this;
        }

        /**
         * Get name.
         * 
         * @return {string} name
         */
        public getName() : string {
            return this.__name;
        }

        /**
         * Sets the name.
         * 
         * @param {string} name the new name
         */
        public setName(name : string) {
            this.__name = name;
        }

        /**
         * Text.
         * 
         * @param {string} base64EncodedText the base 64 encoded text
         * @return {io.nem.xpx.model.UploadTextRequestParameter} the upload text request parameter
         */
        public text(base64EncodedText : string) : UploadTextRequestParameter {
            this.__text = base64EncodedText;
            return this;
        }

        /**
         * Get text.
         * 
         * @return {string} text
         */
        public getText() : string {
            return this.__text;
        }

        /**
         * Sets the text.
         * 
         * @param {string} text the new text
         */
        public setText(text : string) {
            this.__text = text;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let uploadTextRequestParameter : UploadTextRequestParameter = <UploadTextRequestParameter>o;
            return java.util.Objects.equals(this.__contentType, uploadTextRequestParameter.__contentType) && java.util.Objects.equals(this.__encoding, uploadTextRequestParameter.__encoding) && java.util.Objects.equals(this.__keywords, uploadTextRequestParameter.__keywords) && java.util.Objects.equals(this.__metadata, uploadTextRequestParameter.__metadata) && java.util.Objects.equals(this.__name, uploadTextRequestParameter.__name) && java.util.Objects.equals(this.__text, uploadTextRequestParameter.__text);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class UploadTextRequestParameter {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__contentType)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    contentType: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__encoding)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    encoding: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__keywords)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    keywords: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__metadata)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    metadata: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__name)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    name: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__text)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    text: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    UploadTextRequestParameter["__class"] = "io.nem.xpx.model.UploadTextRequestParameter";

}
namespace io.nem.xpx.model {
    /**
     * URI.
     * @class
     */
    export class URI {
        /**
         * The absolute.
         */
        /*private*/ __absolute : boolean = null;

        /**
         * The authority.
         */
        /*private*/ __authority : string = null;

        /**
         * The fragment.
         */
        /*private*/ __fragment : string = null;

        /**
         * The host.
         */
        /*private*/ __host : string = null;

        /**
         * The opaque.
         */
        /*private*/ __opaque : boolean = null;

        /**
         * The path.
         */
        /*private*/ __path : string = null;

        /**
         * The port.
         */
        /*private*/ __port : number = null;

        /**
         * The query.
         */
        /*private*/ __query : string = null;

        /**
         * The raw authority.
         */
        /*private*/ __rawAuthority : string = null;

        /**
         * The raw fragment.
         */
        /*private*/ __rawFragment : string = null;

        /**
         * The raw path.
         */
        /*private*/ __rawPath : string = null;

        /**
         * The raw query.
         */
        /*private*/ __rawQuery : string = null;

        /**
         * The raw scheme specific part.
         */
        /*private*/ __rawSchemeSpecificPart : string = null;

        /**
         * The raw user info.
         */
        /*private*/ __rawUserInfo : string = null;

        /**
         * The scheme.
         */
        /*private*/ __scheme : string = null;

        /**
         * The scheme specific part.
         */
        /*private*/ __schemeSpecificPart : string = null;

        /**
         * The user info.
         */
        /*private*/ __userInfo : string = null;

        /**
         * Absolute.
         * 
         * @param {boolean} absolute the absolute
         * @return {io.nem.xpx.model.URI} the uri
         */
        public absolute(absolute : boolean) : URI {
            this.__absolute = absolute;
            return this;
        }

        /**
         * Get absolute.
         * 
         * @return {boolean} absolute
         */
        public getAbsolute() : boolean {
            return this.__absolute;
        }

        /**
         * Sets the absolute.
         * 
         * @param {boolean} absolute the new absolute
         */
        public setAbsolute(absolute : boolean) {
            this.__absolute = absolute;
        }

        /**
         * Authority.
         * 
         * @param {string} authority the authority
         * @return {io.nem.xpx.model.URI} the uri
         */
        public authority(authority : string) : URI {
            this.__authority = authority;
            return this;
        }

        /**
         * Get authority.
         * 
         * @return {string} authority
         */
        public getAuthority() : string {
            return this.__authority;
        }

        /**
         * Sets the authority.
         * 
         * @param {string} authority the new authority
         */
        public setAuthority(authority : string) {
            this.__authority = authority;
        }

        /**
         * Fragment.
         * 
         * @param {string} fragment the fragment
         * @return {io.nem.xpx.model.URI} the uri
         */
        public fragment(fragment : string) : URI {
            this.__fragment = fragment;
            return this;
        }

        /**
         * Get fragment.
         * 
         * @return {string} fragment
         */
        public getFragment() : string {
            return this.__fragment;
        }

        /**
         * Sets the fragment.
         * 
         * @param {string} fragment the new fragment
         */
        public setFragment(fragment : string) {
            this.__fragment = fragment;
        }

        /**
         * Host.
         * 
         * @param {string} host the host
         * @return {io.nem.xpx.model.URI} the uri
         */
        public host(host : string) : URI {
            this.__host = host;
            return this;
        }

        /**
         * Get host.
         * 
         * @return {string} host
         */
        public getHost() : string {
            return this.__host;
        }

        /**
         * Sets the host.
         * 
         * @param {string} host the new host
         */
        public setHost(host : string) {
            this.__host = host;
        }

        /**
         * Opaque.
         * 
         * @param {boolean} opaque the opaque
         * @return {io.nem.xpx.model.URI} the uri
         */
        public opaque(opaque : boolean) : URI {
            this.__opaque = opaque;
            return this;
        }

        /**
         * Get opaque.
         * 
         * @return {boolean} opaque
         */
        public getOpaque() : boolean {
            return this.__opaque;
        }

        /**
         * Sets the opaque.
         * 
         * @param {boolean} opaque the new opaque
         */
        public setOpaque(opaque : boolean) {
            this.__opaque = opaque;
        }

        /**
         * Path.
         * 
         * @param {string} path the path
         * @return {io.nem.xpx.model.URI} the uri
         */
        public path(path : string) : URI {
            this.__path = path;
            return this;
        }

        /**
         * Get path.
         * 
         * @return {string} path
         */
        public getPath() : string {
            return this.__path;
        }

        /**
         * Sets the path.
         * 
         * @param {string} path the new path
         */
        public setPath(path : string) {
            this.__path = path;
        }

        /**
         * Port.
         * 
         * @param {number} port the port
         * @return {io.nem.xpx.model.URI} the uri
         */
        public port(port : number) : URI {
            this.__port = port;
            return this;
        }

        /**
         * Get port.
         * 
         * @return {number} port
         */
        public getPort() : number {
            return this.__port;
        }

        /**
         * Sets the port.
         * 
         * @param {number} port the new port
         */
        public setPort(port : number) {
            this.__port = port;
        }

        /**
         * Query.
         * 
         * @param {string} query the query
         * @return {io.nem.xpx.model.URI} the uri
         */
        public query(query : string) : URI {
            this.__query = query;
            return this;
        }

        /**
         * Get query.
         * 
         * @return {string} query
         */
        public getQuery() : string {
            return this.__query;
        }

        /**
         * Sets the query.
         * 
         * @param {string} query the new query
         */
        public setQuery(query : string) {
            this.__query = query;
        }

        /**
         * Raw authority.
         * 
         * @param {string} rawAuthority the raw authority
         * @return {io.nem.xpx.model.URI} the uri
         */
        public rawAuthority(rawAuthority : string) : URI {
            this.__rawAuthority = rawAuthority;
            return this;
        }

        /**
         * Get rawAuthority.
         * 
         * @return {string} rawAuthority
         */
        public getRawAuthority() : string {
            return this.__rawAuthority;
        }

        /**
         * Sets the raw authority.
         * 
         * @param {string} rawAuthority the new raw authority
         */
        public setRawAuthority(rawAuthority : string) {
            this.__rawAuthority = rawAuthority;
        }

        /**
         * Raw fragment.
         * 
         * @param {string} rawFragment the raw fragment
         * @return {io.nem.xpx.model.URI} the uri
         */
        public rawFragment(rawFragment : string) : URI {
            this.__rawFragment = rawFragment;
            return this;
        }

        /**
         * Get rawFragment.
         * 
         * @return {string} rawFragment
         */
        public getRawFragment() : string {
            return this.__rawFragment;
        }

        /**
         * Sets the raw fragment.
         * 
         * @param {string} rawFragment the new raw fragment
         */
        public setRawFragment(rawFragment : string) {
            this.__rawFragment = rawFragment;
        }

        /**
         * Raw path.
         * 
         * @param {string} rawPath the raw path
         * @return {io.nem.xpx.model.URI} the uri
         */
        public rawPath(rawPath : string) : URI {
            this.__rawPath = rawPath;
            return this;
        }

        /**
         * Get rawPath.
         * 
         * @return {string} rawPath
         */
        public getRawPath() : string {
            return this.__rawPath;
        }

        /**
         * Sets the raw path.
         * 
         * @param {string} rawPath the new raw path
         */
        public setRawPath(rawPath : string) {
            this.__rawPath = rawPath;
        }

        /**
         * Raw query.
         * 
         * @param {string} rawQuery the raw query
         * @return {io.nem.xpx.model.URI} the uri
         */
        public rawQuery(rawQuery : string) : URI {
            this.__rawQuery = rawQuery;
            return this;
        }

        /**
         * Get rawQuery.
         * 
         * @return {string} rawQuery
         */
        public getRawQuery() : string {
            return this.__rawQuery;
        }

        /**
         * Sets the raw query.
         * 
         * @param {string} rawQuery the new raw query
         */
        public setRawQuery(rawQuery : string) {
            this.__rawQuery = rawQuery;
        }

        /**
         * Raw scheme specific part.
         * 
         * @param {string} rawSchemeSpecificPart the raw scheme specific part
         * @return {io.nem.xpx.model.URI} the uri
         */
        public rawSchemeSpecificPart(rawSchemeSpecificPart : string) : URI {
            this.__rawSchemeSpecificPart = rawSchemeSpecificPart;
            return this;
        }

        /**
         * Get rawSchemeSpecificPart.
         * 
         * @return {string} rawSchemeSpecificPart
         */
        public getRawSchemeSpecificPart() : string {
            return this.__rawSchemeSpecificPart;
        }

        /**
         * Sets the raw scheme specific part.
         * 
         * @param {string} rawSchemeSpecificPart the new raw scheme specific part
         */
        public setRawSchemeSpecificPart(rawSchemeSpecificPart : string) {
            this.__rawSchemeSpecificPart = rawSchemeSpecificPart;
        }

        /**
         * Raw user info.
         * 
         * @param {string} rawUserInfo the raw user info
         * @return {io.nem.xpx.model.URI} the uri
         */
        public rawUserInfo(rawUserInfo : string) : URI {
            this.__rawUserInfo = rawUserInfo;
            return this;
        }

        /**
         * Get rawUserInfo.
         * 
         * @return {string} rawUserInfo
         */
        public getRawUserInfo() : string {
            return this.__rawUserInfo;
        }

        /**
         * Sets the raw user info.
         * 
         * @param {string} rawUserInfo the new raw user info
         */
        public setRawUserInfo(rawUserInfo : string) {
            this.__rawUserInfo = rawUserInfo;
        }

        /**
         * Scheme.
         * 
         * @param {string} scheme the scheme
         * @return {io.nem.xpx.model.URI} the uri
         */
        public scheme(scheme : string) : URI {
            this.__scheme = scheme;
            return this;
        }

        /**
         * Get scheme.
         * 
         * @return {string} scheme
         */
        public getScheme() : string {
            return this.__scheme;
        }

        /**
         * Sets the scheme.
         * 
         * @param {string} scheme the new scheme
         */
        public setScheme(scheme : string) {
            this.__scheme = scheme;
        }

        /**
         * Scheme specific part.
         * 
         * @param {string} schemeSpecificPart the scheme specific part
         * @return {io.nem.xpx.model.URI} the uri
         */
        public schemeSpecificPart(schemeSpecificPart : string) : URI {
            this.__schemeSpecificPart = schemeSpecificPart;
            return this;
        }

        /**
         * Get schemeSpecificPart.
         * 
         * @return {string} schemeSpecificPart
         */
        public getSchemeSpecificPart() : string {
            return this.__schemeSpecificPart;
        }

        /**
         * Sets the scheme specific part.
         * 
         * @param {string} schemeSpecificPart the new scheme specific part
         */
        public setSchemeSpecificPart(schemeSpecificPart : string) {
            this.__schemeSpecificPart = schemeSpecificPart;
        }

        /**
         * User info.
         * 
         * @param {string} userInfo the user info
         * @return {io.nem.xpx.model.URI} the uri
         */
        public userInfo(userInfo : string) : URI {
            this.__userInfo = userInfo;
            return this;
        }

        /**
         * Get userInfo.
         * 
         * @return {string} userInfo
         */
        public getUserInfo() : string {
            return this.__userInfo;
        }

        /**
         * Sets the user info.
         * 
         * @param {string} userInfo the new user info
         */
        public setUserInfo(userInfo : string) {
            this.__userInfo = userInfo;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let URI : URI = <URI>o;
            return java.util.Objects.equals(this.__absolute, URI.__absolute) && java.util.Objects.equals(this.__authority, URI.__authority) && java.util.Objects.equals(this.__fragment, URI.__fragment) && java.util.Objects.equals(this.__host, URI.__host) && java.util.Objects.equals(this.__opaque, URI.__opaque) && java.util.Objects.equals(this.__path, URI.__path) && java.util.Objects.equals(this.__port, URI.__port) && java.util.Objects.equals(this.__query, URI.__query) && java.util.Objects.equals(this.__rawAuthority, URI.__rawAuthority) && java.util.Objects.equals(this.__rawFragment, URI.__rawFragment) && java.util.Objects.equals(this.__rawPath, URI.__rawPath) && java.util.Objects.equals(this.__rawQuery, URI.__rawQuery) && java.util.Objects.equals(this.__rawSchemeSpecificPart, URI.__rawSchemeSpecificPart) && java.util.Objects.equals(this.__rawUserInfo, URI.__rawUserInfo) && java.util.Objects.equals(this.__scheme, URI.__scheme) && java.util.Objects.equals(this.__schemeSpecificPart, URI.__schemeSpecificPart) && java.util.Objects.equals(this.__userInfo, URI.__userInfo);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class URI {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__absolute)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    absolute: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__authority)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    authority: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__fragment)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    fragment: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__host)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    host: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__opaque)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    opaque: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__path)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    path: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__port)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    port: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__query)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    query: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__rawAuthority)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    rawAuthority: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__rawFragment)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    rawFragment: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__rawPath)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    rawPath: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__rawQuery)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    rawQuery: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__rawSchemeSpecificPart)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    rawSchemeSpecificPart: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__rawUserInfo)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    rawUserInfo: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__scheme)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    scheme: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__schemeSpecificPart)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    schemeSpecificPart: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__userInfo)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    userInfo: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    URI["__class"] = "io.nem.xpx.model.URI";

}
namespace io.nem.xpx.model {
    /**
     * URL.
     * @class
     */
    export class URL {
        /**
         * The authority.
         */
        /*private*/ __authority : string = null;

        /**
         * The content.
         */
        /*private*/ __content : any = null;

        /**
         * The default port.
         */
        /*private*/ __defaultPort : number = null;

        /**
         * The file.
         */
        /*private*/ __file : string = null;

        /**
         * The host.
         */
        /*private*/ __host : string = null;

        /**
         * The path.
         */
        /*private*/ __path : string = null;

        /**
         * The port.
         */
        /*private*/ __port : number = null;

        /**
         * The protocol.
         */
        /*private*/ __protocol : string = null;

        /**
         * The query.
         */
        /*private*/ __query : string = null;

        /**
         * The ref.
         */
        /*private*/ __ref : string = null;

        /**
         * The user info.
         */
        /*private*/ __userInfo : string = null;

        /**
         * Authority.
         * 
         * @param {string} authority the authority
         * @return {io.nem.xpx.model.URL} the url
         */
        public authority(authority : string) : URL {
            this.__authority = authority;
            return this;
        }

        /**
         * Get authority.
         * 
         * @return {string} authority
         */
        public getAuthority() : string {
            return this.__authority;
        }

        /**
         * Sets the authority.
         * 
         * @param {string} authority the new authority
         */
        public setAuthority(authority : string) {
            this.__authority = authority;
        }

        /**
         * Content.
         * 
         * @param {*} content the content
         * @return {io.nem.xpx.model.URL} the url
         */
        public content(content : any) : URL {
            this.__content = content;
            return this;
        }

        /**
         * Get content.
         * 
         * @return {*} content
         */
        public getContent() : any {
            return this.__content;
        }

        /**
         * Sets the content.
         * 
         * @param {*} content the new content
         */
        public setContent(content : any) {
            this.__content = content;
        }

        /**
         * Default port.
         * 
         * @param {number} defaultPort the default port
         * @return {io.nem.xpx.model.URL} the url
         */
        public defaultPort(defaultPort : number) : URL {
            this.__defaultPort = defaultPort;
            return this;
        }

        /**
         * Get defaultPort.
         * 
         * @return {number} defaultPort
         */
        public getDefaultPort() : number {
            return this.__defaultPort;
        }

        /**
         * Sets the default port.
         * 
         * @param {number} defaultPort the new default port
         */
        public setDefaultPort(defaultPort : number) {
            this.__defaultPort = defaultPort;
        }

        /**
         * File.
         * 
         * @param {string} file the file
         * @return {io.nem.xpx.model.URL} the url
         */
        public file(file : string) : URL {
            this.__file = file;
            return this;
        }

        /**
         * Get file.
         * 
         * @return {string} file
         */
        public getFile() : string {
            return this.__file;
        }

        /**
         * Sets the file.
         * 
         * @param {string} file the new file
         */
        public setFile(file : string) {
            this.__file = file;
        }

        /**
         * Host.
         * 
         * @param {string} host the host
         * @return {io.nem.xpx.model.URL} the url
         */
        public host(host : string) : URL {
            this.__host = host;
            return this;
        }

        /**
         * Get host.
         * 
         * @return {string} host
         */
        public getHost() : string {
            return this.__host;
        }

        /**
         * Sets the host.
         * 
         * @param {string} host the new host
         */
        public setHost(host : string) {
            this.__host = host;
        }

        /**
         * Path.
         * 
         * @param {string} path the path
         * @return {io.nem.xpx.model.URL} the url
         */
        public path(path : string) : URL {
            this.__path = path;
            return this;
        }

        /**
         * Get path.
         * 
         * @return {string} path
         */
        public getPath() : string {
            return this.__path;
        }

        /**
         * Sets the path.
         * 
         * @param {string} path the new path
         */
        public setPath(path : string) {
            this.__path = path;
        }

        /**
         * Port.
         * 
         * @param {number} port the port
         * @return {io.nem.xpx.model.URL} the url
         */
        public port(port : number) : URL {
            this.__port = port;
            return this;
        }

        /**
         * Get port.
         * 
         * @return {number} port
         */
        public getPort() : number {
            return this.__port;
        }

        /**
         * Sets the port.
         * 
         * @param {number} port the new port
         */
        public setPort(port : number) {
            this.__port = port;
        }

        /**
         * Protocol.
         * 
         * @param {string} protocol the protocol
         * @return {io.nem.xpx.model.URL} the url
         */
        public protocol(protocol : string) : URL {
            this.__protocol = protocol;
            return this;
        }

        /**
         * Get protocol.
         * 
         * @return {string} protocol
         */
        public getProtocol() : string {
            return this.__protocol;
        }

        /**
         * Sets the protocol.
         * 
         * @param {string} protocol the new protocol
         */
        public setProtocol(protocol : string) {
            this.__protocol = protocol;
        }

        /**
         * Query.
         * 
         * @param {string} query the query
         * @return {io.nem.xpx.model.URL} the url
         */
        public query(query : string) : URL {
            this.__query = query;
            return this;
        }

        /**
         * Get query.
         * 
         * @return {string} query
         */
        public getQuery() : string {
            return this.__query;
        }

        /**
         * Sets the query.
         * 
         * @param {string} query the new query
         */
        public setQuery(query : string) {
            this.__query = query;
        }

        /**
         * Ref.
         * 
         * @param {string} ref the ref
         * @return {io.nem.xpx.model.URL} the url
         */
        public ref(ref : string) : URL {
            this.__ref = ref;
            return this;
        }

        /**
         * Get ref.
         * 
         * @return {string} ref
         */
        public getRef() : string {
            return this.__ref;
        }

        /**
         * Sets the ref.
         * 
         * @param {string} ref the new ref
         */
        public setRef(ref : string) {
            this.__ref = ref;
        }

        /**
         * User info.
         * 
         * @param {string} userInfo the user info
         * @return {io.nem.xpx.model.URL} the url
         */
        public userInfo(userInfo : string) : URL {
            this.__userInfo = userInfo;
            return this;
        }

        /**
         * Get userInfo.
         * 
         * @return {string} userInfo
         */
        public getUserInfo() : string {
            return this.__userInfo;
        }

        /**
         * Sets the user info.
         * 
         * @param {string} userInfo the new user info
         */
        public setUserInfo(userInfo : string) {
            this.__userInfo = userInfo;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let URL : URL = <URL>o;
            return java.util.Objects.equals(this.__authority, URL.__authority) && java.util.Objects.equals(this.__content, URL.__content) && java.util.Objects.equals(this.__defaultPort, URL.__defaultPort) && java.util.Objects.equals(this.__file, URL.__file) && java.util.Objects.equals(this.__host, URL.__host) && java.util.Objects.equals(this.__path, URL.__path) && java.util.Objects.equals(this.__port, URL.__port) && java.util.Objects.equals(this.__protocol, URL.__protocol) && java.util.Objects.equals(this.__query, URL.__query) && java.util.Objects.equals(this.__ref, URL.__ref) && java.util.Objects.equals(this.__userInfo, URL.__userInfo);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class URL {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__authority)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    authority: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__content)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    content: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__defaultPort)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    defaultPort: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__file)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    file: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__host)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    host: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__path)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    path: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__port)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    port: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__protocol)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    protocol: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__query)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    query: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__ref)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    ref: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__userInfo)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    userInfo: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }
    }
    URL["__class"] = "io.nem.xpx.model.URL";

}
namespace io.nem.xpx.model {
    /**
     * The Class Globals.
     * @class
     */
    export class XpxSdkGlobalConstants {
        /**
         * The Constant TIME_PROVIDER.
         */
        public static TIME_PROVIDER : org.nem.core.time.TimeProvider; public static TIME_PROVIDER_$LI$() : org.nem.core.time.TimeProvider { if(XpxSdkGlobalConstants.TIME_PROVIDER == null) XpxSdkGlobalConstants.TIME_PROVIDER = new org.nem.core.time.SystemTimeProvider(); return XpxSdkGlobalConstants.TIME_PROVIDER; };
    }
    XpxSdkGlobalConstants["__class"] = "io.nem.xpx.model.XpxSdkGlobalConstants";

}
namespace io.nem.xpx.service.common {
    export class FileAndNamingRouteApi {
        /*private*/ apiClient : io.nem.ApiClient;

        public constructor(apiClient : io.nem.ApiClient) {
            if(this.apiClient===undefined) this.apiClient = null;
            this.apiClient = apiClient;
        }

        public getApiClient() : io.nem.ApiClient {
            return this.apiClient;
        }

        public setApiClient(apiClient : io.nem.ApiClient) {
            this.apiClient = apiClient;
        }

        /**
         * Build call for directXipnsGetUsingGET
         * @param {string} ipfsHash ipfsHash (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public directXipnsGetUsingGETCall(ipfsHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/xipns/{ipfsHash}".replace(new RegExp("\\{ipfsHash\\}", 'g'),this.apiClient.escapeString(ipfsHash.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new FileAndNamingRouteApi.FileAndNamingRouteApi$0(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /*private*/ directXipnsGetUsingGETValidateBeforeCall(ipfsHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(ipfsHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'ipfsHash\' when calling directXipnsGetUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.directXipnsGetUsingGETCall(ipfsHash, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Download associated file of the given NEM Hash
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} ipfsHash ipfsHash (required)
         * @return {Array} byte[]
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public directXipnsGetUsingGET(ipfsHash : string) : number[] {
            let resp : io.nem.ApiResponse<number[]> = this.directXipnsGetUsingGETWithHttpInfo(ipfsHash);
            return resp.getData();
        }

        /**
         * Download associated file of the given NEM Hash
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} ipfsHash ipfsHash (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;byte[]&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public directXipnsGetUsingGETWithHttpInfo(ipfsHash : string) : io.nem.ApiResponse<number[]> {
            let call : com.squareup.okhttp.Call = this.directXipnsGetUsingGETValidateBeforeCall(ipfsHash, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Download associated file of the given NEM Hash (asynchronously)
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} ipfsHash ipfsHash (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public directXipnsGetUsingGETAsync(ipfsHash : string, callback : io.nem.ApiCallback<number[]>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$1(this, callback);
                progressRequestListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$2(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.directXipnsGetUsingGETValidateBeforeCall(ipfsHash, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for directXipnsHeadUsingHEAD
         * @param {string} ipfsHash ipfsHash (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public directXipnsHeadUsingHEADCall(ipfsHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/xipns/{ipfsHash}".replace(new RegExp("\\{ipfsHash\\}", 'g'),this.apiClient.escapeString(ipfsHash.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new FileAndNamingRouteApi.FileAndNamingRouteApi$3(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "HEAD", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /*private*/ directXipnsHeadUsingHEADValidateBeforeCall(ipfsHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(ipfsHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'ipfsHash\' when calling directXipnsHeadUsingHEAD(Async)");
            }
            let call : com.squareup.okhttp.Call = this.directXipnsHeadUsingHEADCall(ipfsHash, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Download associated file of the given NEM Hash
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} ipfsHash ipfsHash (required)
         * @return {Array} byte[]
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public directXipnsHeadUsingHEAD(ipfsHash : string) : number[] {
            let resp : io.nem.ApiResponse<number[]> = this.directXipnsHeadUsingHEADWithHttpInfo(ipfsHash);
            return resp.getData();
        }

        /**
         * Download associated file of the given NEM Hash
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} ipfsHash ipfsHash (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;byte[]&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public directXipnsHeadUsingHEADWithHttpInfo(ipfsHash : string) : io.nem.ApiResponse<number[]> {
            let call : com.squareup.okhttp.Call = this.directXipnsHeadUsingHEADValidateBeforeCall(ipfsHash, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Download associated file of the given NEM Hash (asynchronously)
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} ipfsHash ipfsHash (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public directXipnsHeadUsingHEADAsync(ipfsHash : string, callback : io.nem.ApiCallback<number[]>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$4(this, callback);
                progressRequestListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$5(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.directXipnsHeadUsingHEADValidateBeforeCall(ipfsHash, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for directXpxfsGetUsingGET
         * @param {string} nemHash nemHash (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public directXpxfsGetUsingGETCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/xpxfs/{nemHash}".replace(new RegExp("\\{nemHash\\}", 'g'),this.apiClient.escapeString(nemHash.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new FileAndNamingRouteApi.FileAndNamingRouteApi$6(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /*private*/ directXpxfsGetUsingGETValidateBeforeCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(nemHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'nemHash\' when calling directXpxfsGetUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.directXpxfsGetUsingGETCall(nemHash, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Download associated file of the given NEM Hash
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} nemHash nemHash (required)
         * @return {Array} byte[]
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public directXpxfsGetUsingGET(nemHash : string) : number[] {
            let resp : io.nem.ApiResponse<number[]> = this.directXpxfsGetUsingGETWithHttpInfo(nemHash);
            return resp.getData();
        }

        /**
         * Download associated file of the given NEM Hash
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} nemHash nemHash (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;byte[]&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public directXpxfsGetUsingGETWithHttpInfo(nemHash : string) : io.nem.ApiResponse<number[]> {
            let call : com.squareup.okhttp.Call = this.directXpxfsGetUsingGETValidateBeforeCall(nemHash, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Download associated file of the given NEM Hash (asynchronously)
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} nemHash nemHash (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public directXpxfsGetUsingGETAsync(nemHash : string, callback : io.nem.ApiCallback<number[]>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$7(this, callback);
                progressRequestListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$8(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.directXpxfsGetUsingGETValidateBeforeCall(nemHash, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for directXpxfsHeadUsingHEAD
         * @param {string} nemHash nemHash (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public directXpxfsHeadUsingHEADCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/xpxfs/{nemHash}".replace(new RegExp("\\{nemHash\\}", 'g'),this.apiClient.escapeString(nemHash.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new FileAndNamingRouteApi.FileAndNamingRouteApi$9(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "HEAD", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /*private*/ directXpxfsHeadUsingHEADValidateBeforeCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(nemHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'nemHash\' when calling directXpxfsHeadUsingHEAD(Async)");
            }
            let call : com.squareup.okhttp.Call = this.directXpxfsHeadUsingHEADCall(nemHash, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Download associated file of the given NEM Hash
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} nemHash nemHash (required)
         * @return {Array} byte[]
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public directXpxfsHeadUsingHEAD(nemHash : string) : number[] {
            let resp : io.nem.ApiResponse<number[]> = this.directXpxfsHeadUsingHEADWithHttpInfo(nemHash);
            return resp.getData();
        }

        /**
         * Download associated file of the given NEM Hash
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} nemHash nemHash (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;byte[]&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public directXpxfsHeadUsingHEADWithHttpInfo(nemHash : string) : io.nem.ApiResponse<number[]> {
            let call : com.squareup.okhttp.Call = this.directXpxfsHeadUsingHEADValidateBeforeCall(nemHash, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Download associated file of the given NEM Hash (asynchronously)
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} nemHash nemHash (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public directXpxfsHeadUsingHEADAsync(nemHash : string, callback : io.nem.ApiCallback<number[]>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$10(this, callback);
                progressRequestListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$11(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.directXpxfsHeadUsingHEADValidateBeforeCall(nemHash, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for directXpxnsGetUsingGET
         * @param {string} nemHash nemHash (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public directXpxnsGetUsingGETCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/xpxns/{nemHash}".replace(new RegExp("\\{nemHash\\}", 'g'),this.apiClient.escapeString(nemHash.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new FileAndNamingRouteApi.FileAndNamingRouteApi$12(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /*private*/ directXpxnsGetUsingGETValidateBeforeCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(nemHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'nemHash\' when calling directXpxnsGetUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.directXpxnsGetUsingGETCall(nemHash, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Download associated file of the given NEM Hash
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} nemHash nemHash (required)
         * @return {Array} byte[]
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public directXpxnsGetUsingGET(nemHash : string) : number[] {
            let resp : io.nem.ApiResponse<number[]> = this.directXpxnsGetUsingGETWithHttpInfo(nemHash);
            return resp.getData();
        }

        /**
         * Download associated file of the given NEM Hash
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} nemHash nemHash (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;byte[]&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public directXpxnsGetUsingGETWithHttpInfo(nemHash : string) : io.nem.ApiResponse<number[]> {
            let call : com.squareup.okhttp.Call = this.directXpxnsGetUsingGETValidateBeforeCall(nemHash, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Download associated file of the given NEM Hash (asynchronously)
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} nemHash nemHash (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public directXpxnsGetUsingGETAsync(nemHash : string, callback : io.nem.ApiCallback<number[]>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$13(this, callback);
                progressRequestListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$14(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.directXpxnsGetUsingGETValidateBeforeCall(nemHash, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for directXpxnsHeadUsingHEAD
         * @param {string} nemHash nemHash (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public directXpxnsHeadUsingHEADCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/xpxns/{nemHash}".replace(new RegExp("\\{nemHash\\}", 'g'),this.apiClient.escapeString(nemHash.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new FileAndNamingRouteApi.FileAndNamingRouteApi$15(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "HEAD", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /*private*/ directXpxnsHeadUsingHEADValidateBeforeCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(nemHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'nemHash\' when calling directXpxnsHeadUsingHEAD(Async)");
            }
            let call : com.squareup.okhttp.Call = this.directXpxnsHeadUsingHEADCall(nemHash, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Download associated file of the given NEM Hash
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} nemHash nemHash (required)
         * @return {Array} byte[]
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public directXpxnsHeadUsingHEAD(nemHash : string) : number[] {
            let resp : io.nem.ApiResponse<number[]> = this.directXpxnsHeadUsingHEADWithHttpInfo(nemHash);
            return resp.getData();
        }

        /**
         * Download associated file of the given NEM Hash
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} nemHash nemHash (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;byte[]&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public directXpxnsHeadUsingHEADWithHttpInfo(nemHash : string) : io.nem.ApiResponse<number[]> {
            let call : com.squareup.okhttp.Call = this.directXpxnsHeadUsingHEADValidateBeforeCall(nemHash, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Download associated file of the given NEM Hash (asynchronously)
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} nemHash nemHash (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public directXpxnsHeadUsingHEADAsync(nemHash : string, callback : io.nem.ApiCallback<number[]>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$16(this, callback);
                progressRequestListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$17(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.directXpxnsHeadUsingHEADValidateBeforeCall(nemHash, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for directxIpfsGetUsingGET
         * @param {string} ipfsHash ipfsHash (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public directxIpfsGetUsingGETCall(ipfsHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/xipfs/{ipfsHash}".replace(new RegExp("\\{ipfsHash\\}", 'g'),this.apiClient.escapeString(ipfsHash.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new FileAndNamingRouteApi.FileAndNamingRouteApi$18(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /*private*/ directxIpfsGetUsingGETValidateBeforeCall(ipfsHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(ipfsHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'ipfsHash\' when calling directxIpfsGetUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.directxIpfsGetUsingGETCall(ipfsHash, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Download associated file of the given NEM Hash
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} ipfsHash ipfsHash (required)
         * @return {Array} byte[]
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public directxIpfsGetUsingGET(ipfsHash : string) : number[] {
            let resp : io.nem.ApiResponse<number[]> = this.directxIpfsGetUsingGETWithHttpInfo(ipfsHash);
            return resp.getData();
        }

        /**
         * Download associated file of the given NEM Hash
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} ipfsHash ipfsHash (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;byte[]&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public directxIpfsGetUsingGETWithHttpInfo(ipfsHash : string) : io.nem.ApiResponse<number[]> {
            let call : com.squareup.okhttp.Call = this.directxIpfsGetUsingGETValidateBeforeCall(ipfsHash, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Download associated file of the given NEM Hash (asynchronously)
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} ipfsHash ipfsHash (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public directxIpfsGetUsingGETAsync(ipfsHash : string, callback : io.nem.ApiCallback<number[]>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$19(this, callback);
                progressRequestListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$20(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.directxIpfsGetUsingGETValidateBeforeCall(ipfsHash, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for directxIpfsHeadUsingHEAD
         * @param {string} ipfsHash ipfsHash (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public directxIpfsHeadUsingHEADCall(ipfsHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/xipfs/{ipfsHash}".replace(new RegExp("\\{ipfsHash\\}", 'g'),this.apiClient.escapeString(ipfsHash.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new FileAndNamingRouteApi.FileAndNamingRouteApi$21(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "HEAD", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /*private*/ directxIpfsHeadUsingHEADValidateBeforeCall(ipfsHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(ipfsHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'ipfsHash\' when calling directxIpfsHeadUsingHEAD(Async)");
            }
            let call : com.squareup.okhttp.Call = this.directxIpfsHeadUsingHEADCall(ipfsHash, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Download associated file of the given NEM Hash
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} ipfsHash ipfsHash (required)
         * @return {Array} byte[]
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public directxIpfsHeadUsingHEAD(ipfsHash : string) : number[] {
            let resp : io.nem.ApiResponse<number[]> = this.directxIpfsHeadUsingHEADWithHttpInfo(ipfsHash);
            return resp.getData();
        }

        /**
         * Download associated file of the given NEM Hash
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} ipfsHash ipfsHash (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;byte[]&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public directxIpfsHeadUsingHEADWithHttpInfo(ipfsHash : string) : io.nem.ApiResponse<number[]> {
            let call : com.squareup.okhttp.Call = this.directxIpfsHeadUsingHEADValidateBeforeCall(ipfsHash, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Download associated file of the given NEM Hash (asynchronously)
         * Download associated file of the given NEM Hash (This is only applicable to public files only)
         * @param {string} ipfsHash ipfsHash (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public directxIpfsHeadUsingHEADAsync(ipfsHash : string, callback : io.nem.ApiCallback<number[]>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$22(this, callback);
                progressRequestListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$23(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.directxIpfsHeadUsingHEADValidateBeforeCall(ipfsHash, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for loadXpxfsDirectoryGetUsingGET
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public loadXpxfsDirectoryGetUsingGETCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/xpxfs/{nemHash}/**".replace(new RegExp("\\{nemHash\\}", 'g'),this.apiClient.escapeString(nemHash.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new FileAndNamingRouteApi.FileAndNamingRouteApi$24(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /*private*/ loadXpxfsDirectoryGetUsingGETValidateBeforeCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(nemHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'nemHash\' when calling loadXpxfsDirectoryGetUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.loadXpxfsDirectoryGetUsingGETCall(nemHash, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Loads a directory that&#39;s rooted from the NEM Blockchain
         * Loads a Static Content.
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @return {*} Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public loadXpxfsDirectoryGetUsingGET(nemHash : string) : any {
            let resp : io.nem.ApiResponse<any> = this.loadXpxfsDirectoryGetUsingGETWithHttpInfo(nemHash);
            return resp.getData();
        }

        /**
         * Loads a directory that&#39;s rooted from the NEM Blockchain
         * Loads a Static Content.
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public loadXpxfsDirectoryGetUsingGETWithHttpInfo(nemHash : string) : io.nem.ApiResponse<any> {
            let call : com.squareup.okhttp.Call = this.loadXpxfsDirectoryGetUsingGETValidateBeforeCall(nemHash, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<any>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<any>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Loads a directory that&#39;s rooted from the NEM Blockchain (asynchronously)
         * Loads a Static Content.
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public loadXpxfsDirectoryGetUsingGETAsync(nemHash : string, callback : io.nem.ApiCallback<any>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$25(this, callback);
                progressRequestListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$26(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.loadXpxfsDirectoryGetUsingGETValidateBeforeCall(nemHash, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<any>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<any>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for loadXpxfsDirectoryHeadUsingHEAD
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public loadXpxfsDirectoryHeadUsingHEADCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/xpxfs/{nemHash}/**".replace(new RegExp("\\{nemHash\\}", 'g'),this.apiClient.escapeString(nemHash.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new FileAndNamingRouteApi.FileAndNamingRouteApi$27(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "HEAD", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /*private*/ loadXpxfsDirectoryHeadUsingHEADValidateBeforeCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(nemHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'nemHash\' when calling loadXpxfsDirectoryHeadUsingHEAD(Async)");
            }
            let call : com.squareup.okhttp.Call = this.loadXpxfsDirectoryHeadUsingHEADCall(nemHash, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Loads a directory that&#39;s rooted from the NEM Blockchain
         * Loads a Static Content.
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @return {*} Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public loadXpxfsDirectoryHeadUsingHEAD(nemHash : string) : any {
            let resp : io.nem.ApiResponse<any> = this.loadXpxfsDirectoryHeadUsingHEADWithHttpInfo(nemHash);
            return resp.getData();
        }

        /**
         * Loads a directory that&#39;s rooted from the NEM Blockchain
         * Loads a Static Content.
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public loadXpxfsDirectoryHeadUsingHEADWithHttpInfo(nemHash : string) : io.nem.ApiResponse<any> {
            let call : com.squareup.okhttp.Call = this.loadXpxfsDirectoryHeadUsingHEADValidateBeforeCall(nemHash, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<any>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<any>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Loads a directory that&#39;s rooted from the NEM Blockchain (asynchronously)
         * Loads a Static Content.
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public loadXpxfsDirectoryHeadUsingHEADAsync(nemHash : string, callback : io.nem.ApiCallback<any>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$28(this, callback);
                progressRequestListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$29(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.loadXpxfsDirectoryHeadUsingHEADValidateBeforeCall(nemHash, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<any>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<any>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for loadXpxnsDirectoryGetUsingGET
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public loadXpxnsDirectoryGetUsingGETCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/xpxns/{nemHash}/**".replace(new RegExp("\\{nemHash\\}", 'g'),this.apiClient.escapeString(nemHash.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new FileAndNamingRouteApi.FileAndNamingRouteApi$30(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /*private*/ loadXpxnsDirectoryGetUsingGETValidateBeforeCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(nemHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'nemHash\' when calling loadXpxnsDirectoryGetUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.loadXpxnsDirectoryGetUsingGETCall(nemHash, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Loads a directory that&#39;s rooted from the NEM Blockchain
         * Loads a Static Content.
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @return {*} Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public loadXpxnsDirectoryGetUsingGET(nemHash : string) : any {
            let resp : io.nem.ApiResponse<any> = this.loadXpxnsDirectoryGetUsingGETWithHttpInfo(nemHash);
            return resp.getData();
        }

        /**
         * Loads a directory that&#39;s rooted from the NEM Blockchain
         * Loads a Static Content.
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public loadXpxnsDirectoryGetUsingGETWithHttpInfo(nemHash : string) : io.nem.ApiResponse<any> {
            let call : com.squareup.okhttp.Call = this.loadXpxnsDirectoryGetUsingGETValidateBeforeCall(nemHash, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<any>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<any>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Loads a directory that&#39;s rooted from the NEM Blockchain (asynchronously)
         * Loads a Static Content.
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public loadXpxnsDirectoryGetUsingGETAsync(nemHash : string, callback : io.nem.ApiCallback<any>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$31(this, callback);
                progressRequestListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$32(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.loadXpxnsDirectoryGetUsingGETValidateBeforeCall(nemHash, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<any>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<any>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for loadXpxnsDirectoryHeadUsingHEAD
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public loadXpxnsDirectoryHeadUsingHEADCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/xpxns/{nemHash}/**".replace(new RegExp("\\{nemHash\\}", 'g'),this.apiClient.escapeString(nemHash.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new FileAndNamingRouteApi.FileAndNamingRouteApi$33(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "HEAD", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /*private*/ loadXpxnsDirectoryHeadUsingHEADValidateBeforeCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(nemHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'nemHash\' when calling loadXpxnsDirectoryHeadUsingHEAD(Async)");
            }
            let call : com.squareup.okhttp.Call = this.loadXpxnsDirectoryHeadUsingHEADCall(nemHash, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Loads a directory that&#39;s rooted from the NEM Blockchain
         * Loads a Static Content.
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @return {*} Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public loadXpxnsDirectoryHeadUsingHEAD(nemHash : string) : any {
            let resp : io.nem.ApiResponse<any> = this.loadXpxnsDirectoryHeadUsingHEADWithHttpInfo(nemHash);
            return resp.getData();
        }

        /**
         * Loads a directory that&#39;s rooted from the NEM Blockchain
         * Loads a Static Content.
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public loadXpxnsDirectoryHeadUsingHEADWithHttpInfo(nemHash : string) : io.nem.ApiResponse<any> {
            let call : com.squareup.okhttp.Call = this.loadXpxnsDirectoryHeadUsingHEADValidateBeforeCall(nemHash, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<any>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<any>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Loads a directory that&#39;s rooted from the NEM Blockchain (asynchronously)
         * Loads a Static Content.
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public loadXpxnsDirectoryHeadUsingHEADAsync(nemHash : string, callback : io.nem.ApiCallback<any>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$34(this, callback);
                progressRequestListener = new FileAndNamingRouteApi.FileAndNamingRouteApi$35(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.loadXpxnsDirectoryHeadUsingHEADValidateBeforeCall(nemHash, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<any>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<any>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }
    }
    FileAndNamingRouteApi["__class"] = "io.nem.xpx.service.common.FileAndNamingRouteApi";


    export namespace FileAndNamingRouteApi {

        export class FileAndNamingRouteApi$0 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$0["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class FileAndNamingRouteApi$1 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$1["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class FileAndNamingRouteApi$2 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$2["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class FileAndNamingRouteApi$3 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$3["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class FileAndNamingRouteApi$4 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$4["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class FileAndNamingRouteApi$5 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$5["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class FileAndNamingRouteApi$6 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$6["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class FileAndNamingRouteApi$7 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$7["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class FileAndNamingRouteApi$8 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$8["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class FileAndNamingRouteApi$9 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$9["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class FileAndNamingRouteApi$10 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$10["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class FileAndNamingRouteApi$11 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$11["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class FileAndNamingRouteApi$12 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$12["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class FileAndNamingRouteApi$13 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$13["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class FileAndNamingRouteApi$14 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$14["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class FileAndNamingRouteApi$15 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$15["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class FileAndNamingRouteApi$16 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$16["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class FileAndNamingRouteApi$17 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$17["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class FileAndNamingRouteApi$18 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$18["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class FileAndNamingRouteApi$19 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$19["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class FileAndNamingRouteApi$20 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$20["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class FileAndNamingRouteApi$21 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$21["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class FileAndNamingRouteApi$22 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$22["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class FileAndNamingRouteApi$23 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$23["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class FileAndNamingRouteApi$24 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$24["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class FileAndNamingRouteApi$25 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$25["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class FileAndNamingRouteApi$26 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$26["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class FileAndNamingRouteApi$27 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$27["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class FileAndNamingRouteApi$28 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$28["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class FileAndNamingRouteApi$29 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$29["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class FileAndNamingRouteApi$30 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$30["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class FileAndNamingRouteApi$31 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$31["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class FileAndNamingRouteApi$32 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$32["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class FileAndNamingRouteApi$33 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$33["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class FileAndNamingRouteApi$34 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$34["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class FileAndNamingRouteApi$35 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        FileAndNamingRouteApi$35["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];


    }

}
namespace io.nem.xpx.service.common {
    /**
     * Instantiates a new local search api.
     * 
     * @param {io.nem.xpx.service.NemTransactionApi} nemTransactionApi
     * 
     * the nem transaction api
     * @class
     */
    export abstract class PrivateSearchApi {
        /**
         * The nem transaction api.
         */
        /*private*/ nemTransactionApi : io.nem.xpx.service.NemTransactionApi;

        public constructor(nemTransactionApi : io.nem.xpx.service.NemTransactionApi) {
            if(this.nemTransactionApi===undefined) this.nemTransactionApi = null;
            this.nemTransactionApi = nemTransactionApi;
        }

        /**
         * Search transaction with name.
         * 
         * @param {string} xPvKey the x pv key
         * @param {string} xPubkey the x pubkey
         * @param {string} name the name
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]} the list
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        public searchTransactionWithName(xPvKey : string, xPubkey : string, name : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            let encryptedMessage : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> = <any>([]);
            /* addAll */((l1, l2) => l1.push.apply(l1, l2))(encryptedMessage, this.getNextForNameSearch(xPvKey, xPubkey, name, ""));
            return encryptedMessage;
        }

        /**
         * Search transaction with metadata key value pair.
         * 
         * @param {string} xPvKey the x pv key
         * @param {string} xPubkey the x pubkey
         * @param {string} key the key
         * @param {string} value the value
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]} the list
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        public searchTransactionWithMetadataKeyValuePair(xPvKey : string, xPubkey : string, key : string, value : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            let encryptedMessage : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> = <any>([]);
            /* addAll */((l1, l2) => l1.push.apply(l1, l2))(encryptedMessage, this.getNextForMetadataSearch(xPvKey, xPubkey, key, value, ""));
            return encryptedMessage;
        }

        /**
         * Search transaction with keyword.
         * 
         * @param {string} xPvKey the x pv key
         * @param {string} xPubkey the x pubkey
         * @param {string} keywords the keywords
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]} the list
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        public searchTransactionWithKeyword(xPvKey : string, xPubkey : string, keywords : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            let encryptedMessage : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> = <any>([]);
            /* addAll */((l1, l2) => l1.push.apply(l1, l2))(encryptedMessage, this.getNextForKeywordSearch(xPvKey, xPubkey, keywords, ""));
            return encryptedMessage;
        }

        /**
         * Gets the next for name search.
         * 
         * @param {string} xPvKey the x pv key
         * @param {string} xPubkey the x pubkey
         * @param {string} name the name
         * @param {string} hash the hash
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]} the next for name search
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         * @private
         */
        /*private*/ getNextForNameSearch(xPvKey : string, xPubkey : string, name : string, hash : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            let pvKey : org.nem.core.crypto.PrivateKey = org.nem.core.crypto.PrivateKey.fromHexString(xPvKey);
            let keyPair : org.nem.core.crypto.KeyPair = new org.nem.core.crypto.KeyPair(pvKey);
            let privateKeyAddress : string = org.nem.core.model.Address.fromPublicKey(keyPair.getPublicKey()).toString();
            let listOfTransactionMetadataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = null;
            if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(hash,""))) {
                listOfTransactionMetadataPair = this.nemTransactionApi.getAllTransactions$java_lang_String(privateKeyAddress);
            } else {
                listOfTransactionMetadataPair = this.nemTransactionApi.getAllTransactions$java_lang_String$java_lang_String(privateKeyAddress, hash);
            }
            let encryptedMessage : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> = <any>([]);
            let currentHash : string = "";
            for(let index160=0; index160 < listOfTransactionMetadataPair.length; index160++) {
                let tmp = listOfTransactionMetadataPair[index160];
                {
                    if(tmp.getEntity() != null && tmp.getEntity() instanceof <any>org.nem.core.model.TransferTransaction) {
                        currentHash = tmp.getMetaData().getHash().toString();
                        let transferTransaction : org.nem.core.model.TransferTransaction = <org.nem.core.model.TransferTransaction>tmp.getEntity();
                        if(this.checkIfTxnHaveXPXMosaic(transferTransaction)) {
                            let found : boolean = false;
                            try {
                                if(transferTransaction.getMessage().getType() === 1) {
                                    let resourceMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage = io.nem.xpx.service.model.buffers.ResourceHashMessage.getRootAsResourceHashMessage$java_nio_ByteBuffer(java.nio.ByteBuffer.wrap(org.apache.commons.codec.binary.Base64.decodeBase64(transferTransaction.getMessage().getDecodedPayload())));
                                    if(/* contains */(resourceMessage.name().toLowerCase().indexOf(name.toLowerCase()) != -1)) {
                                        /* add */(encryptedMessage.push(this.toEntity(currentHash, resourceMessage))>0);
                                    }
                                } else if(transferTransaction.getMessage().getType() === 2) {
                                    let secureMessage : org.nem.core.messages.SecureMessage = null;
                                    if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(transferTransaction.getSigner().getAddress().getEncoded(),privateKeyAddress))) {
                                        secureMessage = org.nem.core.messages.SecureMessage.fromEncodedPayload(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PrivateKey.fromHexString(xPvKey))), new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PublicKey.fromHexString(xPubkey))), transferTransaction.getMessage().getEncodedPayload());
                                    } else if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(transferTransaction.getRecipient().getAddress().getEncoded(),privateKeyAddress))) {
                                        secureMessage = org.nem.core.messages.SecureMessage.fromEncodedPayload(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PublicKey.fromHexString(xPubkey))), new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PrivateKey.fromHexString(xPvKey))), transferTransaction.getMessage().getEncodedPayload());
                                    }
                                    let resourceMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage = io.nem.xpx.service.model.buffers.ResourceHashMessage.getRootAsResourceHashMessage$java_nio_ByteBuffer(java.nio.ByteBuffer.wrap(org.apache.commons.codec.binary.Base64.decodeBase64(secureMessage.getDecodedPayload())));
                                    if(/* contains */(resourceMessage.name().toLowerCase().indexOf(name.toLowerCase()) != -1)) {
                                        /* add */(encryptedMessage.push(this.toEntity(currentHash, resourceMessage))>0);
                                    }
                                }
                            } catch(e) {
                                continue;
                            };
                        }
                    }
                }
            }
            if(!/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(currentHash,""))) {
                /* addAll */((l1, l2) => l1.push.apply(l1, l2))(encryptedMessage, this.getNextForNameSearch(xPvKey, xPubkey, name, currentHash));
            }
            return encryptedMessage;
        }

        /**
         * Gets the next for keyword search.
         * 
         * @param {string} xPvKey the x pv key
         * @param {string} xPubkey the x pubkey
         * @param {string} keywords the keywords
         * @param {string} hash the hash
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]} the next for keyword search
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         * @private
         */
        /*private*/ getNextForKeywordSearch(xPvKey : string, xPubkey : string, keywords : string, hash : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            let pvKey : org.nem.core.crypto.PrivateKey = org.nem.core.crypto.PrivateKey.fromHexString(xPvKey);
            let keyPair : org.nem.core.crypto.KeyPair = new org.nem.core.crypto.KeyPair(pvKey);
            let privateKeyAddress : string = org.nem.core.model.Address.fromPublicKey(keyPair.getPublicKey()).toString();
            let listOfTransactionMetadataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = null;
            if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(hash,""))) {
                listOfTransactionMetadataPair = this.nemTransactionApi.getAllTransactions$java_lang_String(privateKeyAddress);
            } else {
                listOfTransactionMetadataPair = this.nemTransactionApi.getAllTransactions$java_lang_String$java_lang_String(privateKeyAddress, hash);
            }
            let encryptedMessage : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> = <any>([]);
            let currentHash : string = "";
            for(let index161=0; index161 < listOfTransactionMetadataPair.length; index161++) {
                let tmp = listOfTransactionMetadataPair[index161];
                {
                    if(tmp.getEntity() != null && tmp.getEntity() instanceof <any>org.nem.core.model.TransferTransaction) {
                        currentHash = tmp.getMetaData().getHash().toString();
                        let transferTransaction : org.nem.core.model.TransferTransaction = <org.nem.core.model.TransferTransaction>tmp.getEntity();
                        if(this.checkIfTxnHaveXPXMosaic(transferTransaction)) {
                            let found : boolean = false;
                            try {
                                if(transferTransaction.getMessage().getType() === 1) {
                                    let resourceMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage = io.nem.xpx.service.model.buffers.ResourceHashMessage.getRootAsResourceHashMessage$java_nio_ByteBuffer(java.nio.ByteBuffer.wrap(org.apache.commons.codec.binary.Base64.decodeBase64(transferTransaction.getMessage().getDecodedPayload())));
                                    let commaSeparatedkeywordsSplit : string[] = keywords.split(",");
                                    for(let index162=0; index162 < commaSeparatedkeywordsSplit.length; index162++) {
                                        let keyword = commaSeparatedkeywordsSplit[index162];
                                        {
                                            if(/* contains */(resourceMessage.keywords().indexOf(keyword) != -1)) {
                                                found = true;
                                                break;
                                            }
                                        }
                                    }
                                    if(found) {
                                        /* add */(encryptedMessage.push(this.toEntity(currentHash, resourceMessage))>0);
                                    }
                                } else if(transferTransaction.getMessage().getType() === 2) {
                                    let secureMessage : org.nem.core.messages.SecureMessage = null;
                                    if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(transferTransaction.getSigner().getAddress().getEncoded(),privateKeyAddress))) {
                                        secureMessage = org.nem.core.messages.SecureMessage.fromEncodedPayload(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PrivateKey.fromHexString(xPvKey))), new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PublicKey.fromHexString(xPubkey))), transferTransaction.getMessage().getEncodedPayload());
                                    } else if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(transferTransaction.getRecipient().getAddress().getEncoded(),privateKeyAddress))) {
                                        secureMessage = org.nem.core.messages.SecureMessage.fromEncodedPayload(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PublicKey.fromHexString(xPubkey))), new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PrivateKey.fromHexString(xPvKey))), transferTransaction.getMessage().getEncodedPayload());
                                    }
                                    let resourceMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage = io.nem.xpx.service.model.buffers.ResourceHashMessage.getRootAsResourceHashMessage$java_nio_ByteBuffer(java.nio.ByteBuffer.wrap(org.apache.commons.codec.binary.Base64.decodeBase64(secureMessage.getDecodedPayload())));
                                    let commaSeparatedkeywordsSplit : string[] = keywords.split(",");
                                    for(let index163=0; index163 < commaSeparatedkeywordsSplit.length; index163++) {
                                        let keyword = commaSeparatedkeywordsSplit[index163];
                                        {
                                            if(/* contains */(resourceMessage.keywords().indexOf(keyword) != -1)) {
                                                found = true;
                                                break;
                                            }
                                        }
                                    }
                                    if(found) {
                                        /* add */(encryptedMessage.push(this.toEntity(currentHash, resourceMessage))>0);
                                    }
                                }
                            } catch(e) {
                                continue;
                            };
                        }
                    }
                }
            }
            if(!/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(currentHash,""))) {
                /* addAll */((l1, l2) => l1.push.apply(l1, l2))(encryptedMessage, this.getNextForKeywordSearch(xPvKey, xPubkey, keywords, currentHash));
            }
            return encryptedMessage;
        }

        /**
         * Gets the next for metadata search.
         * 
         * @param {string} xPvKey the x pv key
         * @param {string} xPubkey the x pubkey
         * @param {string} key the key
         * @param {string} value the value
         * @param {string} hash the hash
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]} the next for metadata search
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         * @private
         */
        /*private*/ getNextForMetadataSearch(xPvKey : string, xPubkey : string, key : string, value : string, hash : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            let pvKey : org.nem.core.crypto.PrivateKey = org.nem.core.crypto.PrivateKey.fromHexString(xPvKey);
            let keyPair : org.nem.core.crypto.KeyPair = new org.nem.core.crypto.KeyPair(pvKey);
            let privateKeyAddress : string = org.nem.core.model.Address.fromPublicKey(keyPair.getPublicKey()).toString();
            let listOfTransactionMetadataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = null;
            if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(hash,""))) {
                listOfTransactionMetadataPair = this.nemTransactionApi.getAllTransactions$java_lang_String(privateKeyAddress);
            } else {
                listOfTransactionMetadataPair = this.nemTransactionApi.getAllTransactions$java_lang_String$java_lang_String(privateKeyAddress, hash);
            }
            let encryptedMessage : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> = <any>([]);
            let currentHash : string = "";
            for(let index164=0; index164 < listOfTransactionMetadataPair.length; index164++) {
                let tmp = listOfTransactionMetadataPair[index164];
                {
                    if(tmp.getEntity() != null && tmp.getEntity() instanceof <any>org.nem.core.model.TransferTransaction) {
                        currentHash = tmp.getMetaData().getHash().toString();
                        let transferTransaction : org.nem.core.model.TransferTransaction = <org.nem.core.model.TransferTransaction>tmp.getEntity();
                        if(this.checkIfTxnHaveXPXMosaic(transferTransaction)) {
                            let found : boolean = false;
                            try {
                                if(transferTransaction.getMessage().getType() === 1) {
                                    let resourceMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage = io.nem.xpx.service.model.buffers.ResourceHashMessage.getRootAsResourceHashMessage$java_nio_ByteBuffer(java.nio.ByteBuffer.wrap(org.apache.commons.codec.binary.Base64.decodeBase64(transferTransaction.getMessage().getDecodedPayload())));
                                    if(resourceMessage.metaData() != null) {
                                        let jsonToMap : any = <any>(io.nem.xpx.utils.JsonUtils.fromJson<any>(resourceMessage.metaData(), "java.util.Map"));
                                        if(/* containsKey */jsonToMap.hasOwnProperty(key) && /* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(/* get */((m,k) => m[k]===undefined?null:m[k])(jsonToMap, key),value))) {
                                            /* add */(encryptedMessage.push(this.toEntity(currentHash, resourceMessage))>0);
                                        }
                                    }
                                } else if(transferTransaction.getMessage().getType() === 2) {
                                    let secureMessage : org.nem.core.messages.SecureMessage = null;
                                    if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(transferTransaction.getSigner().getAddress().getEncoded(),privateKeyAddress))) {
                                        secureMessage = org.nem.core.messages.SecureMessage.fromEncodedPayload(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PrivateKey.fromHexString(xPvKey))), new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PublicKey.fromHexString(xPubkey))), transferTransaction.getMessage().getEncodedPayload());
                                    } else if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(transferTransaction.getRecipient().getAddress().getEncoded(),privateKeyAddress))) {
                                        secureMessage = org.nem.core.messages.SecureMessage.fromEncodedPayload(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PublicKey.fromHexString(xPubkey))), new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PrivateKey.fromHexString(xPvKey))), transferTransaction.getMessage().getEncodedPayload());
                                    }
                                    let resourceMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage = io.nem.xpx.service.model.buffers.ResourceHashMessage.getRootAsResourceHashMessage$java_nio_ByteBuffer(java.nio.ByteBuffer.wrap(org.apache.commons.codec.binary.Base64.decodeBase64(secureMessage.getDecodedPayload())));
                                    if(resourceMessage.metaData() != null) {
                                        let jsonToMap : any = <any>(io.nem.xpx.utils.JsonUtils.fromJson<any>(resourceMessage.metaData(), "java.util.Map"));
                                        if(/* containsKey */jsonToMap.hasOwnProperty(key) && /* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(/* get */((m,k) => m[k]===undefined?null:m[k])(jsonToMap, key),value))) {
                                            /* add */(encryptedMessage.push(this.toEntity(currentHash, resourceMessage))>0);
                                        }
                                    }
                                }
                            } catch(e) {
                                continue;
                            };
                        }
                    }
                }
            }
            if(!/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(currentHash,""))) {
                /* addAll */((l1, l2) => l1.push.apply(l1, l2))(encryptedMessage, this.getNextForMetadataSearch(xPvKey, xPubkey, key, value, currentHash));
            }
            return encryptedMessage;
        }

        /**
         * To entity.
         * 
         * @param {string} nemHash the nem hash
         * @param {io.nem.xpx.service.model.buffers.ResourceHashMessage} resourceMessage            the resource message
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity} the resource hash message json entity
         */
        toEntity(nemHash : string, resourceMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage) : io.nem.xpx.model.ResourceHashMessageJsonEntity {
            let resourceHashMessageJsonEntity : io.nem.xpx.model.ResourceHashMessageJsonEntity = new io.nem.xpx.model.ResourceHashMessageJsonEntity();
            resourceHashMessageJsonEntity.setDigest(resourceMessage.digest());
            resourceHashMessageJsonEntity.setHash(resourceMessage.hash());
            resourceHashMessageJsonEntity.setKeywords(resourceMessage.keywords());
            resourceHashMessageJsonEntity.setMetaData(resourceMessage.metaData());
            resourceHashMessageJsonEntity.setName(resourceMessage.name());
            resourceHashMessageJsonEntity.setTimestamp(resourceMessage.timestamp());
            resourceHashMessageJsonEntity.setType(resourceMessage.type());
            resourceHashMessageJsonEntity.setNemHash(nemHash);
            return resourceHashMessageJsonEntity;
        }

        /**
         * Check if txn have XPX mosaic.
         * 
         * @param {org.nem.core.model.Transaction} transaction
         * the transaction
         * @return {boolean} true, if successful
         */
        checkIfTxnHaveXPXMosaic(transaction : org.nem.core.model.Transaction) : boolean {
            if(transaction != null && transaction instanceof <any>org.nem.core.model.TransferTransaction) {
                let mosaicIter : any = /* iterator */((a) => { var i = 0; return { next: function() { return i<a.length?a[i++]:null; }, hasNext: function() { return i<a.length; }}})((<org.nem.core.model.TransferTransaction>transaction).getMosaics());
                while((mosaicIter.hasNext())) {
                    let mosaic : org.nem.core.model.mosaic.Mosaic = mosaicIter.next();
                    if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(mosaic.getMosaicId().getNamespaceId().getRoot().toString(),"prx")) && /* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(mosaic.getMosaicId().getName(),"xpx"))) {
                        return true;
                    }
                };
            }
            return false;
        }
    }
    PrivateSearchApi["__class"] = "io.nem.xpx.service.common.PrivateSearchApi";

}
namespace io.nem.xpx.service {
    export class HttpClient {
        public constructor() {
        }

        public head(url : java.net.URL) {
            let conn : java.net.HttpURLConnection = null;
            try {
                conn = <java.net.HttpURLConnection>url.openConnection();
                conn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
                conn.setRequestMethod("HEAD");
                conn.setDoOutput(true);
                conn.setUseCaches(false);
                let wr : java.io.DataOutputStream = new java.io.DataOutputStream(conn.getOutputStream());
                wr.close();
            } catch(e) {
                throw e;
            } finally {
                if(conn != null) conn.disconnect();;
            };
        }
    }
    HttpClient["__class"] = "io.nem.xpx.service.HttpClient";

}
namespace io.nem.xpx.service.intf {
    /**
     * The Interface AccountApi.
     * @class
     */
    export interface AccountApi {
        /**
         * Gets the all incoming nem address transactions using GET.
         * 
         * @param {string} publicKey the public key
         * @return {string} the all incoming nem address transactions using GET
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        getAllIncomingNemAddressTransactionsUsingGET(publicKey : string) : string;

        /**
         * Gets the all nem address transactions using GET.
         * 
         * @param {string} publicKey the public key
         * @return {string} the all nem address transactions using GET
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        getAllNemAddressTransactionsUsingGET(publicKey : string) : string;

        /**
         * Gets the all nem address transactions with page size using GET.
         * 
         * @param {string} publicKey the public key
         * @param {string} pageSize the page size
         * @return {string} the all nem address transactions with page size using GET
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        getAllNemAddressTransactionsWithPageSizeUsingGET(publicKey : string, pageSize : string) : string;

        /**
         * Gets the all outgoing nem address transactions using GET.
         * 
         * @param {string} publicKey the public key
         * @return {string} the all outgoing nem address transactions using GET
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        getAllOutgoingNemAddressTransactionsUsingGET(publicKey : string) : string;

        /**
         * Gets the all unconfirmed nem address transactions using GET.
         * 
         * @param {string} publicKey the public key
         * @return {string} the all unconfirmed nem address transactions using GET
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        getAllUnconfirmedNemAddressTransactionsUsingGET(publicKey : string) : string;

        /**
         * Gets the nem address details using GET.
         * 
         * @param {string} publicKey the public key
         * @return {io.nem.xpx.model.AccountMetaDataPair} the nem address details using GET
         * @throws ApiException the api exception
         */
        getNemAddressDetailsUsingGET(publicKey : string) : io.nem.xpx.model.AccountMetaDataPair;
    }
}
namespace io.nem.xpx.service.intf {
    /**
     * The Interface DataHashApiInterface.
     * @class
     */
    export interface DataHashApi {
        /**
         * Generate hash and expose data to network using POST.
         * 
         * @param {Array} data the data
         * @return {string} the binary transaction encrypted message
         * @throws ApiException the api exception
         * @throws IOException Signals that an I/O exception has occurred.
         * @throws NoSuchAlgorithmException the no such algorithm exception
         */
        generateHashForDataOnlyUsingPOST(data : number[]) : string;
    }
}
namespace io.nem.xpx.service.intf {
    /**
     * The Interface DirectoryLoadApi.
     * @class
     */
    export interface DirectoryLoadApi {
        /**
         * Load directory using GET.
         * 
         * @param {string} nemHash the nem hash
         * @return {*} the object
         * @throws ApiException the api exception
         */
        loadDirectoryUsingGET(nemHash : string) : any;
    }
}
namespace io.nem.xpx.service.intf {
    /**
     * The Interface DownloadApi.
     * @class
     */
    export interface DownloadApi {
        /**
         * Download stream using hash using POST.
         * 
         * @param {string} hash the hash
         * @return {Array} the byte[]
         * @throws ApiException the api exception
         * @throws IOException Signals that an I/O exception has occurred.
         */
        downloadUsingDataHashUsingGET(hash : string) : number[];

        /**
         * Download binary using GET.
         * 
         * @param {string} nemHash the nem hash
         * @param {string} transferMode the transfer mode
         * @return {Array} the byte[]
         * @throws ApiException the api exception
         * @throws IOException Signals that an I/O exception has occurred.
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        downloadBinaryUsingGET(nemHash : string, transferMode : string) : number[];

        /**
         * Download file using GET.
         * 
         * @param {string} nemHash the nem hash
         * @param {string} transferMode the transfer mode
         * @return {Array} the byte[]
         * @throws ApiException the api exception
         * @throws IOException Signals that an I/O exception has occurred.
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        downloadFileUsingGET(nemHash : string, transferMode : string) : number[];

        /**
         * Download text using GET.
         * 
         * @param {string} nemHash the nem hash
         * @param {string} transferMode the transfer mode
         * @return {Array} the byte[]
         * @throws ApiException the api exception
         * @throws IOException Signals that an I/O exception has occurred.
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        downloadTextUsingGET(nemHash : string, transferMode : string) : number[];
    }
}
namespace io.nem.xpx.service.intf {
    /**
     * The Interface NodeApi.
     * @class
     */
    export interface NodeApi {
        /**
         * Gets the node info peers using GET.
         * 
         * @return {io.nem.xpx.model.NodeInfo} the node info peers using GET
         * @throws ApiException the api exception
         */
        getNodeInfoPeersUsingGET() : io.nem.xpx.model.NodeInfo;

        /**
         * Gets the node info using GET.
         * 
         * @return {io.nem.xpx.model.NodeInfo} the node info using GET
         * @throws ApiException the api exception
         */
        getNodeInfoUsingGET() : io.nem.xpx.model.NodeInfo;
    }
}
namespace io.nem.xpx.service.intf {
    /**
     * The Interface PublishAndSubscribeApi.
     * @class
     */
    export interface PublishAndSubscribeApi {
        /**
         * Send to topic using GET.
         * 
         * @param {string} topic the topic
         * @param {string} message the message
         * @return {*} the object
         * @throws Exception the exception
         */
        sendToTopicUsingGET(topic : string, message : string) : any;

        /**
         * Publish topic using GET.
         * 
         * @param {string} topic the topic
         * @param {string} message the message
         * @return {*} the object
         * @throws Exception the exception
         */
        publishTopicUsingGET(topic : string, message : string) : any;
    }
}
namespace io.nem.xpx.service.intf {
    /**
     * The Interface SearchApi.
     * @class
     */
    export interface SearchApi {
        /**
         * Search transaction with keyword using GET.
         * 
         * @param {string} xPvKey the x pv key
         * @param {string} xPubkey the x pubkey
         * @param {string} keywords the keywords
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]} the list
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        searchTransactionWithKeywordUsingGET(xPvKey? : any, xPubkey? : any, keywords? : any) : any;

        /**
         * Search transaction with name using GET.
         * 
         * @param {string} xPvKey the x pv key
         * @param {string} xPubkey the x pubkey
         * @param {string} name the name
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]} the list
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        searchTransactionWithNameUsingGET(xPvKey : string, xPubkey : string, name : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>;

        /**
         * Search all public transaction with metadata key value pair.
         * 
         * @param {string} xPubkey the x pubkey
         * @param {string} key the key
         * @param {string} value the value
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]} the list
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        searchTransactionWithMetadataUsingGET(xPubkey : string, key : string, value : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>;

        /**
         * Search transaction with metadata key value pair.
         * 
         * @param {string} xPvKey the x pv key
         * @param {string} xPubkey the x pubkey
         * @param {string} key the key
         * @param {string} value the value
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]} the list
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        searchTransactionWithMetadataKeyValuePair(xPvKey : string, xPubkey : string, key : string, value : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>;
    }
}
namespace io.nem.xpx.service.intf {
    /**
     * The Interface TransactionAndAnnounceApi.
     * @class
     */
    export interface TransactionAndAnnounceApi {
        /**
         * Announce request publish data signature using POST.
         * 
         * @param {io.nem.xpx.model.RequestAnnounceDataSignature} requestAnnounceDataSignature the request announce data signature
         * @return {string} the string
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        announceRequestPublishDataSignatureUsingPOST(requestAnnounceDataSignature : io.nem.xpx.model.RequestAnnounceDataSignature) : string;

        /**
         * Gets the XPX transaction using GET.
         * 
         * @param {string} nemHash the nem hash
         * @return {string} the XPX transaction using GET
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        getXPXTransactionUsingGET(nemHash : string) : string;
    }
}
namespace io.nem.xpx.service.intf {
    /**
     * The Interface UploadApi.
     * @class
     */
    export interface UploadApi {
        /**
         * Cleanup pinned content using POST.
         * 
         * @param {string} multihash the multihash
         * @return {string} the string
         * @throws ApiException the api exception
         * @throws IOException Signals that an I/O exception has occurred.
         */
        deletePinnedContent(multihash : string) : string;

        /**
         * Upload bytes binary.
         * 
         * @param {Array} binaryData the binary data
         * @param {string} name the name
         * @param {string} contentType the content type
         * @param {string} keywords the keywords
         * @param {string} metadata the metadata
         * @return {Array} the byte[]
         * @throws ApiException the api exception
         * @throws IOException Signals that an I/O exception has occurred.
         * @throws NoSuchAlgorithmException the no such algorithm exception
         */
        uploadBytesBinary(binaryData : number[], name : string, contentType : string, keywords : string, metadata : string) : number[];

        /**
         * Upload text.
         * 
         * @param {Array} textInBytes the text in bytes
         * @param {string} name the name
         * @param {string} contentType the content type
         * @param {string} encoding the encoding
         * @param {string} keywords the keywords
         * @param {string} metadata the metadata
         * @return {Array} the byte[]
         * @throws ApiException the api exception
         * @throws IOException Signals that an I/O exception has occurred.
         * @throws NoSuchAlgorithmException the no such algorithm exception
         */
        uploadText(textInBytes : number[], name : string, contentType : string, encoding : string, keywords : string, metadata : string) : number[];

        /**
         * Upload path.
         * 
         * @param {string} path the path
         * @param {string} name the name
         * @param {string} keywords the keywords
         * @param {string} metadata the metadata
         * @return {Array} the byte[]
         * @throws ApiException the api exception
         * @throws IOException Signals that an I/O exception has occurred.
         * @throws NoSuchAlgorithmException the no such algorithm exception
         */
        uploadPath(path : string, name : string, keywords : string, metadata : string) : number[];
    }
}
namespace io.nem.xpx.service {
    export class IpfsGatewaySyncService {
        /*private*/ syncGateways : Array<string>;

        /*private*/ executor : java.util.concurrent.ExecutorService;

        /*private*/ httpClient : io.nem.xpx.service.HttpClient;

        public constructor(syncGateways? : any, httpClient? : any) {
            if(((syncGateways != null && (syncGateways instanceof Array)) || syncGateways === null) && ((httpClient != null && httpClient instanceof <any>io.nem.xpx.service.HttpClient) || httpClient === null)) {
                let __args = Array.prototype.slice.call(arguments);
                if(this.syncGateways===undefined) this.syncGateways = null;
                if(this.executor===undefined) this.executor = null;
                if(this.httpClient===undefined) this.httpClient = null;
                if(this.syncGateways===undefined) this.syncGateways = null;
                if(this.executor===undefined) this.executor = null;
                if(this.httpClient===undefined) this.httpClient = null;
                (() => {
                    this.syncGateways = syncGateways;
                    this.executor = java.util.concurrent.Executors.newCachedThreadPool();
                    this.httpClient = httpClient;
                })();
            } else if(((syncGateways != null && (syncGateways instanceof Array)) || syncGateways === null) && httpClient === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                {
                    let __args = Array.prototype.slice.call(arguments);
                    let httpClient : any = new io.nem.xpx.service.HttpClient();
                    if(this.syncGateways===undefined) this.syncGateways = null;
                    if(this.executor===undefined) this.executor = null;
                    if(this.httpClient===undefined) this.httpClient = null;
                    if(this.syncGateways===undefined) this.syncGateways = null;
                    if(this.executor===undefined) this.executor = null;
                    if(this.httpClient===undefined) this.httpClient = null;
                    (() => {
                        this.syncGateways = syncGateways;
                        this.executor = java.util.concurrent.Executors.newCachedThreadPool();
                        this.httpClient = httpClient;
                    })();
                }
            } else throw new Error('invalid overload');
        }

        public syncToGatewaysAsynchronously(dataHash : string) {
            if(this.syncGateways == null || /* isEmpty */(this.syncGateways.length == 0)) return;
            this.executor.submit(() => this.syncGateways.forEach((gateway) => {
                try {
                    let gatewayUrl : java.net.URL = new java.net.URL(gateway + "/ipfs/" + dataHash);
                    this.httpClient.head(gatewayUrl);
                } catch(e) {
                    org.pmw.tinylog.Logger.error(java.lang.String.format("Error syncing to gateways %s for hash %s", gateway, dataHash), e);
                };
            }));
        }
    }
    IpfsGatewaySyncService["__class"] = "io.nem.xpx.service.IpfsGatewaySyncService";

}
namespace io.nem.xpx.service.local {
    /**
     * Instantiates a new local account api.
     * 
     * @param {io.nem.xpx.service.NemTransactionApi} nemTransactionApi the nem transaction api
     * @class
     */
    export class LocalAccountApi implements io.nem.xpx.service.intf.AccountApi {
        /**
         * The nem transaction api.
         */
        /*private*/ nemTransactionApi : io.nem.xpx.service.NemTransactionApi;

        public constructor(nemTransactionApi : io.nem.xpx.service.NemTransactionApi) {
            if(this.nemTransactionApi===undefined) this.nemTransactionApi = null;
            this.nemTransactionApi = nemTransactionApi;
        }

        /**
         * 
         * @param {string} publicKey
         * @return {string}
         */
        public getAllIncomingNemAddressTransactionsUsingGET(publicKey : string) : string {
            let listOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = this.nemTransactionApi.getIncomingTransactions$java_lang_String(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(publicKey)).getEncoded());
            let transactionString : Array<string> = <any>([]);
            for(let index165=0; index165 < listOfTxnMetaDataPair.length; index165++) {
                let metaDataPair = listOfTxnMetaDataPair[index165];
                {
                    if(this.checkIfTxnHaveXPXMosaic(metaDataPair.getEntity())) {
                        /* add */(transactionString.push(org.nem.core.serialization.JsonSerializer.serializeToJson(metaDataPair.getEntity()).toJSONString())>0);
                    }
                }
            }
            return io.nem.xpx.utils.JsonUtils.toJson(transactionString);
        }

        /**
         * 
         * @param {string} publicKey
         * @return {string}
         */
        public getAllNemAddressTransactionsUsingGET(publicKey : string) : string {
            let listOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = this.nemTransactionApi.getAllTransactions$java_lang_String(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(publicKey)).getEncoded());
            let transactionString : Array<string> = <any>([]);
            for(let index166=0; index166 < listOfTxnMetaDataPair.length; index166++) {
                let metaDataPair = listOfTxnMetaDataPair[index166];
                {
                    if(this.checkIfTxnHaveXPXMosaic(metaDataPair.getEntity())) {
                        /* add */(transactionString.push(org.nem.core.serialization.JsonSerializer.serializeToJson(metaDataPair.getEntity()).toJSONString())>0);
                    }
                }
            }
            return io.nem.xpx.utils.JsonUtils.toJson(transactionString);
        }

        /**
         * 
         * @param {string} publicKey
         * @param {string} pageSize
         * @return {string}
         */
        public getAllNemAddressTransactionsWithPageSizeUsingGET(publicKey : string, pageSize : string) : string {
            let listOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = this.nemTransactionApi.getAllTransactionsWithPageSize(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(publicKey)).getEncoded(), pageSize);
            let transactionString : Array<string> = <any>([]);
            for(let index167=0; index167 < listOfTxnMetaDataPair.length; index167++) {
                let metaDataPair = listOfTxnMetaDataPair[index167];
                {
                    if(this.checkIfTxnHaveXPXMosaic(metaDataPair.getEntity())) {
                        /* add */(transactionString.push(org.nem.core.serialization.JsonSerializer.serializeToJson(metaDataPair.getEntity()).toJSONString())>0);
                    }
                }
            }
            return io.nem.xpx.utils.JsonUtils.toJson(transactionString);
        }

        /**
         * 
         * @param {string} publicKey
         * @return {string}
         */
        public getAllOutgoingNemAddressTransactionsUsingGET(publicKey : string) : string {
            let listOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = this.nemTransactionApi.getOutgoingTransactions$java_lang_String(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(publicKey)).getEncoded());
            let transactionString : Array<string> = <any>([]);
            for(let index168=0; index168 < listOfTxnMetaDataPair.length; index168++) {
                let metaDataPair = listOfTxnMetaDataPair[index168];
                {
                    if(this.checkIfTxnHaveXPXMosaic(metaDataPair.getEntity())) {
                        /* add */(transactionString.push(org.nem.core.serialization.JsonSerializer.serializeToJson(metaDataPair.getEntity()).toJSONString())>0);
                    }
                }
            }
            return io.nem.xpx.utils.JsonUtils.toJson(transactionString);
        }

        /**
         * 
         * @param {string} publicKey
         * @return {string}
         */
        public getAllUnconfirmedNemAddressTransactionsUsingGET(publicKey : string) : string {
            let listOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = this.nemTransactionApi.getUnconfirmedTransactions(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(publicKey)).getEncoded());
            let transactionString : Array<string> = <any>([]);
            for(let index169=0; index169 < listOfTxnMetaDataPair.length; index169++) {
                let metaDataPair = listOfTxnMetaDataPair[index169];
                {
                    /* add */(transactionString.push(org.nem.core.serialization.JsonSerializer.serializeToJson(metaDataPair.getEntity()).toJSONString())>0);
                }
            }
            return io.nem.xpx.utils.JsonUtils.toJson(transactionString);
        }

        /**
         * 
         * @param {string} publicKey
         * @return {io.nem.xpx.model.AccountMetaDataPair}
         */
        public getNemAddressDetailsUsingGET(publicKey : string) : io.nem.xpx.model.AccountMetaDataPair {
            return null;
        }

        /**
         * Check if txn have XPX mosaic.
         * 
         * @param {org.nem.core.model.Transaction} transaction the transaction
         * @return {boolean} true, if successful
         */
        checkIfTxnHaveXPXMosaic(transaction : org.nem.core.model.Transaction) : boolean {
            if(transaction != null && transaction instanceof <any>org.nem.core.model.TransferTransaction) {
                let mosaicIter : any = /* iterator */((a) => { var i = 0; return { next: function() { return i<a.length?a[i++]:null; }, hasNext: function() { return i<a.length; }}})((<org.nem.core.model.TransferTransaction>transaction).getMosaics());
                while((mosaicIter.hasNext())) {
                    let mosaic : org.nem.core.model.mosaic.Mosaic = mosaicIter.next();
                    if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(mosaic.getMosaicId().getNamespaceId().getRoot().toString(),"prx")) && /* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(mosaic.getMosaicId().getName(),"xpx"))) {
                        return true;
                    }
                };
            }
            return false;
        }
    }
    LocalAccountApi["__class"] = "io.nem.xpx.service.local.LocalAccountApi";
    LocalAccountApi["__interfaces"] = ["io.nem.xpx.service.intf.AccountApi"];


}
namespace io.nem.xpx.service.local {
    /**
     * Instantiates a new local data hash api.
     * 
     * @param {io.ipfs.api.IPFS} proximaxIfpsConnection the proximax ifps connection
     * @class
     */
    export class LocalDataHashApi implements io.nem.xpx.service.intf.DataHashApi {
        /**
         * The proximax ifps connection.
         */
        /*private*/ proximaxIfpsConnection : io.ipfs.api.IPFS;

        public constructor(proximaxIfpsConnection : io.ipfs.api.IPFS) {
            if(this.proximaxIfpsConnection===undefined) this.proximaxIfpsConnection = null;
            this.proximaxIfpsConnection = proximaxIfpsConnection;
        }

        /**
         * 
         * @param {Array} data
         * @return {string}
         */
        public generateHashForDataOnlyUsingPOST(data : number[]) : string {
            let dataHashByteArrayEntity : io.nem.xpx.model.DataHashByteArrayEntity = new io.nem.xpx.model.DataHashByteArrayEntity();
            dataHashByteArrayEntity.setFile(data);
            dataHashByteArrayEntity.setName(Math.abs(/* currentTimeMillis */Date.now()) + "");
            let spfsBlockResult : io.nem.xpx.model.PublishResult = this.getBinaryHashOnly(dataHashByteArrayEntity.getName(), dataHashByteArrayEntity.getFile());
            let multiHashString : string = /* get */spfsBlockResult.getMerkleNode()[0].hash.toBase58();
            return multiHashString;
        }

        /**
         * Gets the binary hash only.
         * 
         * @param {string} name the name
         * @param {Array} binary the binary
         * @return {io.nem.xpx.model.PublishResult} the binary hash only
         * @throws IOException Signals that an I/O exception has occurred.
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ getBinaryHashOnly(name : string, binary : number[]) : io.nem.xpx.model.PublishResult {
            let result : io.nem.xpx.model.PublishResult = null;
            result = new io.nem.xpx.model.PublishResult();
            let byteArrayWrapper : io.ipfs.api.NamedStreamable.ByteArrayWrapper = new io.ipfs.api.NamedStreamable.ByteArrayWrapper(name, binary);
            let node : Array<io.ipfs.api.MerkleNode> = this.proximaxIfpsConnection.add(byteArrayWrapper, false, true);
            result.setMerkleNode(node);
            return result;
        }
    }
    LocalDataHashApi["__class"] = "io.nem.xpx.service.local.LocalDataHashApi";
    LocalDataHashApi["__interfaces"] = ["io.nem.xpx.service.intf.DataHashApi"];


}
namespace io.nem.xpx.service.local {
    /**
     * Instantiates a new local download api.
     * 
     * @param {io.nem.xpx.service.NemTransactionApi} nemTransactionApi the nem transaction api
     * @param {io.ipfs.api.IPFS} proximaxIfpsConnection the proximax ifps connection
     * @class
     */
    export class LocalDownloadApi implements io.nem.xpx.service.intf.DownloadApi {
        /**
         * The nem transaction api.
         */
        /*private*/ nemTransactionApi : io.nem.xpx.service.NemTransactionApi;

        /**
         * The proximax ifps connection.
         */
        /*private*/ proximaxIfpsConnection : io.ipfs.api.IPFS;

        public constructor(nemTransactionApi : io.nem.xpx.service.NemTransactionApi, proximaxIfpsConnection : io.ipfs.api.IPFS) {
            if(this.nemTransactionApi===undefined) this.nemTransactionApi = null;
            if(this.proximaxIfpsConnection===undefined) this.proximaxIfpsConnection = null;
            this.nemTransactionApi = nemTransactionApi;
            this.proximaxIfpsConnection = proximaxIfpsConnection;
        }

        /**
         * 
         * @param {string} hash
         * @return {Array}
         */
        public downloadUsingDataHashUsingGET(hash : string) : number[] {
            return this.proximaxIfpsConnection.cat(io.ipfs.multihash.Multihash.fromBase58(hash));
        }

        /**
         * 
         * @param {string} nemHash
         * @param {string} transferMode
         * @return {Array}
         */
        public downloadTextUsingGET(nemHash : string, transferMode : string) : number[] {
            let transactionMetaDataPair : org.nem.core.model.ncc.TransactionMetaDataPair = this.nemTransactionApi.getTransaction(nemHash);
            let transfer : org.nem.core.model.TransferTransaction = (<org.nem.core.model.TransferTransaction>transactionMetaDataPair.getEntity());
            let resourceMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage = io.nem.xpx.service.model.buffers.ResourceHashMessage.getRootAsResourceHashMessage$java_nio_ByteBuffer(java.nio.ByteBuffer.wrap(org.apache.commons.codec.binary.Base64.decodeBase64(transfer.getMessage().getEncodedPayload())));
            return this.proximaxIfpsConnection.cat(io.ipfs.multihash.Multihash.fromBase58(resourceMessage.hash()));
        }

        /**
         * 
         * @param {string} nemHash
         * @param {string} transferMode
         * @return {Array}
         */
        public downloadBinaryUsingGET(nemHash : string, transferMode : string) : number[] {
            let transactionMetaDataPair : org.nem.core.model.ncc.TransactionMetaDataPair = this.nemTransactionApi.getTransaction(nemHash);
            let transfer : org.nem.core.model.TransferTransaction = (<org.nem.core.model.TransferTransaction>transactionMetaDataPair.getEntity());
            let resourceMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage = io.nem.xpx.service.model.buffers.ResourceHashMessage.getRootAsResourceHashMessage$java_nio_ByteBuffer(java.nio.ByteBuffer.wrap(org.apache.commons.codec.binary.Base64.decodeBase64(transfer.getMessage().getEncodedPayload())));
            return this.proximaxIfpsConnection.cat(io.ipfs.multihash.Multihash.fromBase58(resourceMessage.hash()));
        }

        /**
         * 
         * @param {string} nemHash
         * @param {string} transferMode
         * @return {Array}
         */
        public downloadFileUsingGET(nemHash : string, transferMode : string) : number[] {
            let transactionMetaDataPair : org.nem.core.model.ncc.TransactionMetaDataPair = this.nemTransactionApi.getTransaction(nemHash);
            let transfer : org.nem.core.model.TransferTransaction = (<org.nem.core.model.TransferTransaction>transactionMetaDataPair.getEntity());
            let resourceMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage = io.nem.xpx.service.model.buffers.ResourceHashMessage.getRootAsResourceHashMessage$java_nio_ByteBuffer(java.nio.ByteBuffer.wrap(org.apache.commons.codec.binary.Base64.decodeBase64(transfer.getMessage().getEncodedPayload())));
            return this.proximaxIfpsConnection.cat(io.ipfs.multihash.Multihash.fromBase58(resourceMessage.hash()));
        }

        /**
         * Load resource.
         * 
         * @param {io.nem.xpx.service.model.buffers.ResourceHashMessage} resourceMessage the resource message
         * @return {Array} the byte[]
         * @throws IOException Signals that an I/O exception has occurred.
         * @throws ApiException the api exception
         */
        public loadResource(resourceMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage) : number[] {
            return this.proximaxIfpsConnection.cat(io.ipfs.multihash.Multihash.fromBase58(resourceMessage.hash()));
        }

        /**
         * Validate digest.
         * 
         * @param {Array} binaryData the binary data
         * @param {string} digest the digest
         * @throws NoSuchAlgorithmException the no such algorithm exception
         * @throws MessageDigestNotMatchException the message digest not match exception
         * @private
         */
        /*private*/ validateDigest(binaryData : number[], digest : string) {
            let messageDigest : java.security.MessageDigest = java.security.MessageDigest.getInstance("SHA-256");
            let binaryDigest : string = String.fromCharCode.apply(null, org.bouncycastle.util.encoders.Hex.encode(messageDigest.digest(binaryData)));
            if(!/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(binaryDigest,digest))) {
                throw new io.nem.xpx.exceptions.MessageDigestNotMatchException("Message Digest Validation Failed. Resource requested seems to be corrupted.");
            }
        }
    }
    LocalDownloadApi["__class"] = "io.nem.xpx.service.local.LocalDownloadApi";
    LocalDownloadApi["__interfaces"] = ["io.nem.xpx.service.intf.DownloadApi"];


}
namespace io.nem.xpx.service.local {
    /**
     * Instantiates a new local fuse download api.
     * 
     * @param {io.ipfs.api.IPFS} proximaxIfpsConnection the proximax ifps connection
     * @class
     */
    export class LocalFuseDownloadApi implements io.nem.xpx.service.intf.DownloadApi {
        /**
         * The proximax ifps connection.
         */
        /*private*/ proximaxIfpsConnection : io.ipfs.api.IPFS;

        public constructor(proximaxIfpsConnection : io.ipfs.api.IPFS) {
            if(this.proximaxIfpsConnection===undefined) this.proximaxIfpsConnection = null;
            this.proximaxIfpsConnection = proximaxIfpsConnection;
        }

        /**
         * 
         * @param {string} hash
         * @return {Array}
         */
        public downloadUsingDataHashUsingGET(hash : string) : number[] {
            return this.proximaxIfpsConnection.cat(io.ipfs.multihash.Multihash.fromBase58(hash));
        }

        /**
         * 
         * @param {string} nemHash
         * @param {string} transferMode
         * @return {Array}
         */
        public downloadBinaryUsingGET(nemHash : string, transferMode : string) : number[] {
            return null;
        }

        /**
         * 
         * @param {string} nemHash
         * @param {string} transferMode
         * @return {Array}
         */
        public downloadFileUsingGET(nemHash : string, transferMode : string) : number[] {
            return null;
        }

        /**
         * 
         * @param {string} nemHash
         * @param {string} transferMode
         * @return {Array}
         */
        public downloadTextUsingGET(nemHash : string, transferMode : string) : number[] {
            return null;
        }
    }
    LocalFuseDownloadApi["__class"] = "io.nem.xpx.service.local.LocalFuseDownloadApi";
    LocalFuseDownloadApi["__interfaces"] = ["io.nem.xpx.service.intf.DownloadApi"];


}
namespace io.nem.xpx.service.local {
    /**
     * Instantiates a new local node api.
     * 
     * @param {io.ipfs.api.IPFS} proximaxIfpsConnection the proximax ifps connection
     * @class
     */
    export class LocalNodeApi implements io.nem.xpx.service.intf.NodeApi {
        /**
         * The proximax ifps connection.
         */
        /*private*/ proximaxIfpsConnection : io.ipfs.api.IPFS;

        public constructor(proximaxIfpsConnection : io.ipfs.api.IPFS) {
            if(this.proximaxIfpsConnection===undefined) this.proximaxIfpsConnection = null;
            this.proximaxIfpsConnection = proximaxIfpsConnection;
        }

        /**
         * 
         * @return {io.nem.xpx.model.NodeInfo}
         */
        public getNodeInfoPeersUsingGET() : io.nem.xpx.model.NodeInfo {
            throw new io.nem.xpx.exceptions.ApiException("Method can\'t be accessed thru local connection");
        }

        /**
         * 
         * @return {io.nem.xpx.model.NodeInfo}
         */
        public getNodeInfoUsingGET() : io.nem.xpx.model.NodeInfo {
            throw new io.nem.xpx.exceptions.ApiException("Method can\'t be accessed thru local connection");
        }
    }
    LocalNodeApi["__class"] = "io.nem.xpx.service.local.LocalNodeApi";
    LocalNodeApi["__interfaces"] = ["io.nem.xpx.service.intf.NodeApi"];


}
namespace io.nem.xpx.service.local {
    /**
     * Instantiates a new local publish and subscribe api.
     * 
     * @param {io.ipfs.api.IPFS} proximaxIfpsConnection the proximax ifps connection
     * @class
     */
    export class LocalPublishAndSubscribeApi implements io.nem.xpx.service.intf.PublishAndSubscribeApi {
        /**
         * The proximax ifps connection.
         */
        /*private*/ proximaxIfpsConnection : io.ipfs.api.IPFS;

        public constructor(proximaxIfpsConnection : io.ipfs.api.IPFS) {
            if(this.proximaxIfpsConnection===undefined) this.proximaxIfpsConnection = null;
            this.proximaxIfpsConnection = proximaxIfpsConnection;
        }

        /**
         * 
         * @param {string} topic
         * @param {string} message
         * @return {*}
         */
        public sendToTopicUsingGET(topic : string, message : string) : any {
            return this.proximaxIfpsConnection.pubsub.pub(topic, message);
        }

        /**
         * 
         * @param {string} topic
         * @param {string} message
         * @return {*}
         */
        public publishTopicUsingGET(topic : string, message : string) : any {
            return this.proximaxIfpsConnection.pubsub.pub(topic, message);
        }
    }
    LocalPublishAndSubscribeApi["__class"] = "io.nem.xpx.service.local.LocalPublishAndSubscribeApi";
    LocalPublishAndSubscribeApi["__interfaces"] = ["io.nem.xpx.service.intf.PublishAndSubscribeApi"];


}
namespace io.nem.xpx.service.local {
    /**
     * Instantiates a new local transaction and announce api.
     * 
     * @param {io.nem.xpx.service.NemTransactionApi} nemTransactionApi the nem transaction api
     * @class
     */
    export class LocalTransactionAndAnnounceApi implements io.nem.xpx.service.intf.TransactionAndAnnounceApi {
        /**
         * The nem transaction api.
         */
        /*private*/ nemTransactionApi : io.nem.xpx.service.NemTransactionApi;

        public constructor(nemTransactionApi : io.nem.xpx.service.NemTransactionApi) {
            if(this.nemTransactionApi===undefined) this.nemTransactionApi = null;
            this.nemTransactionApi = nemTransactionApi;
        }

        /**
         * 
         * @param {io.nem.xpx.model.RequestAnnounceDataSignature} requestAnnounceDataSignature
         * @return {string}
         */
        public announceRequestPublishDataSignatureUsingPOST(requestAnnounceDataSignature : io.nem.xpx.model.RequestAnnounceDataSignature) : string {
            let announceResult : org.nem.core.model.ncc.NemAnnounceResult = this.nemTransactionApi.sendTransferTransaction(org.nem.core.utils.HexEncoder.getBytes(requestAnnounceDataSignature.getData()), org.nem.core.utils.HexEncoder.getBytes(requestAnnounceDataSignature.getSignature()));
            let transactionMpair : org.nem.core.model.ncc.TransactionMetaDataPair = this.nemTransactionApi.getTransaction(announceResult.getTransactionHash().toString());
            let transferTransaction : org.nem.core.model.TransferTransaction = (<org.nem.core.model.TransferTransaction>transactionMpair.getEntity());
            return org.nem.core.serialization.JsonSerializer.serializeToJson(transferTransaction).toJSONString();
        }

        /**
         * 
         * @param {string} nemHash
         * @return {string}
         */
        public getXPXTransactionUsingGET(nemHash : string) : string {
            return org.nem.core.serialization.JsonSerializer.serializeToJson(this.nemTransactionApi.getTransaction(nemHash)).toJSONString();
        }
    }
    LocalTransactionAndAnnounceApi["__class"] = "io.nem.xpx.service.local.LocalTransactionAndAnnounceApi";
    LocalTransactionAndAnnounceApi["__interfaces"] = ["io.nem.xpx.service.intf.TransactionAndAnnounceApi"];


}
namespace io.nem.xpx.service.local {
    /**
     * Instantiates a new local upload api.
     * 
     * @param {io.ipfs.api.IPFS} proximaxIfpsConnection the proximax ifps connection
     * @class
     */
    export class LocalUploadApi implements io.nem.xpx.service.intf.UploadApi {
        /**
         * The proximax ifps connection.
         */
        /*private*/ proximaxIfpsConnection : io.ipfs.api.IPFS;

        public constructor(proximaxIfpsConnection : io.ipfs.api.IPFS) {
            if(this.proximaxIfpsConnection===undefined) this.proximaxIfpsConnection = null;
            this.proximaxIfpsConnection = proximaxIfpsConnection;
        }

        /**
         * 
         * @param {string} multihash
         * @return {string}
         */
        public deletePinnedContent(multihash : string) : string {
            return /* toString */('['+this.proximaxIfpsConnection.pin.rm(io.ipfs.multihash.Multihash.fromBase58(multihash)).join(', ')+']');
        }

        /**
         * 
         * @param {Array} binaryData
         * @param {string} name
         * @param {string} contentType
         * @param {string} keywords
         * @param {string} metadata
         * @return {Array}
         */
        public uploadBytesBinary(binaryData : number[], name : string, contentType : string, keywords : string, metadata : string) : number[] {
            let nameOrDefault : string = io.nem.xpx.utils.StringUtils.isEmpty(name)?/* valueOf */new String(Math.abs(/* currentTimeMillis */Date.now())).toString():name;
            let contentTypeOrDetected : string = io.nem.xpx.utils.ContentTypeUtils.contentTypeLookup$java_lang_String$byte_A(contentType, binaryData);
            let keywordsOrDefault : string = keywords == null?"":keywords;
            let metadataOrDefault : string = metadata == null?"":metadata;
            let spfsBlockResult : io.nem.xpx.model.PublishResult = this.exposeAndPinBinary(nameOrDefault, binaryData);
            let multiHashString : string = /* get */spfsBlockResult.getMerkleNode()[0].hash.toBase58();
            let builder : com.google.flatbuffers.FlatBufferBuilder = new com.google.flatbuffers.FlatBufferBuilder(1024);
            let messageDigest : java.security.MessageDigest = java.security.MessageDigest.getInstance("SHA-256");
            let digest : number = builder.createString(String.fromCharCode.apply(null, org.bouncycastle.util.encoders.Hex.encode(messageDigest.digest(binaryData))));
            let hash : number = builder.createString(multiHashString);
            let keywordsRes : number = builder.createString(keywordsOrDefault);
            let metadataRes : number = builder.createString(metadataOrDefault);
            let nameint : number = builder.createString(nameOrDefault);
            let type : number = builder.createString(contentTypeOrDetected);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.startResourceHashMessage(builder);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addDigest(builder, digest);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addHash(builder, hash);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addKeywords(builder, keywordsRes);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addMetaData(builder, metadataRes);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addName(builder, nameint);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addTimestamp(builder, /* currentTimeMillis */Date.now());
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addType(builder, type);
            builder.finish(io.nem.xpx.service.model.buffers.ResourceHashMessage.endResourceHashMessage(builder));
            return org.apache.commons.codec.binary.Base64.encodeBase64(builder.sizedByteArray());
        }

        /**
         * 
         * @param {Array} textInBytes
         * @param {string} name
         * @param {string} contentType
         * @param {string} encoding
         * @param {string} keywords
         * @param {string} metadata
         * @return {Array}
         */
        public uploadText(textInBytes : number[], name : string, contentType : string, encoding : string, keywords : string, metadata : string) : number[] {
            let nameOrDefault : string = io.nem.xpx.utils.StringUtils.isEmpty(name)?/* valueOf */new String(Math.abs(/* currentTimeMillis */Date.now())).toString():name;
            let contentTypeOrDefault : string = io.nem.xpx.utils.StringUtils.isEmpty(contentType)?"text/plain":contentType;
            let encodingOrDefault : string = io.nem.xpx.utils.StringUtils.isEmpty(encoding)?"UTF-8":encoding;
            let keywordsOrDefault : string = keywords == null?"":keywords;
            let metadataOrDefault : string = metadata == null?"":metadata;
            let spfsBlockResult : io.nem.xpx.model.PublishResult = this.exposeAndPinBinary(nameOrDefault, textInBytes);
            let multiHashString : string = /* get */spfsBlockResult.getMerkleNode()[0].hash.toBase58();
            let builder : com.google.flatbuffers.FlatBufferBuilder = new com.google.flatbuffers.FlatBufferBuilder(1024);
            let messageDigest : java.security.MessageDigest = java.security.MessageDigest.getInstance("SHA-256");
            let digest : number = builder.createString(String.fromCharCode.apply(null, org.bouncycastle.util.encoders.Hex.encode(messageDigest.digest(textInBytes))));
            let hash : number = builder.createString(multiHashString);
            let keywordsRes : number = builder.createString(keywordsOrDefault);
            let metadataRes : number = builder.createString(metadataOrDefault);
            let nameint : number = builder.createString(nameOrDefault);
            let type : number = builder.createString(contentTypeOrDefault);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.startResourceHashMessage(builder);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addDigest(builder, digest);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addHash(builder, hash);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addKeywords(builder, keywordsRes);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addMetaData(builder, metadataRes);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addName(builder, nameint);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addTimestamp(builder, /* currentTimeMillis */Date.now());
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addType(builder, type);
            builder.finish(io.nem.xpx.service.model.buffers.ResourceHashMessage.endResourceHashMessage(builder));
            return org.apache.commons.codec.binary.Base64.encodeBase64(builder.sizedByteArray());
        }

        public uploadPath(path : string, name : string, keywords : string, metadata : string) : number[] {
            let nameOrDefault : string = io.nem.xpx.utils.StringUtils.isEmpty(name)?/* valueOf */new String(Math.abs(/* currentTimeMillis */Date.now())).toString():name;
            let keywordsOrDefault : string = keywords == null?"":keywords;
            let metadataOrDefault : string = metadata == null?"":metadata;
            let contentType : string = "Directory";
            let spfsBlockResult : io.nem.xpx.model.PublishResult = this.exposeAndPinPath(path);
            let multiHashString : string = "";
            let merkleNodeIter : any = /* iterator */((a) => { var i = 0; return { next: function() { return i<a.length?a[i++]:null; }, hasNext: function() { return i<a.length; }}})(spfsBlockResult.getMerkleNode());
            spfsBlockResult.getMerkleNode().stream().forEach((n) => {
                org.pmw.tinylog.Logger.error(n);
            });
            while((merkleNodeIter.hasNext())) {
                let merkleNode : io.ipfs.api.MerkleNode = <io.ipfs.api.MerkleNode>merkleNodeIter.next();
                let namePath : string = "/" + merkleNode.name.get();
                if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(namePath,path))) {
                    multiHashString = merkleNode.hash.toBase58();
                    break;
                }
            };
            if(multiHashString == null || /* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(multiHashString,""))) {
                multiHashString = /* get */spfsBlockResult.getMerkleNode()[/* size */(<number>spfsBlockResult.getMerkleNode().length) - 1].hash.toBase58();
            }
            let builder : com.google.flatbuffers.FlatBufferBuilder = new com.google.flatbuffers.FlatBufferBuilder(1024);
            let messageDigest : java.security.MessageDigest = java.security.MessageDigest.getInstance("SHA-256");
            let digest : number = builder.createString(String.fromCharCode.apply(null, org.bouncycastle.util.encoders.Hex.encode(messageDigest.digest(/* getBytes */(path).split('').map(s => s.charCodeAt(0))))));
            let hash : number = builder.createString(multiHashString);
            let keywordsRes : number = builder.createString(keywordsOrDefault);
            let metadataRes : number = builder.createString(metadataOrDefault);
            let nameint : number = builder.createString(nameOrDefault);
            let type : number = builder.createString(contentType);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.startResourceHashMessage(builder);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addDigest(builder, digest);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addHash(builder, hash);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addKeywords(builder, keywordsRes);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addMetaData(builder, metadataRes);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addName(builder, nameint);
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addTimestamp(builder, /* currentTimeMillis */Date.now());
            io.nem.xpx.service.model.buffers.ResourceHashMessage.addType(builder, type);
            builder.finish(io.nem.xpx.service.model.buffers.ResourceHashMessage.endResourceHashMessage(builder));
            return org.apache.commons.codec.binary.Base64.encodeBase64(builder.sizedByteArray());
        }

        /**
         * Expose and pin binary.
         * 
         * @param {string} name
         * the name
         * @param {Array} binary
         * the binary
         * @return {io.nem.xpx.model.PublishResult} the publish result
         * @throws IOException
         * Signals that an I/O exception has occurred.
         * @throws ApiException
         * the api exception
         * @private
         */
        /*private*/ exposeAndPinBinary(name : string, binary : number[]) : io.nem.xpx.model.PublishResult {
            let result : io.nem.xpx.model.PublishResult = new io.nem.xpx.model.PublishResult();
            let byteArrayWrapper : io.ipfs.api.NamedStreamable.ByteArrayWrapper = new io.ipfs.api.NamedStreamable.ByteArrayWrapper(name, binary);
            let node : Array<io.ipfs.api.MerkleNode> = this.proximaxIfpsConnection.add(byteArrayWrapper);
            let pinned : Array<io.ipfs.multihash.Multihash> = this.proximaxIfpsConnection.pin.add(/* get */node[0].hash);
            result.setMerkleNode(node);
            result.setMultiHash(pinned);
            return result;
        }

        /**
         * Expose and pin path.
         * 
         * @param {string} path the path
         * @return {io.nem.xpx.model.PublishResult} the publish result
         */
        public exposeAndPinPath(path : string) : io.nem.xpx.model.PublishResult {
            let result : io.nem.xpx.model.PublishResult = new io.nem.xpx.model.PublishResult();
            try {
                let streamables : Array<io.ipfs.api.NamedStreamable> = <any>([]);
                let fileWrapper : io.ipfs.api.NamedStreamable.FileWrapper = new io.ipfs.api.NamedStreamable.FileWrapper(new java.io.File(path));
                /* add */(streamables.push(new io.ipfs.api.NamedStreamable.DirWrapper(new java.io.File(path).getAbsolutePath(), fileWrapper.getChildren()))>0);
                let merkleNode : Array<io.ipfs.api.MerkleNode> = this.proximaxIfpsConnection.add(streamables, true, false);
                result.setMerkleNode(merkleNode);
            } catch(e) {
                org.pmw.tinylog.Logger.error("Error on decoding NEM Transaction Message." + e.message);
            };
            return result;
        }

        /**
         * Recurse path to be added.
         * 
         * @param {*[]} streamables
         * the streamables
         * @param {string} path
         * the path
         * @private
         */
        /*private*/ recursePathToBeAdded(streamables : Array<io.ipfs.api.NamedStreamable>, path : string) {
            let folder : java.io.File = new java.io.File(path);
            let listOfFiles : java.io.File[] = folder.listFiles();
            for(let index170=0; index170 < listOfFiles.length; index170++) {
                let file = listOfFiles[index170];
                {
                    if(file.isDirectory()) {
                        let fileWrapper : io.ipfs.api.NamedStreamable.FileWrapper = new io.ipfs.api.NamedStreamable.FileWrapper(file);
                        /* add */(streamables.push(new io.ipfs.api.NamedStreamable.DirWrapper(file.getAbsolutePath(), fileWrapper.getChildren()))>0);
                        this.recursePathToBeAdded(streamables, file.getAbsolutePath());
                    } else {
                        /* add */(streamables.push(new io.ipfs.api.NamedStreamable.FileWrapper(file))>0);
                    }
                }
            }
        }

        /**
         * Expose binary.
         * 
         * @param {string} name
         * the name
         * @param {Array} binary
         * the binary
         * @return {io.nem.xpx.model.PublishResult} the publish result
         * @throws IOException
         * Signals that an I/O exception has occurred.
         * @throws ApiException
         * the api exception
         * @private
         */
        /*private*/ exposeBinary(name : string, binary : number[]) : io.nem.xpx.model.PublishResult {
            let result : io.nem.xpx.model.PublishResult = new io.nem.xpx.model.PublishResult();
            let byteArrayWrapper : io.ipfs.api.NamedStreamable.ByteArrayWrapper = new io.ipfs.api.NamedStreamable.ByteArrayWrapper(name, binary);
            let node : Array<io.ipfs.api.MerkleNode> = this.proximaxIfpsConnection.add(byteArrayWrapper);
            result.setMerkleNode(node);
            return result;
        }

        /**
         * Gets the binary hash only.
         * 
         * @param {string} name
         * the name
         * @param {Array} binary
         * the binary
         * @return {io.nem.xpx.model.PublishResult} the binary hash only
         * @throws IOException
         * Signals that an I/O exception has occurred.
         * @throws ApiException
         * the api exception
         * @private
         */
        /*private*/ getBinaryHashOnly(name : string, binary : number[]) : io.nem.xpx.model.PublishResult {
            let result : io.nem.xpx.model.PublishResult = null;
            result = new io.nem.xpx.model.PublishResult();
            let byteArrayWrapper : io.ipfs.api.NamedStreamable.ByteArrayWrapper = new io.ipfs.api.NamedStreamable.ByteArrayWrapper(name, binary);
            let node : Array<io.ipfs.api.MerkleNode> = this.proximaxIfpsConnection.add(byteArrayWrapper, false, true);
            result.setMerkleNode(node);
            return result;
        }

        /**
         * Grab dirs.
         * 
         * @param {string} path
         * the path
         * @param {io.ipfs.api.MerkleNode[]} node
         * the node
         * @throws IOException
         * Signals that an I/O exception has occurred.
         * @throws ApiException
         * the api exception
         * @private
         */
        /*private*/ grabDirs(path : string, node : Array<io.ipfs.api.MerkleNode>) {
            let directories : java.io.File[] = new java.io.File(path).listFiles(() => { return java.io.File.isDirectory() });
            for(let index171=0; index171 < directories.length; index171++) {
                let f = directories[index171];
                {
                    let fileWrapper : io.ipfs.api.NamedStreamable.FileWrapper = new io.ipfs.api.NamedStreamable.FileWrapper(f);
                    let dirWrapper : io.ipfs.api.NamedStreamable.DirWrapper = new io.ipfs.api.NamedStreamable.DirWrapper(f.getName().toString(), fileWrapper.getChildren());
                    /* addAll */((l1, l2) => l1.push.apply(l1, l2))(node, this.proximaxIfpsConnection.add(dirWrapper, true, false));
                    this.grabDirs(f.getAbsolutePath(), node);
                }
            }
        }
    }
    LocalUploadApi["__class"] = "io.nem.xpx.service.local.LocalUploadApi";
    LocalUploadApi["__interfaces"] = ["io.nem.xpx.service.intf.UploadApi"];


}
namespace io.nem.xpx.service.model.buffers {
    /**
     * The Class ResourceHashMessage.
     * @class
     * @extends com.google.flatbuffers.Table
     */
    export class ResourceHashMessage extends com.google.flatbuffers.Table {
        public static getRootAsResourceHashMessage$java_nio_ByteBuffer(_bb : java.nio.ByteBuffer) : ResourceHashMessage {
            return ResourceHashMessage.getRootAsResourceHashMessage$java_nio_ByteBuffer$io_nem_xpx_service_model_buffers_ResourceHashMessage(_bb, new ResourceHashMessage());
        }

        public static getRootAsResourceHashMessage$java_nio_ByteBuffer$io_nem_xpx_service_model_buffers_ResourceHashMessage(_bb : java.nio.ByteBuffer, obj : ResourceHashMessage) : ResourceHashMessage {
            _bb.order(java.nio.ByteOrder.LITTLE_ENDIAN);
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb));
        }

        /**
         * Gets the root as resource hash message.
         * 
         * @param {java.nio.ByteBuffer} _bb the bb
         * @param {io.nem.xpx.service.model.buffers.ResourceHashMessage} obj the obj
         * @return {io.nem.xpx.service.model.buffers.ResourceHashMessage} the root as resource hash message
         */
        public static getRootAsResourceHashMessage(_bb? : any, obj? : any) : any {
            if(((_bb != null && _bb instanceof <any>java.nio.ByteBuffer) || _bb === null) && ((obj != null && obj instanceof <any>io.nem.xpx.service.model.buffers.ResourceHashMessage) || obj === null)) {
                return <any>io.nem.xpx.service.model.buffers.ResourceHashMessage.getRootAsResourceHashMessage$java_nio_ByteBuffer$io_nem_xpx_service_model_buffers_ResourceHashMessage(_bb, obj);
            } else if(((_bb != null && _bb instanceof <any>java.nio.ByteBuffer) || _bb === null) && obj === undefined) {
                return <any>io.nem.xpx.service.model.buffers.ResourceHashMessage.getRootAsResourceHashMessage$java_nio_ByteBuffer(_bb);
            } else throw new Error('invalid overload');
        }

        /**
         * Inits the.
         * 
         * @param {number} _i the i
         * @param {java.nio.ByteBuffer} _bb the bb
         */
        public __init(_i : number, _bb : java.nio.ByteBuffer) {
            this.bb_pos = _i;
            this.bb = _bb;
        }

        /**
         * Assign.
         * 
         * @param {number} _i the i
         * @param {java.nio.ByteBuffer} _bb the bb
         * @return {io.nem.xpx.service.model.buffers.ResourceHashMessage} the resource hash message
         */
        public __assign(_i : number, _bb : java.nio.ByteBuffer) : ResourceHashMessage {
            this.__init(_i, _bb);
            return this;
        }

        /**
         * Digest.
         * 
         * @return {string} the string
         */
        public digest() : string {
            let o : number = this.__offset(4);
            return o !== 0?this.__string(o + this.bb_pos):null;
        }

        /**
         * Digest as byte buffer.
         * 
         * @return {java.nio.ByteBuffer} the byte buffer
         */
        public digestAsByteBuffer() : java.nio.ByteBuffer {
            return this.__vector_as_bytebuffer(4, 1);
        }

        /**
         * Hash.
         * 
         * @return {string} the string
         */
        public hash() : string {
            let o : number = this.__offset(6);
            return o !== 0?this.__string(o + this.bb_pos):null;
        }

        /**
         * Hash as byte buffer.
         * 
         * @return {java.nio.ByteBuffer} the byte buffer
         */
        public hashAsByteBuffer() : java.nio.ByteBuffer {
            return this.__vector_as_bytebuffer(6, 1);
        }

        /**
         * Keywords.
         * 
         * @return {string} the string
         */
        public keywords() : string {
            let o : number = this.__offset(8);
            return o !== 0?this.__string(o + this.bb_pos):null;
        }

        /**
         * Keywords as byte buffer.
         * 
         * @return {java.nio.ByteBuffer} the byte buffer
         */
        public keywordsAsByteBuffer() : java.nio.ByteBuffer {
            return this.__vector_as_bytebuffer(8, 1);
        }

        /**
         * Meta data.
         * 
         * @return {string} the string
         */
        public metaData() : string {
            let o : number = this.__offset(10);
            return o !== 0?this.__string(o + this.bb_pos):null;
        }

        /**
         * Meta data as byte buffer.
         * 
         * @return {java.nio.ByteBuffer} the byte buffer
         */
        public metaDataAsByteBuffer() : java.nio.ByteBuffer {
            return this.__vector_as_bytebuffer(10, 1);
        }

        /**
         * Name.
         * 
         * @return {string} the string
         */
        public name() : string {
            let o : number = this.__offset(12);
            return o !== 0?this.__string(o + this.bb_pos):null;
        }

        /**
         * Name as byte buffer.
         * 
         * @return {java.nio.ByteBuffer} the byte buffer
         */
        public nameAsByteBuffer() : java.nio.ByteBuffer {
            return this.__vector_as_bytebuffer(12, 1);
        }

        /**
         * Size.
         * 
         * @return {number} the int
         */
        public size() : number {
            let o : number = this.__offset(14);
            return o !== 0?this.bb.getInt(o + this.bb_pos):0;
        }

        /**
         * Timestamp.
         * 
         * @return {number} the long
         */
        public timestamp() : number {
            let o : number = this.__offset(16);
            return o !== 0?this.bb.getLong(o + this.bb_pos):0;
        }

        /**
         * Type.
         * 
         * @return {string} the string
         */
        public type() : string {
            let o : number = this.__offset(18);
            return o !== 0?this.__string(o + this.bb_pos):null;
        }

        /**
         * Type as byte buffer.
         * 
         * @return {java.nio.ByteBuffer} the byte buffer
         */
        public typeAsByteBuffer() : java.nio.ByteBuffer {
            return this.__vector_as_bytebuffer(18, 1);
        }

        /**
         * Creates the resource hash message.
         * 
         * @param {com.google.flatbuffers.FlatBufferBuilder} builder the builder
         * @param {number} digestOffset the digest offset
         * @param {number} hashOffset the hash offset
         * @param {number} keywordsOffset the keywords offset
         * @param {number} metaDataOffset the meta data offset
         * @param {number} nameOffset the name offset
         * @param {number} size the size
         * @param {number} timestamp the timestamp
         * @param {number} typeOffset the type offset
         * @return {number} the int
         */
        public static createResourceHashMessage(builder : com.google.flatbuffers.FlatBufferBuilder, digestOffset : number, hashOffset : number, keywordsOffset : number, metaDataOffset : number, nameOffset : number, size : number, timestamp : number, typeOffset : number) : number {
            builder.startObject(8);
            ResourceHashMessage.addTimestamp(builder, timestamp);
            ResourceHashMessage.addType(builder, typeOffset);
            ResourceHashMessage.addSize(builder, size);
            ResourceHashMessage.addName(builder, nameOffset);
            ResourceHashMessage.addMetaData(builder, metaDataOffset);
            ResourceHashMessage.addKeywords(builder, keywordsOffset);
            ResourceHashMessage.addHash(builder, hashOffset);
            ResourceHashMessage.addDigest(builder, digestOffset);
            return ResourceHashMessage.endResourceHashMessage(builder);
        }

        /**
         * Start resource hash message.
         * 
         * @param {com.google.flatbuffers.FlatBufferBuilder} builder the builder
         */
        public static startResourceHashMessage(builder : com.google.flatbuffers.FlatBufferBuilder) {
            builder.startObject(8);
        }

        /**
         * Adds the digest.
         * 
         * @param {com.google.flatbuffers.FlatBufferBuilder} builder the builder
         * @param {number} digestOffset the digest offset
         */
        public static addDigest(builder : com.google.flatbuffers.FlatBufferBuilder, digestOffset : number) {
            builder.addOffset(0, digestOffset, 0);
        }

        /**
         * Adds the hash.
         * 
         * @param {com.google.flatbuffers.FlatBufferBuilder} builder the builder
         * @param {number} hashOffset the hash offset
         */
        public static addHash(builder : com.google.flatbuffers.FlatBufferBuilder, hashOffset : number) {
            builder.addOffset(1, hashOffset, 0);
        }

        /**
         * Adds the keywords.
         * 
         * @param {com.google.flatbuffers.FlatBufferBuilder} builder the builder
         * @param {number} keywordsOffset the keywords offset
         */
        public static addKeywords(builder : com.google.flatbuffers.FlatBufferBuilder, keywordsOffset : number) {
            builder.addOffset(2, keywordsOffset, 0);
        }

        /**
         * Adds the meta data.
         * 
         * @param {com.google.flatbuffers.FlatBufferBuilder} builder the builder
         * @param {number} metaDataOffset the meta data offset
         */
        public static addMetaData(builder : com.google.flatbuffers.FlatBufferBuilder, metaDataOffset : number) {
            builder.addOffset(3, metaDataOffset, 0);
        }

        /**
         * Adds the name.
         * 
         * @param {com.google.flatbuffers.FlatBufferBuilder} builder the builder
         * @param {number} nameOffset the name offset
         */
        public static addName(builder : com.google.flatbuffers.FlatBufferBuilder, nameOffset : number) {
            builder.addOffset(4, nameOffset, 0);
        }

        /**
         * Adds the size.
         * 
         * @param {com.google.flatbuffers.FlatBufferBuilder} builder the builder
         * @param {number} size the size
         */
        public static addSize(builder : com.google.flatbuffers.FlatBufferBuilder, size : number) {
            builder.addInt(5, size, 0);
        }

        /**
         * Adds the timestamp.
         * 
         * @param {com.google.flatbuffers.FlatBufferBuilder} builder the builder
         * @param {number} timestamp the timestamp
         */
        public static addTimestamp(builder : com.google.flatbuffers.FlatBufferBuilder, timestamp : number) {
            builder.addLong(6, timestamp, 0);
        }

        /**
         * Adds the type.
         * 
         * @param {com.google.flatbuffers.FlatBufferBuilder} builder the builder
         * @param {number} typeOffset the type offset
         */
        public static addType(builder : com.google.flatbuffers.FlatBufferBuilder, typeOffset : number) {
            builder.addOffset(7, typeOffset, 0);
        }

        /**
         * End resource hash message.
         * 
         * @param {com.google.flatbuffers.FlatBufferBuilder} builder the builder
         * @return {number} the int
         */
        public static endResourceHashMessage(builder : com.google.flatbuffers.FlatBufferBuilder) : number {
            let o : number = builder.endObject();
            return o;
        }

        /**
         * Finish resource hash message buffer.
         * 
         * @param {com.google.flatbuffers.FlatBufferBuilder} builder the builder
         * @param {number} offset the offset
         */
        public static finishResourceHashMessageBuffer(builder : com.google.flatbuffers.FlatBufferBuilder, offset : number) {
            builder.finish(offset);
        }
    }
    ResourceHashMessage["__class"] = "io.nem.xpx.service.model.buffers.ResourceHashMessage";

}
namespace io.nem.xpx.service {
    /**
     * Instantiates a new nem account api.
     * 
     * @param {org.nem.core.node.NodeEndpoint} nodeEndpoint the node endpoint
     * @param {org.nem.core.connect.client.DefaultAsyncNemConnector} asyncNemConnector the async nem connector
     * @class
     */
    export class NemAccountApi {
        /**
         * The node endpoint.
         */
        /*private*/ nodeEndpoint : org.nem.core.node.NodeEndpoint;

        /**
         * The async nem connector.
         */
        /*private*/ asyncNemConnector : org.nem.core.connect.client.DefaultAsyncNemConnector<org.nem.core.node.ApiId>;

        public constructor(nodeEndpoint : org.nem.core.node.NodeEndpoint, asyncNemConnector : org.nem.core.connect.client.DefaultAsyncNemConnector<org.nem.core.node.ApiId>) {
            if(this.nodeEndpoint===undefined) this.nodeEndpoint = null;
            if(this.asyncNemConnector===undefined) this.asyncNemConnector = null;
            this.nodeEndpoint = nodeEndpoint;
            this.asyncNemConnector = asyncNemConnector;
        }

        /**
         * Gets the account by address.
         * 
         * @param {string} address            the address
         * @return {org.nem.core.model.ncc.AccountMetaDataPair} the account by address
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         * @throws ApiException the api exception
         */
        public getAccountByAddress(address : string) : org.nem.core.model.ncc.AccountMetaDataPair {
            let des : org.nem.core.serialization.Deserializer;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_ACCOUNT_LOOK_UP], "address=" + address).exceptionally((fn) => {
                console.error(fn.message, fn);
                return null;
            }).get();
            return new org.nem.core.model.ncc.AccountMetaDataPair(des);
        }

        /**
         * Gets the account owned mosaic.
         * 
         * @param {string} address            the address
         * @return {org.nem.core.model.mosaic.Mosaic[]} the account owned mosaic
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         * @throws ApiException the api exception
         */
        public getAccountOwnedMosaic(address : string) : Array<org.nem.core.model.mosaic.Mosaic> {
            let des : org.nem.core.serialization.Deserializer;
            let list : Array<org.nem.core.model.mosaic.Mosaic>;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_ACCOUNT_MOSAIC_OWNED], "address=" + address).get();
            list = <Array<org.nem.core.model.mosaic.Mosaic>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.mosaic.Mosaic(arg0) });
            return list;
        }

        /**
         * Get the list of Harvest Info for the account.
         * 
         * @param {string} address the address
         * @return {org.nem.core.model.ncc.HarvestInfo[]} the account harvest info
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         * @throws ApiException the api exception
         */
        public getAccountHarvestInfo(address : string) : Array<org.nem.core.model.ncc.HarvestInfo> {
            let des : org.nem.core.serialization.Deserializer;
            let list : Array<org.nem.core.model.ncc.HarvestInfo>;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_ACCOUNT_HARVESTS], "address=" + address).get();
            list = <Array<org.nem.core.model.ncc.HarvestInfo>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.HarvestInfo(arg0) });
            return list;
        }

        /**
         * Generate account.
         * 
         * @return {io.nem.xpx.model.GeneratedAccount} the key pair view model
         */
        public generateAccount() : io.nem.xpx.model.GeneratedAccount {
            let ga : io.nem.xpx.model.GeneratedAccount = new io.nem.xpx.model.GeneratedAccount();
            let kp : org.nem.core.crypto.KeyPair = new org.nem.core.crypto.KeyPair();
            let account : org.nem.core.model.Account = new org.nem.core.model.Account(kp);
            ga.setKeyPair(kp);
            ga.setAccount(account);
            ga.setEncodedAddress(account.getAddress().getEncoded());
            ga.setEncodedPrivateKey(kp.getPrivateKey().toString());
            ga.setEncodedPublicKey(kp.getPublicKey().toString());
            return ga;
        }
    }
    NemAccountApi["__class"] = "io.nem.xpx.service.NemAccountApi";

}
namespace io.nem.xpx.service {
    /**
     * Instantiates a new nem namespace and mosaics api.
     * 
     * @param {org.nem.core.node.NodeEndpoint} nodeEndpoint the node endpoint
     * @param {org.nem.core.connect.client.DefaultAsyncNemConnector} asyncNemConnector the async nem connector
     * @class
     */
    export class NemNamespaceAndMosaicsApi {
        /**
         * The node endpoint.
         */
        /*private*/ nodeEndpoint : org.nem.core.node.NodeEndpoint;

        /**
         * The async nem connector.
         */
        /*private*/ asyncNemConnector : org.nem.core.connect.client.DefaultAsyncNemConnector<org.nem.core.node.ApiId>;

        public constructor(nodeEndpoint : org.nem.core.node.NodeEndpoint, asyncNemConnector : org.nem.core.connect.client.DefaultAsyncNemConnector<org.nem.core.node.ApiId>) {
            if(this.nodeEndpoint===undefined) this.nodeEndpoint = null;
            if(this.asyncNemConnector===undefined) this.asyncNemConnector = null;
            this.nodeEndpoint = nodeEndpoint;
            this.asyncNemConnector = asyncNemConnector;
        }

        public getNamespaceRootPage$() : Array<org.nem.core.model.ncc.NamespaceMetaDataPair> {
            let des : org.nem.core.serialization.Deserializer;
            let list : Array<org.nem.core.model.ncc.NamespaceMetaDataPair>;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_NAMESPACE_ROOT_PAGE], "").get();
            list = <Array<org.nem.core.model.ncc.NamespaceMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.NamespaceMetaDataPair(arg0) });
            return list;
        }

        public getNamespaceRootPage$java_lang_String(id : string) : Array<org.nem.core.model.ncc.NamespaceMetaDataPair> {
            let des : org.nem.core.serialization.Deserializer;
            let list : Array<org.nem.core.model.ncc.NamespaceMetaDataPair>;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_NAMESPACE_ROOT_PAGE], "id=" + id).get();
            list = <Array<org.nem.core.model.ncc.NamespaceMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.NamespaceMetaDataPair(arg0) });
            return list;
        }

        public getNamespaceRootPage$java_lang_String$java_lang_String(id : string, pageSize : string) : Array<org.nem.core.model.ncc.NamespaceMetaDataPair> {
            let des : org.nem.core.serialization.Deserializer;
            let list : Array<org.nem.core.model.ncc.NamespaceMetaDataPair>;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_NAMESPACE_ROOT_PAGE], "id=" + id + "&pagesize=" + pageSize).get();
            list = <Array<org.nem.core.model.ncc.NamespaceMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.NamespaceMetaDataPair(arg0) });
            return list;
        }

        /**
         * Gets the namespace root page.
         * 
         * @param {string} id the id
         * @param {string} pageSize the page size
         * @return {org.nem.core.model.ncc.NamespaceMetaDataPair[]} the namespace root page
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        public getNamespaceRootPage(id? : any, pageSize? : any) : any {
            if(((typeof id === 'string') || id === null) && ((typeof pageSize === 'string') || pageSize === null)) {
                return <any>this.getNamespaceRootPage$java_lang_String$java_lang_String(id, pageSize);
            } else if(((typeof id === 'string') || id === null) && pageSize === undefined) {
                return <any>this.getNamespaceRootPage$java_lang_String(id);
            } else if(id === undefined && pageSize === undefined) {
                return <any>this.getNamespaceRootPage$();
            } else throw new Error('invalid overload');
        }

        /**
         * Gets the namespace.
         * 
         * @param {string} namespace the namespace
         * @return {org.nem.core.model.namespace.Namespace} the namespace
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        public getNamespace(namespace : string) : org.nem.core.model.namespace.Namespace {
            let des : org.nem.core.serialization.Deserializer;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_NAMESPACE], "namespace=" + namespace).exceptionally((fn) => {
                console.error(fn.message, fn);
                return null;
            }).get();
            return new org.nem.core.model.namespace.Namespace(des);
        }

        public getNamespaceMosaicDefinitionPage$java_lang_String(namespace : string) : Array<org.nem.core.model.ncc.MosaicDefinitionMetaDataPair> {
            let des : org.nem.core.serialization.Deserializer;
            let list : Array<org.nem.core.model.ncc.MosaicDefinitionMetaDataPair>;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_NAMESPACE_MOSAIC_DEFINITION_PAGE], "namespace=" + namespace).get();
            list = <Array<org.nem.core.model.ncc.MosaicDefinitionMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.MosaicDefinitionMetaDataPair(arg0) });
            return list;
        }

        public getNamespaceMosaicDefinitionPage$java_lang_String$java_lang_String(namespace : string, id : string) : Array<org.nem.core.model.ncc.MosaicDefinitionMetaDataPair> {
            let des : org.nem.core.serialization.Deserializer;
            let list : Array<org.nem.core.model.ncc.MosaicDefinitionMetaDataPair>;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_NAMESPACE_MOSAIC_DEFINITION_PAGE], "namespace=" + namespace + "&id=" + id).get();
            list = <Array<org.nem.core.model.ncc.MosaicDefinitionMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.MosaicDefinitionMetaDataPair(arg0) });
            return list;
        }

        public getNamespaceMosaicDefinitionPage$java_lang_String$java_lang_String$java_lang_String(namespace : string, id : string, pageSize : string) : Array<org.nem.core.model.ncc.MosaicDefinitionMetaDataPair> {
            let des : org.nem.core.serialization.Deserializer;
            let list : Array<org.nem.core.model.ncc.MosaicDefinitionMetaDataPair>;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_NAMESPACE_MOSAIC_DEFINITION_PAGE], "namespace=" + namespace + "&id=" + id + "&pagesize=" + pageSize).get();
            list = <Array<org.nem.core.model.ncc.MosaicDefinitionMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.MosaicDefinitionMetaDataPair(arg0) });
            return list;
        }

        /**
         * Gets the namespace mosaic definition page.
         * 
         * @param {string} namespace the namespace
         * @param {string} id the id
         * @param {string} pageSize the page size
         * @return {org.nem.core.model.ncc.MosaicDefinitionMetaDataPair[]} the namespace mosaic definition page
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        public getNamespaceMosaicDefinitionPage(namespace? : any, id? : any, pageSize? : any) : any {
            if(((typeof namespace === 'string') || namespace === null) && ((typeof id === 'string') || id === null) && ((typeof pageSize === 'string') || pageSize === null)) {
                return <any>this.getNamespaceMosaicDefinitionPage$java_lang_String$java_lang_String$java_lang_String(namespace, id, pageSize);
            } else if(((typeof namespace === 'string') || namespace === null) && ((typeof id === 'string') || id === null) && pageSize === undefined) {
                return <any>this.getNamespaceMosaicDefinitionPage$java_lang_String$java_lang_String(namespace, id);
            } else if(((typeof namespace === 'string') || namespace === null) && id === undefined && pageSize === undefined) {
                return <any>this.getNamespaceMosaicDefinitionPage$java_lang_String(namespace);
            } else throw new Error('invalid overload');
        }

        /**
         * Gets the mosaic information .
         * 
         * @param {string} namespace the namespace
         * @param {string} mosaic the mosaic
         * @return {org.nem.core.model.mosaic.MosaicDefinition} the mosaic information
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        public getMosaicInformation(namespace : string, mosaic : string) : org.nem.core.model.mosaic.MosaicDefinition {
            let des : org.nem.core.serialization.Deserializer;
            let list : Array<org.nem.core.model.ncc.MosaicDefinitionMetaDataPair>;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_NAMESPACE_MOSAIC_DEFINITION_PAGE], "namespace=" + namespace).get();
            list = <Array<org.nem.core.model.ncc.MosaicDefinitionMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.MosaicDefinitionMetaDataPair(arg0) });
            for(let index172=0; index172 < list.length; index172++) {
                let mosaicDefinitionMetadataPair = list[index172];
                {
                    if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(mosaicDefinitionMetadataPair.getEntity().getId().getName(),mosaic))) {
                        return mosaicDefinitionMetadataPair.getEntity();
                    }
                }
            }
            return null;
        }
    }
    NemNamespaceAndMosaicsApi["__class"] = "io.nem.xpx.service.NemNamespaceAndMosaicsApi";

}
namespace io.nem.xpx.service {
    /**
     * Instantiates a new nem transaction api.
     * 
     * @param {org.nem.core.node.NodeEndpoint} nodeEndpoint the node endpoint
     * @param {org.nem.core.connect.client.DefaultAsyncNemConnector} asyncNemConnector the async nem connector
     * @class
     */
    export class NemTransactionApi {
        /**
         * The node endpoint.
         */
        /*private*/ nodeEndpoint : org.nem.core.node.NodeEndpoint;

        /**
         * The async nem connector.
         */
        /*private*/ asyncNemConnector : org.nem.core.connect.client.DefaultAsyncNemConnector<org.nem.core.node.ApiId>;

        public constructor(nodeEndpoint : org.nem.core.node.NodeEndpoint, asyncNemConnector : org.nem.core.connect.client.DefaultAsyncNemConnector<org.nem.core.node.ApiId>) {
            if(this.nodeEndpoint===undefined) this.nodeEndpoint = null;
            if(this.asyncNemConnector===undefined) this.asyncNemConnector = null;
            this.nodeEndpoint = nodeEndpoint;
            this.asyncNemConnector = asyncNemConnector;
        }

        /**
         * Gets the transaction.
         * 
         * @param {string} hash
         * the hash
         * @return {org.nem.core.model.ncc.TransactionMetaDataPair} the transaction
         * @throws InterruptedException
         * the interrupted exception
         * @throws ExecutionException
         * the execution exception
         * @throws ApiException
         * the api exception
         */
        public getTransaction(hash : string) : org.nem.core.model.ncc.TransactionMetaDataPair {
            let des : org.nem.core.serialization.Deserializer;
            let trans : org.nem.core.model.ncc.TransactionMetaDataPair;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_TRANSACTION_GET], "hash=" + hash).get();
            trans = new org.nem.core.model.ncc.TransactionMetaDataPair(des);
            return trans;
        }

        public getAllTransactions$java_lang_String(address : string) : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let des : org.nem.core.serialization.Deserializer;
            let list : Array<org.nem.core.model.ncc.TransactionMetaDataPair>;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_ACCOUNT_TRANSFERS_ALL], "address=" + address).get();
            list = <Array<org.nem.core.model.ncc.TransactionMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.TransactionMetaDataPair(arg0) });
            return list;
        }

        /**
         * Gets the all transactions with a page size.
         * 
         * @param {string} address
         * the address
         * @param {string} pageSize
         * the page size
         * @return {org.nem.core.model.ncc.TransactionMetaDataPair[]} the all transactions with page size
         * @throws InterruptedException
         * the interrupted exception
         * @throws ExecutionException
         * the execution exception
         * @throws ApiException
         * the api exception
         */
        public getAllTransactionsWithPageSize(address : string, pageSize : string) : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let des : org.nem.core.serialization.Deserializer;
            let list : Array<org.nem.core.model.ncc.TransactionMetaDataPair>;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_ACCOUNT_TRANSFERS_ALL], "address=" + address + "&pageSize=" + pageSize).get();
            list = <Array<org.nem.core.model.ncc.TransactionMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.TransactionMetaDataPair(arg0) });
            return list;
        }

        public getAllTransactions$java_lang_String$java_lang_String(address : string, hash : string) : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let des : org.nem.core.serialization.Deserializer;
            let list : Array<org.nem.core.model.ncc.TransactionMetaDataPair>;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_ACCOUNT_TRANSFERS_ALL], "address=" + address + "&hash=" + hash).get();
            list = <Array<org.nem.core.model.ncc.TransactionMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.TransactionMetaDataPair(arg0) });
            return list;
        }

        public getAllTransactions$java_lang_String$java_lang_String$java_lang_String(address : string, hash : string, id : string) : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let des : org.nem.core.serialization.Deserializer;
            let list : Array<org.nem.core.model.ncc.TransactionMetaDataPair>;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_ACCOUNT_TRANSFERS_ALL], "address=" + address + "&hash=" + hash + "&id=" + id).get();
            list = <Array<org.nem.core.model.ncc.TransactionMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.TransactionMetaDataPair(arg0) });
            return list;
        }

        /**
         * Gets the all transactions.
         * 
         * @param {string} address
         * the address
         * @param {string} hash
         * the hash
         * @param {string} id
         * the id
         * @return {org.nem.core.model.ncc.TransactionMetaDataPair[]} the all transactions
         * @throws InterruptedException
         * the interrupted exception
         * @throws ExecutionException
         * the execution exception
         * @throws ApiException
         * the api exception
         */
        public getAllTransactions(address? : any, hash? : any, id? : any) : any {
            if(((typeof address === 'string') || address === null) && ((typeof hash === 'string') || hash === null) && ((typeof id === 'string') || id === null)) {
                return <any>this.getAllTransactions$java_lang_String$java_lang_String$java_lang_String(address, hash, id);
            } else if(((typeof address === 'string') || address === null) && ((typeof hash === 'string') || hash === null) && id === undefined) {
                return <any>this.getAllTransactions$java_lang_String$java_lang_String(address, hash);
            } else if(((typeof address === 'string') || address === null) && hash === undefined && id === undefined) {
                return <any>this.getAllTransactions$java_lang_String(address);
            } else throw new Error('invalid overload');
        }

        public getIncomingTransactions$java_lang_String(address : string) : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let des : org.nem.core.serialization.Deserializer;
            let list : Array<org.nem.core.model.ncc.TransactionMetaDataPair>;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_ACCOUNT_TRANSFERS_INCOMING], "address=" + address).get();
            list = <Array<org.nem.core.model.ncc.TransactionMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.TransactionMetaDataPair(arg0) });
            return list;
        }

        public getIncomingTransactions$java_lang_String$java_lang_String(address : string, hash : string) : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let des : org.nem.core.serialization.Deserializer;
            let list : Array<org.nem.core.model.ncc.TransactionMetaDataPair>;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_ACCOUNT_TRANSFERS_INCOMING], "address=" + address + "&hash=" + hash).get();
            list = <Array<org.nem.core.model.ncc.TransactionMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.TransactionMetaDataPair(arg0) });
            return list;
        }

        public getIncomingTransactions$java_lang_String$java_lang_String$java_lang_String(address : string, hash : string, id : string) : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let des : org.nem.core.serialization.Deserializer;
            let list : Array<org.nem.core.model.ncc.TransactionMetaDataPair>;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_ACCOUNT_TRANSFERS_INCOMING], "address=" + address + "&hash=" + hash + "&id=" + id).get();
            list = <Array<org.nem.core.model.ncc.TransactionMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.TransactionMetaDataPair(arg0) });
            return list;
        }

        /**
         * Gets the incoming transactions.
         * 
         * @param {string} address
         * the address
         * @param {string} hash
         * the hash
         * @param {string} id
         * the id
         * @return {org.nem.core.model.ncc.TransactionMetaDataPair[]} the incoming transactions
         * @throws InterruptedException
         * the interrupted exception
         * @throws ExecutionException
         * the execution exception
         * @throws ApiException
         * the api exception
         */
        public getIncomingTransactions(address? : any, hash? : any, id? : any) : any {
            if(((typeof address === 'string') || address === null) && ((typeof hash === 'string') || hash === null) && ((typeof id === 'string') || id === null)) {
                return <any>this.getIncomingTransactions$java_lang_String$java_lang_String$java_lang_String(address, hash, id);
            } else if(((typeof address === 'string') || address === null) && ((typeof hash === 'string') || hash === null) && id === undefined) {
                return <any>this.getIncomingTransactions$java_lang_String$java_lang_String(address, hash);
            } else if(((typeof address === 'string') || address === null) && hash === undefined && id === undefined) {
                return <any>this.getIncomingTransactions$java_lang_String(address);
            } else throw new Error('invalid overload');
        }

        public getOutgoingTransactions$java_lang_String(address : string) : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let list : Array<org.nem.core.model.ncc.TransactionMetaDataPair>;
            let des : org.nem.core.serialization.Deserializer;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_ACCOUNT_TRANSFERS_OUTGOING], "address=" + address).get();
            list = <Array<org.nem.core.model.ncc.TransactionMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.TransactionMetaDataPair(arg0) });
            return list;
        }

        public getOutgoingTransactions$java_lang_String$java_lang_String(address : string, hash : string) : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let list : Array<org.nem.core.model.ncc.TransactionMetaDataPair>;
            let des : org.nem.core.serialization.Deserializer;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_ACCOUNT_TRANSFERS_OUTGOING], "address=" + address + "&hash=" + hash).get();
            list = <Array<org.nem.core.model.ncc.TransactionMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.TransactionMetaDataPair(arg0) });
            return list;
        }

        public getOutgoingTransactions$java_lang_String$java_lang_String$java_lang_String(address : string, hash : string, id : string) : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let list : Array<org.nem.core.model.ncc.TransactionMetaDataPair>;
            let des : org.nem.core.serialization.Deserializer;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_ACCOUNT_TRANSFERS_OUTGOING], "address=" + address + "&hash=" + hash + "&id=" + id).get();
            list = <Array<org.nem.core.model.ncc.TransactionMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.TransactionMetaDataPair(arg0) });
            return list;
        }

        /**
         * Gets the outgoing transactions.
         * 
         * @param {string} address
         * the address
         * @param {string} hash
         * the hash
         * @param {string} id
         * the id
         * @return {org.nem.core.model.ncc.TransactionMetaDataPair[]} the outgoing transactions
         * @throws InterruptedException
         * the interrupted exception
         * @throws ExecutionException
         * the execution exception
         * @throws ApiException
         * the api exception
         */
        public getOutgoingTransactions(address? : any, hash? : any, id? : any) : any {
            if(((typeof address === 'string') || address === null) && ((typeof hash === 'string') || hash === null) && ((typeof id === 'string') || id === null)) {
                return <any>this.getOutgoingTransactions$java_lang_String$java_lang_String$java_lang_String(address, hash, id);
            } else if(((typeof address === 'string') || address === null) && ((typeof hash === 'string') || hash === null) && id === undefined) {
                return <any>this.getOutgoingTransactions$java_lang_String$java_lang_String(address, hash);
            } else if(((typeof address === 'string') || address === null) && hash === undefined && id === undefined) {
                return <any>this.getOutgoingTransactions$java_lang_String(address);
            } else throw new Error('invalid overload');
        }

        /**
         * Gets the unconfirmed transactions.
         * 
         * @param {string} address
         * the address
         * @return {org.nem.core.model.ncc.TransactionMetaDataPair[]} the unconfirmed transactions
         * @throws InterruptedException
         * the interrupted exception
         * @throws ExecutionException
         * the execution exception
         * @throws ApiException
         * the api exception
         */
        public getUnconfirmedTransactions(address : string) : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let des : org.nem.core.serialization.Deserializer;
            let list : Array<org.nem.core.model.ncc.TransactionMetaDataPair>;
            des = this.asyncNemConnector.getAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_ACCOUNT_UNCONFIRMED], "address=" + address).get();
            list = <Array<org.nem.core.model.ncc.TransactionMetaDataPair>><any>des.readObjectArray<any>("data", (arg0) => { return new org.nem.core.model.ncc.TransactionMetaDataPair(arg0) });
            return list;
        }

        /**
         * Send transfer transaction.
         * 
         * @param {Array} data the data
         * @param {Array} signature the signature
         * @return {org.nem.core.model.ncc.NemAnnounceResult} the nem announce result
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         * @throws ApiException the api exception
         */
        public sendTransferTransaction(data : number[], signature : number[]) : org.nem.core.model.ncc.NemAnnounceResult {
            let request : org.nem.core.model.ncc.RequestAnnounce = new org.nem.core.model.ncc.RequestAnnounce(data, signature);
            let future : java.util.concurrent.CompletableFuture<org.nem.core.serialization.Deserializer> = this.announceTransaction(request);
            let transDes : org.nem.core.serialization.Deserializer = future.get();
            return new org.nem.core.model.ncc.NemAnnounceResult(transDes);
        }

        /**
         * Announce transaction.
         * 
         * @param {org.nem.core.model.ncc.RequestAnnounce} request
         * the request
         * @return {java.util.concurrent.CompletableFuture} the completable future
         */
        public announceTransaction(request : org.nem.core.model.ncc.RequestAnnounce) : java.util.concurrent.CompletableFuture<org.nem.core.serialization.Deserializer> {
            let des : java.util.concurrent.CompletableFuture<org.nem.core.serialization.Deserializer> = this.asyncNemConnector.postAsync(this.nodeEndpoint, org.nem.core.connect.client.NisApiId["_$wrappers"][org.nem.core.connect.client.NisApiId.NIS_REST_TRANSACTION_ANNOUNCE], new org.nem.core.connect.HttpJsonPostRequest(request));
            return des;
        }
    }
    NemTransactionApi["__class"] = "io.nem.xpx.service.NemTransactionApi";

}
namespace io.nem.xpx.service.remote {
    /**
     * Instantiates a new remote account api.
     * 
     * @param {io.nem.ApiClient} apiClient the api client
     * @class
     */
    export class RemoteAccountApi implements io.nem.xpx.service.intf.AccountApi {
        /**
         * The api client.
         */
        /*private*/ apiClient : io.nem.ApiClient;

        public constructor(apiClient : io.nem.ApiClient) {
            if(this.apiClient===undefined) this.apiClient = null;
            this.apiClient = apiClient;
        }

        /**
         * Gets the api client.
         * 
         * @return {io.nem.ApiClient} the api client
         */
        public getApiClient() : io.nem.ApiClient {
            return this.apiClient;
        }

        /**
         * Build call for getAllIncomingNemAddressTransactionsUsingGET.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public getAllIncomingNemAddressTransactionsUsingGETCall(publicKey : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/account/get/incoming/transactions/{publicKey}".replace(new RegExp("\\{publicKey\\}", 'g'),this.apiClient.escapeString(publicKey.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["application/json"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteAccountApi.RemoteAccountApi$0(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Gets the all incoming nem address transactions using GET validate before call.
         * 
         * @param {string} publicKey the public key
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the all incoming nem address transactions using GET validate before call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ getAllIncomingNemAddressTransactionsUsingGETValidateBeforeCall(publicKey : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(publicKey == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'publicKey\' when calling getAllIncomingNemAddressTransactionsUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.getAllIncomingNemAddressTransactionsUsingGETCall(publicKey, progressListener, progressRequestListener);
            return call;
        }

        /**
         * getAllIncomingNemAddressTransactions.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @return {string} String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getAllIncomingNemAddressTransactionsUsingGET(publicKey : string) : string {
            let resp : io.nem.ApiResponse<string> = this.getAllIncomingNemAddressTransactionsUsingGETWithHttpInfo(publicKey);
            return resp.getData();
        }

        /**
         * getAllIncomingNemAddressTransactions.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getAllIncomingNemAddressTransactionsUsingGETWithHttpInfo(publicKey : string) : io.nem.ApiResponse<string> {
            let call : com.squareup.okhttp.Call = this.getAllIncomingNemAddressTransactionsUsingGETValidateBeforeCall(publicKey, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * getAllIncomingNemAddressTransactions (asynchronously).
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public getAllIncomingNemAddressTransactionsUsingGETAsync(publicKey : string, callback : io.nem.ApiCallback<string>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteAccountApi.RemoteAccountApi$1(this, callback);
                progressRequestListener = new RemoteAccountApi.RemoteAccountApi$2(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.getAllIncomingNemAddressTransactionsUsingGETValidateBeforeCall(publicKey, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for getAllNemAddressTransactionsUsingGET.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public getAllNemAddressTransactionsUsingGETCall(publicKey : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/account/get/transactions/{publicKey}".replace(new RegExp("\\{publicKey\\}", 'g'),this.apiClient.escapeString(publicKey.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["application/json"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteAccountApi.RemoteAccountApi$3(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Gets the all nem address transactions using GET validate before call.
         * 
         * @param {string} publicKey the public key
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the all nem address transactions using GET validate before call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ getAllNemAddressTransactionsUsingGETValidateBeforeCall(publicKey : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(publicKey == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'publicKey\' when calling getAllNemAddressTransactionsUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.getAllNemAddressTransactionsUsingGETCall(publicKey, progressListener, progressRequestListener);
            return call;
        }

        /**
         * getAllNemAddressTransactions.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @return {string} String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getAllNemAddressTransactionsUsingGET(publicKey : string) : string {
            let resp : io.nem.ApiResponse<string> = this.getAllNemAddressTransactionsUsingGETWithHttpInfo(publicKey);
            return resp.getData();
        }

        /**
         * getAllNemAddressTransactions.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getAllNemAddressTransactionsUsingGETWithHttpInfo(publicKey : string) : io.nem.ApiResponse<string> {
            let call : com.squareup.okhttp.Call = this.getAllNemAddressTransactionsUsingGETValidateBeforeCall(publicKey, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * getAllNemAddressTransactions (asynchronously).
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public getAllNemAddressTransactionsUsingGETAsync(publicKey : string, callback : io.nem.ApiCallback<string>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteAccountApi.RemoteAccountApi$4(this, callback);
                progressRequestListener = new RemoteAccountApi.RemoteAccountApi$5(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.getAllNemAddressTransactionsUsingGETValidateBeforeCall(publicKey, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for getAllNemAddressTransactionsWithPageSizeUsingGET.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @param {string} pageSize Page Size (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public getAllNemAddressTransactionsWithPageSizeUsingGETCall(publicKey : string, pageSize : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll *//* replaceAll */"/account/get/transactions/{publicKey}/{pageSize}".replace(new RegExp("\\{publicKey\\}", 'g'),this.apiClient.escapeString(publicKey.toString())).replace(new RegExp("\\{pageSize\\}", 'g'),this.apiClient.escapeString(pageSize.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["application/json"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteAccountApi.RemoteAccountApi$6(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Gets the all nem address transactions with page size using GET validate before call.
         * 
         * @param {string} publicKey the public key
         * @param {string} pageSize the page size
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the all nem address transactions with page size using GET validate before call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ getAllNemAddressTransactionsWithPageSizeUsingGETValidateBeforeCall(publicKey : string, pageSize : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(publicKey == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'publicKey\' when calling getAllNemAddressTransactionsWithPageSizeUsingGET(Async)");
            }
            if(pageSize == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'pageSize\' when calling getAllNemAddressTransactionsWithPageSizeUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.getAllNemAddressTransactionsWithPageSizeUsingGETCall(publicKey, pageSize, progressListener, progressRequestListener);
            return call;
        }

        /**
         * getAllNemAddressTransactionsWithPageSize.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @param {string} pageSize Page Size (required)
         * @return {string} String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getAllNemAddressTransactionsWithPageSizeUsingGET(publicKey : string, pageSize : string) : string {
            let resp : io.nem.ApiResponse<string> = this.getAllNemAddressTransactionsWithPageSizeUsingGETWithHttpInfo(publicKey, pageSize);
            return resp.getData();
        }

        /**
         * getAllNemAddressTransactionsWithPageSize.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @param {string} pageSize Page Size (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getAllNemAddressTransactionsWithPageSizeUsingGETWithHttpInfo(publicKey : string, pageSize : string) : io.nem.ApiResponse<string> {
            let call : com.squareup.okhttp.Call = this.getAllNemAddressTransactionsWithPageSizeUsingGETValidateBeforeCall(publicKey, pageSize, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * getAllNemAddressTransactionsWithPageSize (asynchronously).
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @param {string} pageSize Page Size (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public getAllNemAddressTransactionsWithPageSizeUsingGETAsync(publicKey : string, pageSize : string, callback : io.nem.ApiCallback<string>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteAccountApi.RemoteAccountApi$7(this, callback);
                progressRequestListener = new RemoteAccountApi.RemoteAccountApi$8(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.getAllNemAddressTransactionsWithPageSizeUsingGETValidateBeforeCall(publicKey, pageSize, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for getAllOutgoingNemAddressTransactionsUsingGET.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public getAllOutgoingNemAddressTransactionsUsingGETCall(publicKey : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/account/get/outgoing/transactions/{publicKey}".replace(new RegExp("\\{publicKey\\}", 'g'),this.apiClient.escapeString(publicKey.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["application/json"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteAccountApi.RemoteAccountApi$9(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Gets the all outgoing nem address transactions using GET validate before call.
         * 
         * @param {string} publicKey the public key
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the all outgoing nem address transactions using GET validate before call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ getAllOutgoingNemAddressTransactionsUsingGETValidateBeforeCall(publicKey : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(publicKey == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'publicKey\' when calling getAllOutgoingNemAddressTransactionsUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.getAllOutgoingNemAddressTransactionsUsingGETCall(publicKey, progressListener, progressRequestListener);
            return call;
        }

        /**
         * getAllOutgoingNemAddressTransactions.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @return {string} String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getAllOutgoingNemAddressTransactionsUsingGET(publicKey : string) : string {
            let resp : io.nem.ApiResponse<string> = this.getAllOutgoingNemAddressTransactionsUsingGETWithHttpInfo(publicKey);
            return resp.getData();
        }

        /**
         * getAllOutgoingNemAddressTransactions.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getAllOutgoingNemAddressTransactionsUsingGETWithHttpInfo(publicKey : string) : io.nem.ApiResponse<string> {
            let call : com.squareup.okhttp.Call = this.getAllOutgoingNemAddressTransactionsUsingGETValidateBeforeCall(publicKey, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * getAllOutgoingNemAddressTransactions (asynchronously).
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public getAllOutgoingNemAddressTransactionsUsingGETAsync(publicKey : string, callback : io.nem.ApiCallback<string>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteAccountApi.RemoteAccountApi$10(this, callback);
                progressRequestListener = new RemoteAccountApi.RemoteAccountApi$11(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.getAllOutgoingNemAddressTransactionsUsingGETValidateBeforeCall(publicKey, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for getAllUnconfirmedNemAddressTransactionsUsingGET.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public getAllUnconfirmedNemAddressTransactionsUsingGETCall(publicKey : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/account/get/unconfirmed/transactions/{publicKey}".replace(new RegExp("\\{publicKey\\}", 'g'),this.apiClient.escapeString(publicKey.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["application/json"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteAccountApi.RemoteAccountApi$12(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Gets the all unconfirmed nem address transactions using GET validate before call.
         * 
         * @param {string} publicKey the public key
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the all unconfirmed nem address transactions using GET validate before call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ getAllUnconfirmedNemAddressTransactionsUsingGETValidateBeforeCall(publicKey : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(publicKey == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'publicKey\' when calling getAllUnconfirmedNemAddressTransactionsUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.getAllUnconfirmedNemAddressTransactionsUsingGETCall(publicKey, progressListener, progressRequestListener);
            return call;
        }

        /**
         * getAllUnconfirmedNemAddressTransactions.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @return {string} String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getAllUnconfirmedNemAddressTransactionsUsingGET(publicKey : string) : string {
            let resp : io.nem.ApiResponse<string> = this.getAllUnconfirmedNemAddressTransactionsUsingGETWithHttpInfo(publicKey);
            return resp.getData();
        }

        /**
         * getAllUnconfirmedNemAddressTransactions.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getAllUnconfirmedNemAddressTransactionsUsingGETWithHttpInfo(publicKey : string) : io.nem.ApiResponse<string> {
            let call : com.squareup.okhttp.Call = this.getAllUnconfirmedNemAddressTransactionsUsingGETValidateBeforeCall(publicKey, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * getAllUnconfirmedNemAddressTransactions (asynchronously).
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public getAllUnconfirmedNemAddressTransactionsUsingGETAsync(publicKey : string, callback : io.nem.ApiCallback<string>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteAccountApi.RemoteAccountApi$13(this, callback);
                progressRequestListener = new RemoteAccountApi.RemoteAccountApi$14(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.getAllUnconfirmedNemAddressTransactionsUsingGETValidateBeforeCall(publicKey, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for getNemAddressDetailsUsingGET.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public getNemAddressDetailsUsingGETCall(publicKey : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/account/get/info/{publicKey}".replace(new RegExp("\\{publicKey\\}", 'g'),this.apiClient.escapeString(publicKey.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["application/json"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteAccountApi.RemoteAccountApi$15(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Gets the nem address details using GET validate before call.
         * 
         * @param {string} publicKey the public key
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the nem address details using GET validate before call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ getNemAddressDetailsUsingGETValidateBeforeCall(publicKey : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(publicKey == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'publicKey\' when calling getNemAddressDetailsUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.getNemAddressDetailsUsingGETCall(publicKey, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Get the NEM Address Details
         * This endpoint returns the NEM Address/Account Information of a given address.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @return {io.nem.xpx.model.AccountMetaDataPair} AccountMetaDataPair
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getNemAddressDetailsUsingGET(publicKey : string) : io.nem.xpx.model.AccountMetaDataPair {
            let resp : io.nem.ApiResponse<io.nem.xpx.model.AccountMetaDataPair> = this.getNemAddressDetailsUsingGETWithHttpInfo(publicKey);
            return resp.getData();
        }

        /**
         * Get the NEM Address Details
         * This endpoint returns the NEM Address/Account Information of a given address.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;AccountMetaDataPair&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getNemAddressDetailsUsingGETWithHttpInfo(publicKey : string) : io.nem.ApiResponse<io.nem.xpx.model.AccountMetaDataPair> {
            let call : com.squareup.okhttp.Call = this.getNemAddressDetailsUsingGETValidateBeforeCall(publicKey, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<io.nem.xpx.model.AccountMetaDataPair>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<io.nem.xpx.model.AccountMetaDataPair>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Get the NEM Address Details (asynchronously)
         * This endpoint returns the NEM Address/Account Information of a given address.
         * 
         * @param {string} publicKey The NEM Account Public Key (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public getNemAddressDetailsUsingGETAsync(publicKey : string, callback : io.nem.ApiCallback<io.nem.xpx.model.AccountMetaDataPair>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteAccountApi.RemoteAccountApi$16(this, callback);
                progressRequestListener = new RemoteAccountApi.RemoteAccountApi$17(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.getNemAddressDetailsUsingGETValidateBeforeCall(publicKey, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<io.nem.xpx.model.AccountMetaDataPair>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<io.nem.xpx.model.AccountMetaDataPair>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }
    }
    RemoteAccountApi["__class"] = "io.nem.xpx.service.remote.RemoteAccountApi";
    RemoteAccountApi["__interfaces"] = ["io.nem.xpx.service.intf.AccountApi"];



    export namespace RemoteAccountApi {

        export class RemoteAccountApi$0 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$0["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteAccountApi$1 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$1["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteAccountApi$2 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$2["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class RemoteAccountApi$3 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$3["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteAccountApi$4 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$4["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteAccountApi$5 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$5["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class RemoteAccountApi$6 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$6["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteAccountApi$7 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$7["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteAccountApi$8 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$8["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class RemoteAccountApi$9 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$9["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteAccountApi$10 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$10["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteAccountApi$11 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$11["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class RemoteAccountApi$12 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$12["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteAccountApi$13 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$13["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteAccountApi$14 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$14["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class RemoteAccountApi$15 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$15["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteAccountApi$16 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$16["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteAccountApi$17 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteAccountApi$17["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];


    }

}
namespace io.nem.xpx.service.remote {
    /**
     * Instantiates a new remote data hash api.
     * 
     * @param {io.nem.ApiClient} apiClient the api client
     * @class
     */
    export class RemoteDataHashApi implements io.nem.xpx.service.intf.DataHashApi {
        /**
         * The api client.
         */
        /*private*/ apiClient : io.nem.ApiClient;

        public constructor(apiClient : io.nem.ApiClient) {
            if(this.apiClient===undefined) this.apiClient = null;
            this.apiClient = apiClient;
        }

        /**
         * Gets the api client.
         * 
         * @return {io.nem.ApiClient} the api client
         */
        public getApiClient() : io.nem.ApiClient {
            return this.apiClient;
        }

        /**
         * Build call for generateHashForDataOnlyUsingPOST.
         * 
         * @param {Array} data Free form string data that will be stored on the P2P Network (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public generateHashForDataOnlyUsingPOSTCall(data : number[], progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = data;
            let localVarPath : string = "/datahash/hash-only";
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["application/json"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["multipart/form-data"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteDataHashApi.RemoteDataHashApi$0(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Generate hash for data only using POST validate before call.
         * 
         * @param {Array} data the data
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the com.squareup.okhttp. call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ generateHashForDataOnlyUsingPOSTValidateBeforeCall(data : number[], progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(data == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'data\' when calling generateHashForDataOnlyUsingPOST(Async)");
            }
            let call : com.squareup.okhttp.Call = this.generateHashForDataOnlyUsingPOSTCall(data, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Generates the datahash but doesn&#39;t upload the file on the network
         * This endpoint can be used to generates the datahash and uploads the file in the process.
         * @param {Array} data Free form string data that will be stored on the P2P Network (required)
         * @return {string} String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public generateHashForDataOnlyUsingPOST(data : number[]) : string {
            let resp : io.nem.ApiResponse<string> = this.generateHashForDataOnlyUsingPOSTWithHttpInfo(data);
            return resp.getData();
        }

        /**
         * Generates the datahash but doesn&#39;t upload the file on the network
         * This endpoint can be used to generates the datahash and uploads the file in the process.
         * @param {Array} data Free form string data that will be stored on the P2P Network (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public generateHashForDataOnlyUsingPOSTWithHttpInfo(data : number[]) : io.nem.ApiResponse<string> {
            let call : com.squareup.okhttp.Call = this.generateHashForDataOnlyUsingPOSTValidateBeforeCall(data, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Generates the datahash but doesn&#39;t upload the file on the network (asynchronously)
         * This endpoint can be used to generates the datahash and uploads the file in the process.
         * @param {Array} data Free form string data that will be stored on the P2P Network (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public generateHashForDataOnlyUsingPOSTAsync(data : number[], callback : io.nem.ApiCallback<string>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteDataHashApi.RemoteDataHashApi$1(this, callback);
                progressRequestListener = new RemoteDataHashApi.RemoteDataHashApi$2(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.generateHashForDataOnlyUsingPOSTValidateBeforeCall(data, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }
    }
    RemoteDataHashApi["__class"] = "io.nem.xpx.service.remote.RemoteDataHashApi";
    RemoteDataHashApi["__interfaces"] = ["io.nem.xpx.service.intf.DataHashApi"];



    export namespace RemoteDataHashApi {

        export class RemoteDataHashApi$0 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteDataHashApi$0["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteDataHashApi$1 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteDataHashApi$1["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteDataHashApi$2 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteDataHashApi$2["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];


    }

}
namespace io.nem.xpx.service.remote {
    /**
     * Instantiates a new remote directory load api.
     * 
     * @param {io.nem.ApiClient} apiClient the api client
     * @class
     */
    export class RemoteDirectoryLoadApi implements io.nem.xpx.service.intf.DirectoryLoadApi {
        /**
         * The api client.
         */
        /*private*/ apiClient : io.nem.ApiClient;

        public constructor(apiClient : io.nem.ApiClient) {
            if(this.apiClient===undefined) this.apiClient = null;
            this.apiClient = apiClient;
        }

        /**
         * Gets the api client.
         * 
         * @return {io.nem.ApiClient} the api client
         */
        public getApiClient() : io.nem.ApiClient {
            return this.apiClient;
        }

        /**
         * Build call for loadDirectoryUsingGET.
         * 
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public loadDirectoryUsingGETCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/directory/load/{nemHash}/**".replace(new RegExp("\\{nemHash\\}", 'g'),this.apiClient.escapeString(nemHash.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteDirectoryLoadApi.RemoteDirectoryLoadApi$0(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Load directory using GET validate before call.
         * 
         * @param {string} nemHash the nem hash
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the com.squareup.okhttp. call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ loadDirectoryUsingGETValidateBeforeCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(nemHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'nemHash\' when calling loadDirectoryUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.loadDirectoryUsingGETCall(nemHash, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Loads a Static Content.
         * Loads a Static Content.
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @return {*} Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public loadDirectoryUsingGET(nemHash : string) : any {
            let resp : io.nem.ApiResponse<any> = this.loadDirectoryUsingGETWithHttpInfo(nemHash);
            return resp.getData();
        }

        /**
         * Loads a Static Content.
         * Loads a Static Content.
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public loadDirectoryUsingGETWithHttpInfo(nemHash : string) : io.nem.ApiResponse<any> {
            let call : com.squareup.okhttp.Call = this.loadDirectoryUsingGETValidateBeforeCall(nemHash, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<any>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<any>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Loads a Static Content. (asynchronously)
         * Loads a Static Content.
         * @param {string} nemHash NEM Txn (Public) linked to the directory (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public loadDirectoryUsingGETAsync(nemHash : string, callback : io.nem.ApiCallback<any>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteDirectoryLoadApi.RemoteDirectoryLoadApi$1(this, callback);
                progressRequestListener = new RemoteDirectoryLoadApi.RemoteDirectoryLoadApi$2(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.loadDirectoryUsingGETValidateBeforeCall(nemHash, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<any>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<any>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }
    }
    RemoteDirectoryLoadApi["__class"] = "io.nem.xpx.service.remote.RemoteDirectoryLoadApi";
    RemoteDirectoryLoadApi["__interfaces"] = ["io.nem.xpx.service.intf.DirectoryLoadApi"];



    export namespace RemoteDirectoryLoadApi {

        export class RemoteDirectoryLoadApi$0 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteDirectoryLoadApi$0["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteDirectoryLoadApi$1 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteDirectoryLoadApi$1["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteDirectoryLoadApi$2 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteDirectoryLoadApi$2["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];


    }

}
namespace io.nem.xpx.service.remote {
    /**
     * Instantiates a new remote download api.
     * 
     * @param {io.nem.ApiClient} apiClient the api client
     * @class
     */
    export class RemoteDownloadApi implements io.nem.xpx.service.intf.DownloadApi {
        /**
         * The api client.
         */
        /*private*/ apiClient : io.nem.ApiClient;

        public constructor(apiClient : io.nem.ApiClient) {
            if(this.apiClient===undefined) this.apiClient = null;
            this.apiClient = apiClient;
        }

        /**
         * Gets the api client.
         * 
         * @return {io.nem.ApiClient} the api client
         */
        public getApiClient() : io.nem.ApiClient {
            return this.apiClient;
        }

        /**
         * Build call for downloadBinaryUsingGET.
         * 
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferMode Transfer Mode default: bytes (bytes,stream,base64) (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public downloadBinaryUsingGETCall(nemHash : string, transferMode : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = "/download/binary";
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            if(nemHash != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "nemHash", nemHash));
            if(transferMode != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "transferMode", transferMode));
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteDownloadApi.RemoteDownloadApi$0(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Download binary using GET validate before call.
         * 
         * @param {string} nemHash the nem hash
         * @param {string} transferMode the transfer mode
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the com.squareup.okhttp. call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ downloadBinaryUsingGETValidateBeforeCall(nemHash : string, transferMode : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(nemHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'nemHash\' when calling downloadBinaryUsingGET(Async)");
            }
            if(transferMode == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'transferMode\' when calling downloadBinaryUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.downloadBinaryUsingGETCall(nemHash, transferMode, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Download a binary using NEM Transaction Hash
         * Download the binary file associated to a NEM Hash. If NEM Hash uses SECURE Message, it returns the NEM TXN Payload Instead
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferMode Transfer Mode default: bytes (bytes,stream,base64) (required)
         * @return {Array} byte[]
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public downloadBinaryUsingGET(nemHash : string, transferMode : string) : number[] {
            let resp : io.nem.ApiResponse<number[]> = this.downloadBinaryUsingGETWithHttpInfo(nemHash, transferMode);
            return resp.getData();
        }

        /**
         * Download a binary using NEM Transaction Hash
         * Download the binary file associated to a NEM Hash. If NEM Hash uses SECURE Message, it returns the NEM TXN Payload Instead
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferMode Transfer Mode default: bytes (bytes,stream,base64) (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;byte[]&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public downloadBinaryUsingGETWithHttpInfo(nemHash : string, transferMode : string) : io.nem.ApiResponse<number[]> {
            let call : com.squareup.okhttp.Call = this.downloadBinaryUsingGETValidateBeforeCall(nemHash, transferMode, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Download a binary using NEM Transaction Hash (asynchronously)
         * Download the binary file associated to a NEM Hash. If NEM Hash uses SECURE Message, it returns the NEM TXN Payload Instead
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferMode Transfer Mode default: bytes (bytes,stream,base64) (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public downloadBinaryUsingGETAsync(nemHash : string, transferMode : string, callback : io.nem.ApiCallback<number[]>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteDownloadApi.RemoteDownloadApi$1(this, callback);
                progressRequestListener = new RemoteDownloadApi.RemoteDownloadApi$2(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.downloadBinaryUsingGETValidateBeforeCall(nemHash, transferMode, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for downloadFileUsingGET.
         * 
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferMode Transfer Mode default: bytes (bytes,stream,base64) (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public downloadFileUsingGETCall(nemHash : string, transferMode : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = "/download/file";
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            if(nemHash != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "nemHash", nemHash));
            if(transferMode != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "transferMode", transferMode));
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteDownloadApi.RemoteDownloadApi$3(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Download file using GET validate before call.
         * 
         * @param {string} nemHash the nem hash
         * @param {string} transferMode the transfer mode
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the com.squareup.okhttp. call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ downloadFileUsingGETValidateBeforeCall(nemHash : string, transferMode : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(nemHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'nemHash\' when calling downloadFileUsingGET(Async)");
            }
            if(transferMode == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'transferMode\' when calling downloadFileUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.downloadFileUsingGETCall(nemHash, transferMode, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Download a file associated to a NEM Hash.
         * Download the binary file associated to a NEM Hash. If NEM Hash uses SECURE Message, it returns the NEM TXN Payload Instead
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferMode Transfer Mode default: bytes (bytes,stream,base64) (required)
         * @return {Array} byte[]
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public downloadFileUsingGET(nemHash : string, transferMode : string) : number[] {
            let resp : io.nem.ApiResponse<number[]> = this.downloadFileUsingGETWithHttpInfo(nemHash, transferMode);
            return resp.getData();
        }

        /**
         * Download a file associated to a NEM Hash.
         * Download the binary file associated to a NEM Hash. If NEM Hash uses SECURE Message, it returns the NEM TXN Payload Instead
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferMode Transfer Mode default: bytes (bytes,stream,base64) (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;byte[]&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public downloadFileUsingGETWithHttpInfo(nemHash : string, transferMode : string) : io.nem.ApiResponse<number[]> {
            let call : com.squareup.okhttp.Call = this.downloadFileUsingGETValidateBeforeCall(nemHash, transferMode, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Download a file associated to a NEM Hash. (asynchronously)
         * Download the binary file associated to a NEM Hash. If NEM Hash uses SECURE Message, it returns the NEM TXN Payload Instead
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferMode Transfer Mode default: bytes (bytes,stream,base64) (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public downloadFileUsingGETAsync(nemHash : string, transferMode : string, callback : io.nem.ApiCallback<number[]>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteDownloadApi.RemoteDownloadApi$4(this, callback);
                progressRequestListener = new RemoteDownloadApi.RemoteDownloadApi$5(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.downloadFileUsingGETValidateBeforeCall(nemHash, transferMode, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for downloadSecureBinaryUsingGET.
         * 
         * @param {string} xPvkey The Sender or Receiver&#39;s Private Key (required)
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferType Transfer Type default: bytes (bytes,stream,base64) (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public downloadSecureBinaryUsingGETCall(xPvkey : string, nemHash : string, transferType : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = "/download/secure/binary";
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            if(nemHash != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "nemHash", nemHash));
            if(transferType != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "transferType", transferType));
            let localVarHeaderParams : any = <any>({});
            if(xPvkey != null) /* put */(localVarHeaderParams["x-pvkey"] = this.apiClient.parameterToString(xPvkey));
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteDownloadApi.RemoteDownloadApi$6(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Download secure binary using GET validate before call.
         * 
         * @param {string} xPvkey the x pvkey
         * @param {string} nemHash the nem hash
         * @param {string} transferType the transfer type
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the com.squareup.okhttp. call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ downloadSecureBinaryUsingGETValidateBeforeCall(xPvkey : string, nemHash : string, transferType : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(xPvkey == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'xPvkey\' when calling downloadSecureBinaryUsingGET(Async)");
            }
            if(nemHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'nemHash\' when calling downloadSecureBinaryUsingGET(Async)");
            }
            if(transferType == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'transferType\' when calling downloadSecureBinaryUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.downloadSecureBinaryUsingGETCall(xPvkey, nemHash, transferType, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Download a secure resource/blob using NEM Private Key and Transaction Hash
         * Download a blob associated to a NEM Hash. If NEM Hash uses SECURE Message, it returns the NEM TXN Payload Instead
         * @param {string} xPvkey The Sender or Receiver&#39;s Private Key (required)
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferType Transfer Type default: bytes (bytes,stream,base64) (required)
         * @return {Array} byte[]
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public downloadSecureBinaryUsingGET(xPvkey : string, nemHash : string, transferType : string) : number[] {
            let resp : io.nem.ApiResponse<number[]> = this.downloadSecureBinaryUsingGETWithHttpInfo(xPvkey, nemHash, transferType);
            return resp.getData();
        }

        /**
         * Download a secure resource/blob using NEM Private Key and Transaction Hash
         * Download a blob associated to a NEM Hash. If NEM Hash uses SECURE Message, it returns the NEM TXN Payload Instead
         * @param {string} xPvkey The Sender or Receiver&#39;s Private Key (required)
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferType Transfer Type default: bytes (bytes,stream,base64) (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;byte[]&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public downloadSecureBinaryUsingGETWithHttpInfo(xPvkey : string, nemHash : string, transferType : string) : io.nem.ApiResponse<number[]> {
            let call : com.squareup.okhttp.Call = this.downloadSecureBinaryUsingGETValidateBeforeCall(xPvkey, nemHash, transferType, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Download a secure resource/blob using NEM Private Key and Transaction Hash (asynchronously)
         * Download a blob associated to a NEM Hash. If NEM Hash uses SECURE Message, it returns the NEM TXN Payload Instead
         * @param {string} xPvkey The Sender or Receiver&#39;s Private Key (required)
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferType Transfer Type default: bytes (bytes,stream,base64) (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public downloadSecureBinaryUsingGETAsync(xPvkey : string, nemHash : string, transferType : string, callback : io.nem.ApiCallback<number[]>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteDownloadApi.RemoteDownloadApi$7(this, callback);
                progressRequestListener = new RemoteDownloadApi.RemoteDownloadApi$8(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.downloadSecureBinaryUsingGETValidateBeforeCall(xPvkey, nemHash, transferType, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for downloadSecureFileUsingGET.
         * 
         * @param {string} xPvkey The Sender or Receiver&#39;s Private Key (required)
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferType Transfer Type default: bytes (bytes,stream,base64) (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public downloadSecureFileUsingGETCall(xPvkey : string, nemHash : string, transferType : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = "/download/secure/file";
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            if(nemHash != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "nemHash", nemHash));
            if(transferType != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "transferType", transferType));
            let localVarHeaderParams : any = <any>({});
            if(xPvkey != null) /* put */(localVarHeaderParams["x-pvkey"] = this.apiClient.parameterToString(xPvkey));
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteDownloadApi.RemoteDownloadApi$9(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Download secure file using GET validate before call.
         * 
         * @param {string} xPvkey the x pvkey
         * @param {string} nemHash the nem hash
         * @param {string} transferType the transfer type
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the com.squareup.okhttp. call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ downloadSecureFileUsingGETValidateBeforeCall(xPvkey : string, nemHash : string, transferType : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(xPvkey == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'xPvkey\' when calling downloadSecureFileUsingGET(Async)");
            }
            if(nemHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'nemHash\' when calling downloadSecureFileUsingGET(Async)");
            }
            if(transferType == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'transferType\' when calling downloadSecureFileUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.downloadSecureFileUsingGETCall(xPvkey, nemHash, transferType, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Download a secure resource/file using NEM Private Key and Transaction Hash
         * Download a file associated to a NEM Hash. If NEM Hash uses SECURE Message, it returns the NEM TXN Payload Instead
         * @param {string} xPvkey The Sender or Receiver&#39;s Private Key (required)
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferType Transfer Type default: bytes (bytes,stream,base64) (required)
         * @return {Array} byte[]
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public downloadSecureFileUsingGET(xPvkey : string, nemHash : string, transferType : string) : number[] {
            let resp : io.nem.ApiResponse<number[]> = this.downloadSecureFileUsingGETWithHttpInfo(xPvkey, nemHash, transferType);
            return resp.getData();
        }

        /**
         * Download a secure resource/file using NEM Private Key and Transaction Hash
         * Download a file associated to a NEM Hash. If NEM Hash uses SECURE Message, it returns the NEM TXN Payload Instead
         * @param {string} xPvkey The Sender or Receiver&#39;s Private Key (required)
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferType Transfer Type default: bytes (bytes,stream,base64) (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;byte[]&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public downloadSecureFileUsingGETWithHttpInfo(xPvkey : string, nemHash : string, transferType : string) : io.nem.ApiResponse<number[]> {
            let call : com.squareup.okhttp.Call = this.downloadSecureFileUsingGETValidateBeforeCall(xPvkey, nemHash, transferType, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Download a secure resource/file using NEM Private Key and Transaction Hash (asynchronously)
         * Download a file associated to a NEM Hash. If NEM Hash uses SECURE Message, it returns the NEM TXN Payload Instead
         * @param {string} xPvkey The Sender or Receiver&#39;s Private Key (required)
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferType Transfer Type default: bytes (bytes,stream,base64) (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public downloadSecureFileUsingGETAsync(xPvkey : string, nemHash : string, transferType : string, callback : io.nem.ApiCallback<number[]>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteDownloadApi.RemoteDownloadApi$10(this, callback);
                progressRequestListener = new RemoteDownloadApi.RemoteDownloadApi$11(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.downloadSecureFileUsingGETValidateBeforeCall(xPvkey, nemHash, transferType, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for downloadTextUsingGET.
         * 
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferMode Transfer Mode default: bytes (bytes,stream) (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public downloadTextUsingGETCall(nemHash : string, transferMode : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = "/download/text";
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            if(nemHash != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "nemHash", nemHash));
            if(transferMode != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "transferMode", transferMode));
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteDownloadApi.RemoteDownloadApi$12(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Download text using GET validate before call.
         * 
         * @param {string} nemHash the nem hash
         * @param {string} transferMode the transfer mode
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the com.squareup.okhttp. call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ downloadTextUsingGETValidateBeforeCall(nemHash : string, transferMode : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(nemHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'nemHash\' when calling downloadTextUsingGET(Async)");
            }
            if(transferMode == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'transferMode\' when calling downloadTextUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.downloadTextUsingGETCall(nemHash, transferMode, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Download a base64 encoded plain text data using NEM Transaction Hash
         * Download a plain text data associated to a NEM Hash. If NEM Hash uses SECURE Message, it returns the NEM TXN Payload Instead
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferMode Transfer Mode default: bytes (bytes,stream) (required)
         * @return {Array} byte[]
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public downloadTextUsingGET(nemHash : string, transferMode : string) : number[] {
            let resp : io.nem.ApiResponse<number[]> = this.downloadTextUsingGETWithHttpInfo(nemHash, transferMode);
            return resp.getData();
        }

        /**
         * Download a base64 encoded plain text data using NEM Transaction Hash
         * Download a plain text data associated to a NEM Hash. If NEM Hash uses SECURE Message, it returns the NEM TXN Payload Instead
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferMode Transfer Mode default: bytes (bytes,stream) (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;byte[]&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public downloadTextUsingGETWithHttpInfo(nemHash : string, transferMode : string) : io.nem.ApiResponse<number[]> {
            let call : com.squareup.okhttp.Call = this.downloadTextUsingGETValidateBeforeCall(nemHash, transferMode, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Download a base64 encoded plain text data using NEM Transaction Hash (asynchronously)
         * Download a plain text data associated to a NEM Hash. If NEM Hash uses SECURE Message, it returns the NEM TXN Payload Instead
         * @param {string} nemHash The NEM Transaction Hash (required)
         * @param {string} transferMode Transfer Mode default: bytes (bytes,stream) (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public downloadTextUsingGETAsync(nemHash : string, transferMode : string, callback : io.nem.ApiCallback<number[]>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteDownloadApi.RemoteDownloadApi$13(this, callback);
                progressRequestListener = new RemoteDownloadApi.RemoteDownloadApi$14(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.downloadTextUsingGETValidateBeforeCall(nemHash, transferMode, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for downloadUsingDataHashUsingGET.
         * 
         * @param {string} dataHash The NEM Transaction Hash (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public downloadUsingDataHashUsingGETCall(dataHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = "/download/direct/datahash";
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            if(dataHash != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "dataHash", dataHash));
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteDownloadApi.RemoteDownloadApi$15(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Download using data hash using GET validate before call.
         * 
         * @param {string} dataHash the data hash
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the com.squareup.okhttp. call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ downloadUsingDataHashUsingGETValidateBeforeCall(dataHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(dataHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'dataHash\' when calling downloadUsingDataHashUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.downloadUsingDataHashUsingGETCall(dataHash, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Download IPFS file associated to the datahash
         * Download IPFS file associated to the datahash.
         * 
         * @param {string} dataHash The NEM Transaction Hash (required)
         * @return {Array} byte[]
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public downloadUsingDataHashUsingGET(dataHash : string) : number[] {
            let resp : io.nem.ApiResponse<number[]> = this.downloadUsingDataHashUsingGETWithHttpInfo(dataHash);
            return resp.getData();
        }

        /**
         * Download IPFS file associated to the datahash
         * Download IPFS file associated to the datahash.
         * 
         * @param {string} dataHash The NEM Transaction Hash (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;byte[]&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public downloadUsingDataHashUsingGETWithHttpInfo(dataHash : string) : io.nem.ApiResponse<number[]> {
            let call : com.squareup.okhttp.Call = this.downloadUsingDataHashUsingGETValidateBeforeCall(dataHash, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Download IPFS file associated to the datahash (asynchronously)
         * Download IPFS file associated to the datahash.
         * 
         * @param {string} dataHash The NEM Transaction Hash (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public downloadUsingDataHashUsingGETAsync(dataHash : string, callback : io.nem.ApiCallback<number[]>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteDownloadApi.RemoteDownloadApi$16(this, callback);
                progressRequestListener = new RemoteDownloadApi.RemoteDownloadApi$17(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.downloadUsingDataHashUsingGETValidateBeforeCall(dataHash, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }
    }
    RemoteDownloadApi["__class"] = "io.nem.xpx.service.remote.RemoteDownloadApi";
    RemoteDownloadApi["__interfaces"] = ["io.nem.xpx.service.intf.DownloadApi"];



    export namespace RemoteDownloadApi {

        export class RemoteDownloadApi$0 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$0["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteDownloadApi$1 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$1["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteDownloadApi$2 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$2["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class RemoteDownloadApi$3 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$3["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteDownloadApi$4 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$4["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteDownloadApi$5 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$5["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class RemoteDownloadApi$6 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$6["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteDownloadApi$7 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$7["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteDownloadApi$8 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$8["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class RemoteDownloadApi$9 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$9["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteDownloadApi$10 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$10["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteDownloadApi$11 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$11["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class RemoteDownloadApi$12 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$12["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteDownloadApi$13 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$13["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteDownloadApi$14 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$14["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class RemoteDownloadApi$15 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$15["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteDownloadApi$16 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$16["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteDownloadApi$17 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteDownloadApi$17["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];


    }

}
namespace io.nem.xpx.service.remote {
    /**
     * Instantiates a new remote node api.
     * 
     * @param {io.nem.ApiClient} apiClient the api client
     * @class
     */
    export class RemoteNodeApi implements io.nem.xpx.service.intf.NodeApi {
        /**
         * The api client.
         */
        /*private*/ apiClient : io.nem.ApiClient;

        public constructor(apiClient : io.nem.ApiClient) {
            if(this.apiClient===undefined) this.apiClient = null;
            this.apiClient = apiClient;
        }

        /**
         * Gets the api client.
         * 
         * @return {io.nem.ApiClient} the api client
         */
        public getApiClient() : io.nem.ApiClient {
            return this.apiClient;
        }

        /**
         * Build call for checkNodeUsingGET.
         * 
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public checkNodeUsingGETCall(progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = "/node/check";
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["application/json"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteNodeApi.RemoteNodeApi$0(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Check node using GET validate before call.
         * 
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the com.squareup.okhttp. call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ checkNodeUsingGETValidateBeforeCall(progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let call : com.squareup.okhttp.Call = this.checkNodeUsingGETCall(progressListener, progressRequestListener);
            return call;
        }

        /**
         * Check if the Storage Node is up and running.
         * This endpoint is used to check if the P2P Storage Node instance is either alive or down.
         * @return {io.nem.xpx.model.GenericResponseMessage} GenericResponseMessage
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public checkNodeUsingGET() : io.nem.xpx.model.GenericResponseMessage {
            let resp : io.nem.ApiResponse<io.nem.xpx.model.GenericResponseMessage> = this.checkNodeUsingGETWithHttpInfo();
            return resp.getData();
        }

        /**
         * Check if the Storage Node is up and running.
         * This endpoint is used to check if the P2P Storage Node instance is either alive or down.
         * @return {io.nem.ApiResponse} ApiResponse&lt;GenericResponseMessage&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public checkNodeUsingGETWithHttpInfo() : io.nem.ApiResponse<io.nem.xpx.model.GenericResponseMessage> {
            let call : com.squareup.okhttp.Call = this.checkNodeUsingGETValidateBeforeCall(null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<io.nem.xpx.model.GenericResponseMessage>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<io.nem.xpx.model.GenericResponseMessage>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Check if the Storage Node is up and running. (asynchronously)
         * This endpoint is used to check if the P2P Storage Node instance is either alive or down.
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public checkNodeUsingGETAsync(callback : io.nem.ApiCallback<io.nem.xpx.model.GenericResponseMessage>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteNodeApi.RemoteNodeApi$1(this, callback);
                progressRequestListener = new RemoteNodeApi.RemoteNodeApi$2(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.checkNodeUsingGETValidateBeforeCall(progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<io.nem.xpx.model.GenericResponseMessage>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<io.nem.xpx.model.GenericResponseMessage>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for getNodeInfoPeersUsingGET.
         * 
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public getNodeInfoPeersUsingGETCall(progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = "/node/info/peers";
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["application/json"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteNodeApi.RemoteNodeApi$3(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Gets the node info peers using GET validate before call.
         * 
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the node info peers using GET validate before call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ getNodeInfoPeersUsingGETValidateBeforeCall(progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let call : com.squareup.okhttp.Call = this.getNodeInfoPeersUsingGETCall(progressListener, progressRequestListener);
            return call;
        }

        /**
         * Get Storage Node Information
         * This endpoint returns the information of the P2P Storage Node.
         * 
         * @return {io.nem.xpx.model.NodeInfo} NodeInfo
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getNodeInfoPeersUsingGET() : io.nem.xpx.model.NodeInfo {
            let resp : io.nem.ApiResponse<io.nem.xpx.model.NodeInfo> = this.getNodeInfoPeersUsingGETWithHttpInfo();
            return resp.getData();
        }

        /**
         * Get Storage Node Information
         * This endpoint returns the information of the P2P Storage Node.
         * 
         * @return {io.nem.ApiResponse} ApiResponse&lt;NodeInfo&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getNodeInfoPeersUsingGETWithHttpInfo() : io.nem.ApiResponse<io.nem.xpx.model.NodeInfo> {
            let call : com.squareup.okhttp.Call = this.getNodeInfoPeersUsingGETValidateBeforeCall(null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<io.nem.xpx.model.NodeInfo>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<io.nem.xpx.model.NodeInfo>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Get Storage Node Information (asynchronously)
         * This endpoint returns the information of the P2P Storage Node.
         * 
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public getNodeInfoPeersUsingGETAsync(callback : io.nem.ApiCallback<io.nem.xpx.model.NodeInfo>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteNodeApi.RemoteNodeApi$4(this, callback);
                progressRequestListener = new RemoteNodeApi.RemoteNodeApi$5(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.getNodeInfoPeersUsingGETValidateBeforeCall(progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<io.nem.xpx.model.NodeInfo>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<io.nem.xpx.model.NodeInfo>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for getNodeInfoUsingGET.
         * 
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public getNodeInfoUsingGETCall(progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = "/node/info";
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["application/json"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteNodeApi.RemoteNodeApi$6(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Gets the node info using GET validate before call.
         * 
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the node info using GET validate before call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ getNodeInfoUsingGETValidateBeforeCall(progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let call : com.squareup.okhttp.Call = this.getNodeInfoUsingGETCall(progressListener, progressRequestListener);
            return call;
        }

        /**
         * Get Storage Node Information
         * This endpoint returns the information of the P2P Storage Node.
         * 
         * @return {io.nem.xpx.model.NodeInfo} NodeInfo
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getNodeInfoUsingGET() : io.nem.xpx.model.NodeInfo {
            let resp : io.nem.ApiResponse<io.nem.xpx.model.NodeInfo> = this.getNodeInfoUsingGETWithHttpInfo();
            return resp.getData();
        }

        /**
         * Get Storage Node Information
         * This endpoint returns the information of the P2P Storage Node.
         * 
         * @return {io.nem.ApiResponse} ApiResponse&lt;NodeInfo&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getNodeInfoUsingGETWithHttpInfo() : io.nem.ApiResponse<io.nem.xpx.model.NodeInfo> {
            let call : com.squareup.okhttp.Call = this.getNodeInfoUsingGETValidateBeforeCall(null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<io.nem.xpx.model.NodeInfo>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<io.nem.xpx.model.NodeInfo>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Get Storage Node Information (asynchronously)
         * This endpoint returns the information of the P2P Storage Node.
         * 
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public getNodeInfoUsingGETAsync(callback : io.nem.ApiCallback<io.nem.xpx.model.NodeInfo>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteNodeApi.RemoteNodeApi$7(this, callback);
                progressRequestListener = new RemoteNodeApi.RemoteNodeApi$8(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.getNodeInfoUsingGETValidateBeforeCall(progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<io.nem.xpx.model.NodeInfo>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<io.nem.xpx.model.NodeInfo>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for setBlockchainNodeConnectionUsingPOST.
         * 
         * @param {string} network Blockchain Network (required)
         * @param {string} domain Blockchain Network Domain (xxx.xxx.xxx) (required)
         * @param {string} port Blockchain Network Port (xxx.xxx.xxx) (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public setBlockchainNodeConnectionUsingPOSTCall(network : string, domain : string, port : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = "/node/set/blockchain/connection";
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            if(network != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "network", network));
            if(domain != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "domain", domain));
            if(port != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "port", port));
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["application/json"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteNodeApi.RemoteNodeApi$9(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Sets the blockchain node connection using POST validate before call.
         * 
         * @param {string} network the network
         * @param {string} domain the domain
         * @param {string} port the port
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the com.squareup.okhttp. call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ setBlockchainNodeConnectionUsingPOSTValidateBeforeCall(network : string, domain : string, port : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(network == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'network\' when calling setBlockchainNodeConnectionUsingPOST(Async)");
            }
            if(domain == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'domain\' when calling setBlockchainNodeConnectionUsingPOST(Async)");
            }
            if(port == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'port\' when calling setBlockchainNodeConnectionUsingPOST(Async)");
            }
            let call : com.squareup.okhttp.Call = this.setBlockchainNodeConnectionUsingPOSTCall(network, domain, port, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Get Storage Node Information
         * This endpoint returns the information of the P2P Storage Node.
         * 
         * @param {string} network Blockchain Network (required)
         * @param {string} domain Blockchain Network Domain (xxx.xxx.xxx) (required)
         * @param {string} port Blockchain Network Port (xxx.xxx.xxx) (required)
         * @return {string} String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public setBlockchainNodeConnectionUsingPOST(network : string, domain : string, port : string) : string {
            let resp : io.nem.ApiResponse<string> = this.setBlockchainNodeConnectionUsingPOSTWithHttpInfo(network, domain, port);
            return resp.getData();
        }

        /**
         * Get Storage Node Information
         * This endpoint returns the information of the P2P Storage Node.
         * 
         * @param {string} network Blockchain Network (required)
         * @param {string} domain Blockchain Network Domain (xxx.xxx.xxx) (required)
         * @param {string} port Blockchain Network Port (xxx.xxx.xxx) (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public setBlockchainNodeConnectionUsingPOSTWithHttpInfo(network : string, domain : string, port : string) : io.nem.ApiResponse<string> {
            let call : com.squareup.okhttp.Call = this.setBlockchainNodeConnectionUsingPOSTValidateBeforeCall(network, domain, port, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Get Storage Node Information (asynchronously)
         * This endpoint returns the information of the P2P Storage Node.
         * 
         * @param {string} network Blockchain Network (required)
         * @param {string} domain Blockchain Network Domain (xxx.xxx.xxx) (required)
         * @param {string} port Blockchain Network Port (xxx.xxx.xxx) (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public setBlockchainNodeConnectionUsingPOSTAsync(network : string, domain : string, port : string, callback : io.nem.ApiCallback<string>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteNodeApi.RemoteNodeApi$10(this, callback);
                progressRequestListener = new RemoteNodeApi.RemoteNodeApi$11(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.setBlockchainNodeConnectionUsingPOSTValidateBeforeCall(network, domain, port, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }
    }
    RemoteNodeApi["__class"] = "io.nem.xpx.service.remote.RemoteNodeApi";
    RemoteNodeApi["__interfaces"] = ["io.nem.xpx.service.intf.NodeApi"];



    export namespace RemoteNodeApi {

        export class RemoteNodeApi$0 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteNodeApi$0["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteNodeApi$1 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteNodeApi$1["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteNodeApi$2 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteNodeApi$2["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class RemoteNodeApi$3 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteNodeApi$3["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteNodeApi$4 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteNodeApi$4["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteNodeApi$5 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteNodeApi$5["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class RemoteNodeApi$6 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteNodeApi$6["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteNodeApi$7 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteNodeApi$7["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteNodeApi$8 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteNodeApi$8["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class RemoteNodeApi$9 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteNodeApi$9["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteNodeApi$10 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteNodeApi$10["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteNodeApi$11 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteNodeApi$11["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];


    }

}
namespace io.nem.xpx.service.remote {
    /**
     * Instantiates a new remote publish and subscribe api.
     * 
     * @param {io.nem.ApiClient} apiClient the api client
     * @class
     */
    export class RemotePublishAndSubscribeApi implements io.nem.xpx.service.intf.PublishAndSubscribeApi {
        /**
         * The api client.
         */
        /*private*/ apiClient : io.nem.ApiClient;

        public constructor(apiClient : io.nem.ApiClient) {
            if(this.apiClient===undefined) this.apiClient = null;
            this.apiClient = apiClient;
        }

        /**
         * Gets the api client.
         * 
         * @return {io.nem.ApiClient} the api client
         */
        public getApiClient() : io.nem.ApiClient {
            return this.apiClient;
        }

        /**
         * Build call for publishTopicUsingGET.
         * 
         * @param {string} topic Topic (required)
         * @param {string} message Initial Message (optional)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public publishTopicUsingGETCall(topic : string, message : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/pubsub/init/{topic}".replace(new RegExp("\\{topic\\}", 'g'),this.apiClient.escapeString(topic.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            if(message != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "message", message));
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemotePublishAndSubscribeApi.RemotePublishAndSubscribeApi$0(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Publish topic using GET validate before call.
         * 
         * @param {string} topic the topic
         * @param {string} message the message
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the com.squareup.okhttp. call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ publishTopicUsingGETValidateBeforeCall(topic : string, message : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(topic == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'topic\' when calling publishTopicUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.publishTopicUsingGETCall(topic, message, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Publish and Subscribe. Make sure that the IPFS daemon has pubsub enabled.
         * Publish and Subscribe. Make sure that the IPFS daemon has pubsub enabled.
         * @param {string} topic Topic (required)
         * @param {string} message Initial Message (optional)
         * @return {*} Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public publishTopicUsingGET(topic : string, message : string) : any {
            let resp : io.nem.ApiResponse<any> = this.publishTopicUsingGETWithHttpInfo(topic, message);
            return resp.getData();
        }

        /**
         * Publish and Subscribe. Make sure that the IPFS daemon has pubsub enabled.
         * Publish and Subscribe. Make sure that the IPFS daemon has pubsub enabled.
         * @param {string} topic Topic (required)
         * @param {string} message Initial Message (optional)
         * @return {io.nem.ApiResponse} ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public publishTopicUsingGETWithHttpInfo(topic : string, message : string) : io.nem.ApiResponse<any> {
            let call : com.squareup.okhttp.Call = this.publishTopicUsingGETValidateBeforeCall(topic, message, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<any>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<any>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Publish and Subscribe. Make sure that the IPFS daemon has pubsub enabled. (asynchronously)
         * Publish and Subscribe. Make sure that the IPFS daemon has pubsub enabled.
         * @param {string} topic Topic (required)
         * @param {string} message Initial Message (optional)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public publishTopicUsingGETAsync(topic : string, message : string, callback : io.nem.ApiCallback<any>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemotePublishAndSubscribeApi.RemotePublishAndSubscribeApi$1(this, callback);
                progressRequestListener = new RemotePublishAndSubscribeApi.RemotePublishAndSubscribeApi$2(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.publishTopicUsingGETValidateBeforeCall(topic, message, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<any>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<any>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for sendToTopicUsingGET.
         * 
         * @param {string} topic Topic (required)
         * @param {string} message Initial Message (optional)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public sendToTopicUsingGETCall(topic : string, message : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/pubsub/send/to/{topic}".replace(new RegExp("\\{topic\\}", 'g'),this.apiClient.escapeString(topic.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            if(message != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "message", message));
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemotePublishAndSubscribeApi.RemotePublishAndSubscribeApi$3(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Send to topic using GET validate before call.
         * 
         * @param {string} topic the topic
         * @param {string} message the message
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the com.squareup.okhttp. call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ sendToTopicUsingGETValidateBeforeCall(topic : string, message : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(topic == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'topic\' when calling sendToTopicUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.sendToTopicUsingGETCall(topic, message, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Send a message to a published topic
         * Publish and Subscribe. Make sure that the IPFS daemon has pubsub enabled.
         * @param {string} topic Topic (required)
         * @param {string} message Initial Message (optional)
         * @return {*} Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public sendToTopicUsingGET(topic : string, message : string) : any {
            let resp : io.nem.ApiResponse<any> = this.sendToTopicUsingGETWithHttpInfo(topic, message);
            return resp.getData();
        }

        /**
         * Send a message to a published topic
         * Publish and Subscribe. Make sure that the IPFS daemon has pubsub enabled.
         * @param {string} topic Topic (required)
         * @param {string} message Initial Message (optional)
         * @return {io.nem.ApiResponse} ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public sendToTopicUsingGETWithHttpInfo(topic : string, message : string) : io.nem.ApiResponse<any> {
            let call : com.squareup.okhttp.Call = this.sendToTopicUsingGETValidateBeforeCall(topic, message, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<any>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<any>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Send a message to a published topic (asynchronously)
         * Publish and Subscribe. Make sure that the IPFS daemon has pubsub enabled.
         * @param {string} topic Topic (required)
         * @param {string} message Initial Message (optional)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public sendToTopicUsingGETAsync(topic : string, message : string, callback : io.nem.ApiCallback<any>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemotePublishAndSubscribeApi.RemotePublishAndSubscribeApi$4(this, callback);
                progressRequestListener = new RemotePublishAndSubscribeApi.RemotePublishAndSubscribeApi$5(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.sendToTopicUsingGETValidateBeforeCall(topic, message, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<any>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<any>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }
    }
    RemotePublishAndSubscribeApi["__class"] = "io.nem.xpx.service.remote.RemotePublishAndSubscribeApi";
    RemotePublishAndSubscribeApi["__interfaces"] = ["io.nem.xpx.service.intf.PublishAndSubscribeApi"];



    export namespace RemotePublishAndSubscribeApi {

        export class RemotePublishAndSubscribeApi$0 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemotePublishAndSubscribeApi$0["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemotePublishAndSubscribeApi$1 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemotePublishAndSubscribeApi$1["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemotePublishAndSubscribeApi$2 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemotePublishAndSubscribeApi$2["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class RemotePublishAndSubscribeApi$3 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemotePublishAndSubscribeApi$3["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemotePublishAndSubscribeApi$4 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemotePublishAndSubscribeApi$4["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemotePublishAndSubscribeApi$5 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemotePublishAndSubscribeApi$5["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];


    }

}
namespace io.nem.xpx.service.remote {
    /**
     * Instantiates a new remote transaction and announce api.
     * 
     * @param {io.nem.ApiClient} apiClient the api client
     * @class
     */
    export class RemoteTransactionAndAnnounceApi implements io.nem.xpx.service.intf.TransactionAndAnnounceApi {
        /**
         * The api client.
         */
        /*private*/ apiClient : io.nem.ApiClient;

        public constructor(apiClient : io.nem.ApiClient) {
            if(this.apiClient===undefined) this.apiClient = null;
            this.apiClient = apiClient;
        }

        /**
         * Gets the api client.
         * 
         * @return {io.nem.ApiClient} the api client
         */
        public getApiClient() : io.nem.ApiClient {
            return this.apiClient;
        }

        /**
         * Build call for announceRequestPublishDataSignatureUsingPOST.
         * 
         * @param {io.nem.xpx.model.RequestAnnounceDataSignature} requestAnnounceDataSignature The Request Announce Data Signature Json Format (optional)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public announceRequestPublishDataSignatureUsingPOSTCall(requestAnnounceDataSignature : io.nem.xpx.model.RequestAnnounceDataSignature, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = requestAnnounceDataSignature;
            let localVarPath : string = "/transaction/announce";
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["application/json"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteTransactionAndAnnounceApi.RemoteTransactionAndAnnounceApi$0(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Announce request publish data signature using POST validate before call.
         * 
         * @param {io.nem.xpx.model.RequestAnnounceDataSignature} requestAnnounceDataSignature the request announce data signature
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the com.squareup.okhttp. call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ announceRequestPublishDataSignatureUsingPOSTValidateBeforeCall(requestAnnounceDataSignature : io.nem.xpx.model.RequestAnnounceDataSignature, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let call : com.squareup.okhttp.Call = this.announceRequestPublishDataSignatureUsingPOSTCall(requestAnnounceDataSignature, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Announce the DataHash to NEM/P2P Storage and P2P Database
         * Endpoint that can be use to announce the data hash transaction. This will grab the signed BinaryTransaferTransaction and create the P2P Database Entry for the specific data hash / transaction.
         * @param {io.nem.xpx.model.RequestAnnounceDataSignature} requestAnnounceDataSignature The Request Announce Data Signature Json Format (optional)
         * @return {string} String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public announceRequestPublishDataSignatureUsingPOST(requestAnnounceDataSignature : io.nem.xpx.model.RequestAnnounceDataSignature) : string {
            let resp : io.nem.ApiResponse<string> = this.announceRequestPublishDataSignatureUsingPOSTWithHttpInfo(requestAnnounceDataSignature);
            return resp.getData();
        }

        /**
         * Announce the DataHash to NEM/P2P Storage and P2P Database
         * Endpoint that can be use to announce the data hash transaction. This will grab the signed BinaryTransaferTransaction and create the P2P Database Entry for the specific data hash / transaction.
         * @param {io.nem.xpx.model.RequestAnnounceDataSignature} requestAnnounceDataSignature The Request Announce Data Signature Json Format (optional)
         * @return {io.nem.ApiResponse} ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public announceRequestPublishDataSignatureUsingPOSTWithHttpInfo(requestAnnounceDataSignature : io.nem.xpx.model.RequestAnnounceDataSignature) : io.nem.ApiResponse<string> {
            let call : com.squareup.okhttp.Call = this.announceRequestPublishDataSignatureUsingPOSTValidateBeforeCall(requestAnnounceDataSignature, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Announce the DataHash to NEM/P2P Storage and P2P Database (asynchronously)
         * Endpoint that can be use to announce the data hash transaction. This will grab the signed BinaryTransaferTransaction and create the P2P Database Entry for the specific data hash / transaction.
         * @param {io.nem.xpx.model.RequestAnnounceDataSignature} requestAnnounceDataSignature The Request Announce Data Signature Json Format (optional)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public announceRequestPublishDataSignatureUsingPOSTAsync(requestAnnounceDataSignature : io.nem.xpx.model.RequestAnnounceDataSignature, callback : io.nem.ApiCallback<string>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteTransactionAndAnnounceApi.RemoteTransactionAndAnnounceApi$1(this, callback);
                progressRequestListener = new RemoteTransactionAndAnnounceApi.RemoteTransactionAndAnnounceApi$2(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.announceRequestPublishDataSignatureUsingPOSTValidateBeforeCall(requestAnnounceDataSignature, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for getXPXTransactionUsingGET.
         * 
         * @param {string} nemHash XPX Transaction Hash (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public getXPXTransactionUsingGETCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/transaction/get/{nemHash}".replace(new RegExp("\\{nemHash\\}", 'g'),this.apiClient.escapeString(nemHash.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["application/json"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteTransactionAndAnnounceApi.RemoteTransactionAndAnnounceApi$3(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Gets the XPX transaction using GET validate before call.
         * 
         * @param {string} nemHash the nem hash
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the XPX transaction using GET validate before call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ getXPXTransactionUsingGETValidateBeforeCall(nemHash : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(nemHash == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'nemHash\' when calling getXPXTransactionUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.getXPXTransactionUsingGETCall(nemHash, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Get the XPX Transaction Hash
         * Endpoint can be used to get XPX Transaction.
         * @param {string} nemHash XPX Transaction Hash (required)
         * @return {string} String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getXPXTransactionUsingGET(nemHash : string) : string {
            let resp : io.nem.ApiResponse<string> = this.getXPXTransactionUsingGETWithHttpInfo(nemHash);
            return resp.getData();
        }

        /**
         * Get the XPX Transaction Hash
         * Endpoint can be used to get XPX Transaction.
         * @param {string} nemHash XPX Transaction Hash (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public getXPXTransactionUsingGETWithHttpInfo(nemHash : string) : io.nem.ApiResponse<string> {
            let call : com.squareup.okhttp.Call = this.getXPXTransactionUsingGETValidateBeforeCall(nemHash, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Get the XPX Transaction Hash (asynchronously)
         * Endpoint can be used to get XPX Transaction.
         * @param {string} nemHash XPX Transaction Hash (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public getXPXTransactionUsingGETAsync(nemHash : string, callback : io.nem.ApiCallback<string>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteTransactionAndAnnounceApi.RemoteTransactionAndAnnounceApi$4(this, callback);
                progressRequestListener = new RemoteTransactionAndAnnounceApi.RemoteTransactionAndAnnounceApi$5(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.getXPXTransactionUsingGETValidateBeforeCall(nemHash, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }
    }
    RemoteTransactionAndAnnounceApi["__class"] = "io.nem.xpx.service.remote.RemoteTransactionAndAnnounceApi";
    RemoteTransactionAndAnnounceApi["__interfaces"] = ["io.nem.xpx.service.intf.TransactionAndAnnounceApi"];



    export namespace RemoteTransactionAndAnnounceApi {

        export class RemoteTransactionAndAnnounceApi$0 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteTransactionAndAnnounceApi$0["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteTransactionAndAnnounceApi$1 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteTransactionAndAnnounceApi$1["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteTransactionAndAnnounceApi$2 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteTransactionAndAnnounceApi$2["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class RemoteTransactionAndAnnounceApi$3 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteTransactionAndAnnounceApi$3["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteTransactionAndAnnounceApi$4 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteTransactionAndAnnounceApi$4["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteTransactionAndAnnounceApi$5 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteTransactionAndAnnounceApi$5["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];


    }

}
namespace io.nem.xpx.service.remote {
    /**
     * Instantiates a new remote upload api.
     * 
     * @param {io.nem.ApiClient} apiClient the api client
     * @class
     */
    export class RemoteUploadApi implements io.nem.xpx.service.intf.UploadApi {
        /**
         * The api client.
         */
        /*private*/ apiClient : io.nem.ApiClient;

        public constructor(apiClient : io.nem.ApiClient) {
            if(this.apiClient===undefined) this.apiClient = null;
            this.apiClient = apiClient;
        }

        /**
         * Gets the api client.
         * 
         * @return {io.nem.ApiClient} the api client
         */
        public getApiClient() : io.nem.ApiClient {
            return this.apiClient;
        }

        /**
         * Calls the garbage clean up and tries to unpin the given hash
         * This endpoint can be used to generates the datahash and uploads the file in the process.
         * @param {string} multihash The pinned multihash (required)
         * @return {string} String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public deletePinnedContent(multihash : string) : string {
            let localVarPostBody : any = null;
            let localVarPath : string = "/upload/cleanup";
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            if(multihash != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "multihash", multihash));
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["application/json"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            let localVarAuthNames : string[] = [];
            let call : com.squareup.okhttp.Call = this.apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<string>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<string>()).getType();
            let resp : io.nem.ApiResponse<string> = this.apiClient.execute<any>(call, localVarReturnType);
            return resp.getData();
        }

        /**
         * Uploads a Base64 encoded byte[] binary file to the IPFS/P2P Storage Network
         * This endpoint can be used to generate the data that will be injected to the NEM Blockchain.
         * @return {Array} Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @param {Array} binaryData
         * @param {string} name
         * @param {string} contentType
         * @param {string} keywords
         * @param {string} metadata
         */
        public uploadBytesBinary(binaryData : number[], name : string, contentType : string, keywords : string, metadata : string) : number[] {
            let localVarPostBody : io.nem.xpx.model.UploadBytesBinaryRequestParameter = new io.nem.xpx.model.UploadBytesBinaryRequestParameter().contentType(contentType).keywords(keywords).metadata(metadata).name(name).data(binaryData);
            let localVarPath : string = "/upload/bytes/binary";
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            let localVarAuthNames : string[] = [];
            let call : com.squareup.okhttp.Call = this.apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, /* emptyMap */{}, localVarAuthNames, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<number[]>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<number[]>()).getType();
            let response : io.nem.ApiResponse<number[]> = this.apiClient.execute<any>(call, localVarReturnType);
            return response.getData();
        }

        /**
         * Upload the Text to the IPFS/P2P Storage Network
         * This endpoint can be used to generate the data that will be injected to the NEM Blockchain.
         * @return {Array} Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @param {Array} textInBytes
         * @param {string} name
         * @param {string} contentType
         * @param {string} encoding
         * @param {string} keywords
         * @param {string} metadata
         */
        public uploadText(textInBytes : number[], name : string, contentType : string, encoding : string, keywords : string, metadata : string) : number[] {
            let localVarPostBody : io.nem.xpx.model.UploadTextRequestParameter = new io.nem.xpx.model.UploadTextRequestParameter().contentType(contentType).encoding(encoding).keywords(keywords).metadata(metadata).name(name).text(org.apache.commons.codec.binary.Base64.encodeBase64String(textInBytes));
            let localVarPath : string = "/upload/text";
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["*/*"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            let localVarAuthNames : string[] = [];
            let call : com.squareup.okhttp.Call = this.apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, /* emptyMap */{}, localVarAuthNames, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<any>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<any>()).getType();
            let response : io.nem.ApiResponse<number[]> = this.apiClient.execute<any>(call, localVarReturnType);
            return response.getData();
        }

        /**
         * 
         * @param {string} path
         * @param {string} name
         * @param {string} keywords
         * @param {string} metadata
         * @return {Array}
         */
        public uploadPath(path : string, name : string, keywords : string, metadata : string) : number[] {
            throw new io.nem.xpx.exceptions.PathUploadNotSupportedException("Path upload is not supported for remote upload");
        }
    }
    RemoteUploadApi["__class"] = "io.nem.xpx.service.remote.RemoteUploadApi";
    RemoteUploadApi["__interfaces"] = ["io.nem.xpx.service.intf.UploadApi"];


}
namespace io.nem.xpx.service {
    /**
     * Instantiates a new transaction announcer.
     * 
     * @param {io.nem.xpx.service.TransactionFeeCalculators} transactionFeeCalculators the transaction fee calculators
     * @param {io.nem.xpx.service.TransactionSender} transactionSender the transaction sender
     * @class
     */
    export class TransactionAnnouncer {
        /**
         * The transaction fee calculators.
         */
        /*private*/ transactionFeeCalculators : io.nem.xpx.service.TransactionFeeCalculators;

        /**
         * The transaction sender.
         */
        /*private*/ transactionSender : io.nem.xpx.service.TransactionSender;

        public constructor(transactionFeeCalculators : io.nem.xpx.service.TransactionFeeCalculators, transactionSender : io.nem.xpx.service.TransactionSender) {
            if(this.transactionFeeCalculators===undefined) this.transactionFeeCalculators = null;
            if(this.transactionSender===undefined) this.transactionSender = null;
            this.transactionFeeCalculators = transactionFeeCalculators;
            this.transactionSender = transactionSender;
        }

        /**
         * Announce transaction for uploaded content.
         * 
         * @param {org.nem.core.model.Message} nemMessage the nem message
         * @param {string} senderPrivateKey the sender private key
         * @param {string} receiverPublicKey the receiver public key
         * @param {Array} mosaics the mosaics
         * @return {string} the string
         * @throws Exception the exception
         */
        public announceTransactionForUploadedContent(nemMessage : org.nem.core.model.Message, senderPrivateKey : string, receiverPublicKey : string, mosaics : org.nem.core.model.mosaic.Mosaic[]) : string {
            let transferTransaction : org.nem.core.model.TransferTransaction = (o => o.addMosaics.apply(o, mosaics))(new io.nem.xpx.builder.TransferTransactionBuilder(this.transactionFeeCalculators).sender(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PrivateKey.fromHexString(senderPrivateKey)))).recipient(new org.nem.core.model.Account(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(receiverPublicKey)))).version(2).amount(org.nem.core.model.primitive.Amount.fromNem(1)).message(nemMessage)).buildAndSignTransaction();
            let announceResult : org.nem.core.model.ncc.NemAnnounceResult = this.transactionSender.sendTransferTransaction$org_nem_core_model_TransferTransaction(transferTransaction);
            if(announceResult.getCode() === org.nem.core.model.ncc.NemAnnounceResult.CODE_SUCCESS) return announceResult.getTransactionHash().toString(); else throw new io.nem.xpx.exceptions.AnnounceTransactionFailureException(java.lang.String.format("Announcement of Nem transaction failed: %s", announceResult.getMessage()));
        }
    }
    TransactionAnnouncer["__class"] = "io.nem.xpx.service.TransactionAnnouncer";

}
namespace io.nem.xpx.service {
    /**
     * Instantiates a new transaction fee calculators.
     * 
     * @param {io.nem.xpx.service.NemAccountApi} accountApi the account api
     * @param {io.nem.xpx.service.NemNamespaceAndMosaicsApi} namespaceMosaicApi the namespace mosaic api
     * @class
     */
    export class TransactionFeeCalculators {
        /**
         * The account api.
         */
        /*private*/ accountApi : io.nem.xpx.service.NemAccountApi;

        /**
         * The namespace mosaic api.
         */
        /*private*/ namespaceMosaicApi : io.nem.xpx.service.NemNamespaceAndMosaicsApi;

        public constructor(accountApi : io.nem.xpx.service.NemAccountApi, namespaceMosaicApi : io.nem.xpx.service.NemNamespaceAndMosaicsApi) {
            if(this.accountApi===undefined) this.accountApi = null;
            if(this.namespaceMosaicApi===undefined) this.namespaceMosaicApi = null;
            if(this.feeCalculator===undefined) this.feeCalculator = null;
            if(this.feeCalculatorMultiSig===undefined) this.feeCalculatorMultiSig = null;
            this.accountApi = accountApi;
            this.namespaceMosaicApi = namespaceMosaicApi;
        }

        /**
         * The fee calculator.
         */
        /*private*/ feeCalculator : org.nem.core.model.TransactionFeeCalculator;

        /**
         * The fee calculator multi sig.
         */
        /*private*/ feeCalculatorMultiSig : org.nem.core.model.TransactionFeeCalculator;

        public getFeeCalculator$() : org.nem.core.model.TransactionFeeCalculator {
            if(this.feeCalculator == null) this.feeCalculator = new org.nem.core.model.FeeUnitAwareTransactionFeeCalculator(org.nem.core.model.primitive.Amount.fromMicroNem(50000), <any>(this.mosaicInfoLookup()));
            return this.feeCalculator;
        }

        public getFeeCalculatorMultiSig$() : org.nem.core.model.TransactionFeeCalculator {
            if(this.feeCalculatorMultiSig == null) this.feeCalculatorMultiSig = new org.nem.core.model.FeeUnitAwareTransactionFeeCalculator(org.nem.core.model.primitive.Amount.fromMicroNem(50000), <any>(this.mosaicInfoLookup()));
            return this.feeCalculatorMultiSig;
        }

        public getFeeCalculator$java_lang_String(senderAddress : string) : org.nem.core.model.TransactionFeeCalculator {
            return new org.nem.core.model.FeeUnitAwareTransactionFeeCalculator(org.nem.core.model.primitive.Amount.fromMicroNem(50000), <any>(this.mosaicInfoLookupForSender(senderAddress)));
        }

        /**
         * Gets the fee calculator.
         * 
         * @param {string} senderAddress the sender address
         * @return {*} the fee calculator
         */
        public getFeeCalculator(senderAddress? : any) : any {
            if(((typeof senderAddress === 'string') || senderAddress === null)) {
                return <any>this.getFeeCalculator$java_lang_String(senderAddress);
            } else if(senderAddress === undefined) {
                return <any>this.getFeeCalculator$();
            } else throw new Error('invalid overload');
        }

        public getFeeCalculatorMultiSig$java_lang_String(senderAddress : string) : org.nem.core.model.TransactionFeeCalculator {
            return new org.nem.core.model.FeeUnitAwareTransactionFeeCalculator(org.nem.core.model.primitive.Amount.fromMicroNem(50000), <any>(this.mosaicInfoLookupForSender(senderAddress)));
        }

        /**
         * Gets the fee calculator multi sig.
         * 
         * @param {string} senderAddress the sender address
         * @return {*} the fee calculator multi sig
         */
        public getFeeCalculatorMultiSig(senderAddress? : any) : any {
            if(((typeof senderAddress === 'string') || senderAddress === null)) {
                return <any>this.getFeeCalculatorMultiSig$java_lang_String(senderAddress);
            } else if(senderAddress === undefined) {
                return <any>this.getFeeCalculatorMultiSig$();
            } else throw new Error('invalid overload');
        }

        /**
         * Mosaic info lookup.
         * 
         * @return {*} the mosaic fee information lookup
         * @private
         */
        /*private*/ mosaicInfoLookup() : org.nem.core.model.mosaic.MosaicFeeInformationLookup {
            return (id) => {
                if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(id.getName(),"xpx"))) {
                    return new org.nem.core.model.mosaic.MosaicFeeInformation(org.nem.core.model.primitive.Supply.fromValue(8999999999), 4);
                }
                let multiplier : number = /* parseInt */parseInt(id.getName().substring(4));
                let divisibilityChange : number = multiplier - 1;
                return new org.nem.core.model.mosaic.MosaicFeeInformation(org.nem.core.model.primitive.Supply.fromValue(100000000 * multiplier), 3 + divisibilityChange);
            };
        }

        /**
         * Mosaic info lookup for sender.
         * 
         * @param {string} sender the sender
         * @return {*} the mosaic fee information lookup
         * @private
         */
        /*private*/ mosaicInfoLookupForSender(sender : string) : org.nem.core.model.mosaic.MosaicFeeInformationLookup {
            return (id) => {
                let namespaceToLookup : string = id.getNamespaceId().getRoot().toString();
                let mosaicNameToLookup : string = id.getName();
                if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(namespaceToLookup,"nem")) && /* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(mosaicNameToLookup,"xem"))) return null;
                try {
                    {
                        let array174 = this.accountApi.getAccountOwnedMosaic(sender);
                        for(let index173=0; index173 < array174.length; index173++) {
                            let mosaic = array174[index173];
                            {
                                let namespace : string = mosaic.getMosaicId().getNamespaceId().getRoot().toString();
                                let mosaicName : string = mosaic.getMosaicId().getName();
                                if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(namespace,namespaceToLookup)) && /* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(mosaicName,mosaicNameToLookup))) {
                                    let mosaicDefinition : org.nem.core.model.mosaic.MosaicDefinition = this.namespaceMosaicApi.getMosaicInformation(namespace, mosaicName);
                                    return new org.nem.core.model.mosaic.MosaicFeeInformation(org.nem.core.model.primitive.Supply.fromValue(mosaicDefinition.getProperties().getInitialSupply()), mosaicDefinition.getProperties().getDivisibility());
                                }
                            }
                        }
                    }
                    throw new io.nem.xpx.exceptions.MosaicInformationNotFoundException("Mosaic not found on Sender");
                } catch(e) {
                    throw new io.nem.xpx.exceptions.MosaicInformationNotFoundException("Exception occured while getting Mosaic Information." + e.message);
                };
            };
        }
    }
    TransactionFeeCalculators["__class"] = "io.nem.xpx.service.TransactionFeeCalculators";

}
namespace io.nem.xpx.service {
    /**
     * Instantiates a new transaction sender.
     * 
     * @param {io.nem.xpx.service.NemTransactionApi} nemTransactionApi the nem transaction api
     * @param {io.nem.xpx.service.NemAccountApi} nemAccountApi the nem account api
     * @class
     */
    export class TransactionSender {
        /**
         * The Constant LOGGER.
         */
        /*private*/ nemTransactionApi : io.nem.xpx.service.NemTransactionApi;

        /**
         * The nem account api.
         */
        /*private*/ nemAccountApi : io.nem.xpx.service.NemAccountApi;

        public constructor(nemTransactionApi : io.nem.xpx.service.NemTransactionApi, nemAccountApi : io.nem.xpx.service.NemAccountApi) {
            if(this.nemTransactionApi===undefined) this.nemTransactionApi = null;
            if(this.nemAccountApi===undefined) this.nemAccountApi = null;
            this.nemTransactionApi = nemTransactionApi;
            this.nemAccountApi = nemAccountApi;
        }

        /**
         * Send transaction.
         * 
         * @param {org.nem.core.model.Transaction} transaction
         * the transaction
         * @throws ApiException
         * the api exception
         */
        public sendTransaction(transaction : org.nem.core.model.Transaction) {
            let data : number[] = org.nem.core.serialization.BinarySerializer.serializeToBytes(transaction.asNonVerifiable());
            let request : org.nem.core.model.ncc.RequestAnnounce = new org.nem.core.model.ncc.RequestAnnounce(data, transaction.getSignature().getBytes());
            let future : java.util.concurrent.CompletableFuture<org.nem.core.serialization.Deserializer> = this.nemTransactionApi.announceTransaction(request);
            try {
                future.thenAcceptAsync((d) => {
                    let result : org.nem.core.model.ncc.NemAnnounceResult = new org.nem.core.model.ncc.NemAnnounceResult(d);
                    switch((result.getCode())) {
                    case 1:
                        org.pmw.tinylog.Logger.info(javaemul.internal.StringHelper.format("successfully send xem " + result.getMessage()));
                        break;
                    default:
                        org.pmw.tinylog.Logger.info(javaemul.internal.StringHelper.format("could not send xem " + result.getMessage()));
                    }
                }).exceptionally((e) => {
                    org.pmw.tinylog.Logger.error("Error on uploading file data: " + e.message);
                    return null;
                }).get();
            } catch(e) {
                org.pmw.tinylog.Logger.error("Sending/Announcing Transfer Transaction: " + e.message);
            };
        }

        public sendTransferTransaction$org_nem_core_model_TransferTransaction(transaction : org.nem.core.model.TransferTransaction) : org.nem.core.model.ncc.NemAnnounceResult {
            this.checkAddressBalanceAgainstAmount(transaction.getSigner().getAddress().toString(), transaction.getAmount());
            let data : number[] = org.nem.core.serialization.BinarySerializer.serializeToBytes(transaction.asNonVerifiable());
            let request : org.nem.core.model.ncc.RequestAnnounce = new org.nem.core.model.ncc.RequestAnnounce(data, transaction.getSignature().getBytes());
            let future : java.util.concurrent.CompletableFuture<org.nem.core.serialization.Deserializer> = this.nemTransactionApi.announceTransaction(request);
            try {
                let transDes : org.nem.core.serialization.Deserializer = future.get();
                return new org.nem.core.model.ncc.NemAnnounceResult(transDes);
            } catch(e) {
                org.pmw.tinylog.Logger.error("Sending/Announcing Transfer Transaction: " + e.message);
            };
            return null;
        }

        public sendTransferTransaction$byte_A$byte_A(data : number[], signature : number[]) : org.nem.core.model.ncc.NemAnnounceResult {
            let request : org.nem.core.model.ncc.RequestAnnounce = new org.nem.core.model.ncc.RequestAnnounce(data, signature);
            let future : java.util.concurrent.CompletableFuture<org.nem.core.serialization.Deserializer> = this.nemTransactionApi.announceTransaction(request);
            try {
                let transDes : org.nem.core.serialization.Deserializer = future.get();
                return new org.nem.core.model.ncc.NemAnnounceResult(transDes);
            } catch(e) {
                org.pmw.tinylog.Logger.error("Error Occured: " + e.message);
            };
            return null;
        }

        /**
         * Send transfer transaction.
         * 
         * @param {Array} data
         * the data
         * @param {Array} signature
         * the signature
         * @return {org.nem.core.model.ncc.NemAnnounceResult} the nem announce result
         * @throws ApiException
         * the api exception
         */
        public sendTransferTransaction(data? : any, signature? : any) : any {
            if(((data != null && data instanceof <any>Array && (data.length==0 || data[0] == null ||(typeof data[0] === 'number'))) || data === null) && ((signature != null && signature instanceof <any>Array && (signature.length==0 || signature[0] == null ||(typeof signature[0] === 'number'))) || signature === null)) {
                return <any>this.sendTransferTransaction$byte_A$byte_A(data, signature);
            } else if(((data != null && data instanceof <any>org.nem.core.model.TransferTransaction) || data === null) && signature === undefined) {
                return <any>this.sendTransferTransaction$org_nem_core_model_TransferTransaction(data);
            } else throw new Error('invalid overload');
        }

        /**
         * Send future transfer transaction.
         * 
         * @param {org.nem.core.model.TransferTransaction} transaction            the transaction
         * @return {java.util.concurrent.CompletableFuture} the completable future
         * @throws ApiException             the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         * @throws InsufficientAmountException the insufficient amount exception
         */
        public sendFutureTransferTransaction(transaction : org.nem.core.model.TransferTransaction) : java.util.concurrent.CompletableFuture<org.nem.core.serialization.Deserializer> {
            this.checkAddressBalanceAgainstAmount(transaction.getSigner().getAddress().toString(), transaction.getAmount());
            let data : number[] = org.nem.core.serialization.BinarySerializer.serializeToBytes(transaction.asNonVerifiable());
            let request : org.nem.core.model.ncc.RequestAnnounce = new org.nem.core.model.ncc.RequestAnnounce(data, transaction.getSignature().getBytes());
            return this.nemTransactionApi.announceTransaction(request);
        }

        /**
         * Send multi sig transaction.
         * 
         * @param {org.nem.core.model.MultisigTransaction} transaction
         * the transaction
         * @return {org.nem.core.model.ncc.NemAnnounceResult} the nem announce result
         * @throws ApiException
         * the api exception
         */
        public sendMultisigTransaction(transaction : org.nem.core.model.MultisigTransaction) : org.nem.core.model.ncc.NemAnnounceResult {
            let data : number[] = org.nem.core.serialization.BinarySerializer.serializeToBytes(transaction.asNonVerifiable());
            let request : org.nem.core.model.ncc.RequestAnnounce = new org.nem.core.model.ncc.RequestAnnounce(data, transaction.getSignature().getBytes());
            let future : java.util.concurrent.CompletableFuture<org.nem.core.serialization.Deserializer> = this.nemTransactionApi.announceTransaction(request);
            try {
                let transDes : org.nem.core.serialization.Deserializer = future.get();
                return new org.nem.core.model.ncc.NemAnnounceResult(transDes);
            } catch(e) {
                org.pmw.tinylog.Logger.error("Error Occured: " + e.message);
            };
            return null;
        }

        /**
         * Send future multi sig transaction.
         * 
         * @param {org.nem.core.model.MultisigTransaction} transaction
         * the transaction
         * @return {java.util.concurrent.CompletableFuture} the completable future
         * @throws ApiException
         * the api exception
         */
        public sendFutureMultiSigTransaction(transaction : org.nem.core.model.MultisigTransaction) : java.util.concurrent.CompletableFuture<org.nem.core.serialization.Deserializer> {
            let data : number[] = org.nem.core.serialization.BinarySerializer.serializeToBytes(transaction.asNonVerifiable());
            let request : org.nem.core.model.ncc.RequestAnnounce = new org.nem.core.model.ncc.RequestAnnounce(data, transaction.getSignature().getBytes());
            return this.nemTransactionApi.announceTransaction(request);
        }

        /**
         * Send multisig signature transaction.
         * 
         * @param {org.nem.core.model.MultisigSignatureTransaction} transaction
         * the transaction
         * @return {org.nem.core.model.ncc.NemAnnounceResult} the nem announce result
         * @throws ApiException
         * the api exception
         */
        public sendMultisigSignatureTransaction(transaction : org.nem.core.model.MultisigSignatureTransaction) : org.nem.core.model.ncc.NemAnnounceResult {
            let data : number[] = org.nem.core.serialization.BinarySerializer.serializeToBytes(transaction.asNonVerifiable());
            let request : org.nem.core.model.ncc.RequestAnnounce = new org.nem.core.model.ncc.RequestAnnounce(data, transaction.getSignature().getBytes());
            let future : java.util.concurrent.CompletableFuture<org.nem.core.serialization.Deserializer> = this.nemTransactionApi.announceTransaction(request);
            try {
                let transDes : org.nem.core.serialization.Deserializer = future.get();
                return new org.nem.core.model.ncc.NemAnnounceResult(transDes);
            } catch(e) {
                org.pmw.tinylog.Logger.error("Error Occured: " + e.message);
            };
            return null;
        }

        /**
         * Send future multisig signature transaction.
         * 
         * @param {org.nem.core.model.MultisigSignatureTransaction} transaction
         * the transaction
         * @return {java.util.concurrent.CompletableFuture} the completable future
         * @throws ApiException
         * the api exception
         */
        public sendFutureMultisigSignatureTransaction(transaction : org.nem.core.model.MultisigSignatureTransaction) : java.util.concurrent.CompletableFuture<org.nem.core.serialization.Deserializer> {
            let data : number[] = org.nem.core.serialization.BinarySerializer.serializeToBytes(transaction.asNonVerifiable());
            let request : org.nem.core.model.ncc.RequestAnnounce = new org.nem.core.model.ncc.RequestAnnounce(data, transaction.getSignature().getBytes());
            return this.nemTransactionApi.announceTransaction(request);
        }

        /**
         * Check address balance against amount.
         * 
         * @param {string} address the address
         * @param {org.nem.core.model.primitive.Amount} amount the amount
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         * @throws ApiException the api exception
         * @throws InsufficientAmountException the insufficient amount exception
         * @private
         */
        /*private*/ checkAddressBalanceAgainstAmount(address : string, amount : org.nem.core.model.primitive.Amount) {
            let balance : number = this.nemAccountApi.getAccountByAddress(address).getEntity().getBalance().getNumNem();
            let transactionAmount : number = amount.getNumNem();
            if(balance < transactionAmount) {
                throw new io.nem.xpx.exceptions.InsufficientAmountException("Insufficient amount for Address: " + address + ". Balance: " + amount.getNumNem() + ". Transaction Amount: " + transactionAmount);
            }
        }
    }
    TransactionSender["__class"] = "io.nem.xpx.service.TransactionSender";

}
namespace io.nem.xpx.service {
    export class UploadDelegate {
        /*private*/ uploadApi : io.nem.xpx.service.intf.UploadApi;

        public constructor(uploadApi : io.nem.xpx.service.intf.UploadApi) {
            if(this.uploadApi===undefined) this.uploadApi = null;
            this.uploadApi = uploadApi;
        }

        public uploadBinaryToIpfs(binaryData : number[], name : string, contentType : string, keywords : string, metadata : string) : UploadDelegate.ResourceHashMessageWrapper {
            try {
                let resourceHashMessageData : number[] = this.uploadApi.uploadBytesBinary(binaryData, name, contentType, keywords, metadata);
                return new UploadDelegate.ResourceHashMessageWrapper(resourceHashMessageData);
            } catch(e) {
                throw new io.nem.xpx.exceptions.UploadContentFailureException("Failed to upload text to ipfs", e);
            };
        }

        public uploadTextToIpfs(textInBytes : number[], name : string, contentType : string, encoding : string, keywords : string, metadata : string) : UploadDelegate.ResourceHashMessageWrapper {
            try {
                let resourceHashMessageData : number[] = this.uploadApi.uploadText(textInBytes, name, contentType, encoding, keywords, metadata);
                return new UploadDelegate.ResourceHashMessageWrapper(resourceHashMessageData);
            } catch(e) {
                throw new io.nem.xpx.exceptions.UploadContentFailureException("Failed to upload text to ipfs", e);
            };
        }

        public uploadPathToIpfs(path : string, name : string, keywords : string, metadata : string) : UploadDelegate.ResourceHashMessageWrapper {
            try {
                let resourceHashMessageData : number[] = this.uploadApi.uploadPath(path, name, keywords, metadata);
                return new UploadDelegate.ResourceHashMessageWrapper(resourceHashMessageData);
            } catch(e) {
                throw new io.nem.xpx.exceptions.UploadContentFailureException("Failed to upload text to ipfs", e);
            };
        }

        public deletePinnedContent(multihash : string) : string {
            try {
                return this.uploadApi.deletePinnedContent(multihash);
            } catch(e) {
                throw new io.nem.xpx.exceptions.DeletePinnedContentFailureException(java.lang.String.format("Failed to delete pinned content for %s", multihash), e);
            };
        }
    }
    UploadDelegate["__class"] = "io.nem.xpx.service.UploadDelegate";


    export namespace UploadDelegate {

        export class ResourceHashMessageWrapper {
            data : number[];

            resourceHashMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage;

            public constructor(data : number[]) {
                if(this.data===undefined) this.data = null;
                if(this.resourceHashMessage===undefined) this.resourceHashMessage = null;
                this.data = data;
                this.resourceHashMessage = this.toResourceHashMessage(data);
            }

            public getData() : number[] {
                return this.data;
            }

            public getResourceHashMessage() : io.nem.xpx.service.model.buffers.ResourceHashMessage {
                return this.resourceHashMessage;
            }

            toResourceHashMessage(data : number[]) : io.nem.xpx.service.model.buffers.ResourceHashMessage {
                return io.nem.xpx.service.model.buffers.ResourceHashMessage.getRootAsResourceHashMessage$java_nio_ByteBuffer(java.nio.ByteBuffer.wrap(org.apache.commons.codec.binary.Base64.decodeBase64(data)));
            }
        }
        ResourceHashMessageWrapper["__class"] = "io.nem.xpx.service.UploadDelegate.ResourceHashMessageWrapper";

    }

}
namespace io.nem.xpx.strategy.privacy {
    /**
     * The Class PrivacyStrategy.
     * @class
     */
    export abstract class PrivacyStrategy {
        /**
         * Gets the nem message type.
         * 
         * @return {io.nem.xpx.model.NemMessageType} the nem message type
         */
        public abstract getNemMessageType() : io.nem.xpx.model.NemMessageType;

        /**
         * Encrypt.
         * 
         * @param {Array} data the data
         * @return {Array} the byte[]
         */
        public abstract encrypt(data : number[]) : number[];

        /**
         * Decrypt.
         * 
         * @param {Array} data the data
         * @param {org.nem.core.model.TransferTransaction} transaction the transaction
         * @param {io.nem.xpx.service.model.buffers.ResourceHashMessage} hashMessage the hash message
         * @return {Array} the byte[]
         */
        public abstract decrypt(data : number[], transaction : org.nem.core.model.TransferTransaction, hashMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage) : number[];

        /**
         * Encode to message.
         * 
         * @param {Array} payload the payload
         * @return {org.nem.core.model.Message} the message
         */
        public abstract encodeToMessage(payload : number[]) : org.nem.core.model.Message;

        /**
         * Decode transaction.
         * 
         * @param {org.nem.core.model.TransferTransaction} transaction the transaction
         * @return {Array} the byte[]
         */
        public abstract decodeTransaction(transaction : org.nem.core.model.TransferTransaction) : number[];
    }
    PrivacyStrategy["__class"] = "io.nem.xpx.strategy.privacy.PrivacyStrategy";

}
namespace io.nem.xpx.strategy.privacy {
    /**
     * A factory for creating PrivacyStrategy objects.
     * @class
     */
    export class PrivacyStrategyFactory {
        /**
         * The plain privacy strategy.
         */
        public static plainPrivacyStrategy : io.nem.xpx.strategy.privacy.PrivacyStrategy = null;

        constructor() {
        }

        /**
         * Plain privacy.
         * 
         * @return {io.nem.xpx.strategy.privacy.PrivacyStrategy} the privacy strategy
         */
        public static plainPrivacy() : io.nem.xpx.strategy.privacy.PrivacyStrategy {
            if(PrivacyStrategyFactory.plainPrivacyStrategy == null) PrivacyStrategyFactory.plainPrivacyStrategy = new io.nem.xpx.strategy.privacy.PlainPrivacyStrategy();
            return PrivacyStrategyFactory.plainPrivacyStrategy;
        }

        /**
         * Secured with nem keys privacy strategy.
         * 
         * @param {string} senderOrReceiverPrivateKey the sender or receiver private key
         * @param {string} receiverOrSenderPublicKey the receiver or sender public key
         * @return {io.nem.xpx.strategy.privacy.PrivacyStrategy} the privacy strategy
         */
        public static securedWithNemKeysPrivacyStrategy(senderOrReceiverPrivateKey : string, receiverOrSenderPublicKey : string) : io.nem.xpx.strategy.privacy.PrivacyStrategy {
            return new io.nem.xpx.strategy.privacy.SecuredWithNemKeysPrivacyStrategy(senderOrReceiverPrivateKey, receiverOrSenderPublicKey);
        }

        /**
         * Secured with password privacy strategy.
         * 
         * @param {string} password the password
         * @return {io.nem.xpx.strategy.privacy.PrivacyStrategy} the privacy strategy
         */
        public static securedWithPasswordPrivacyStrategy(password : string) : io.nem.xpx.strategy.privacy.PrivacyStrategy {
            return new io.nem.xpx.strategy.privacy.SecuredWithPasswordPrivacyStrategy(new io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption(), password);
        }

        public static securedWithShamirSecretSharingPrivacyStrategy(secretTotalPartCount : number, secretMinimumPartCountToBuild : number, secretParts : any) : io.nem.xpx.strategy.privacy.PrivacyStrategy {
            return new io.nem.xpx.strategy.privacy.SecuredWithShamirSecretSharingPrivacyStrategy(new io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption(), secretTotalPartCount, secretMinimumPartCountToBuild, secretParts);
        }
    }
    PrivacyStrategyFactory["__class"] = "io.nem.xpx.strategy.privacy.PrivacyStrategyFactory";

}
namespace io.nem.xpx.utils {
    /**
     * The Class ContentTypeUtils.
     * @class
     */
    export class ContentTypeUtils {
        /**
         * The Constant TIKA.
         */
        static TIKA : org.apache.tika.Tika; public static TIKA_$LI$() : org.apache.tika.Tika { if(ContentTypeUtils.TIKA == null) ContentTypeUtils.TIKA = new org.apache.tika.Tika(); return ContentTypeUtils.TIKA; };

        public static contentTypeLookup$java_lang_String$java_lang_String(contentType : string, content : string) : string {
            return io.nem.xpx.utils.StringUtils.isEmpty(contentType)?ContentTypeUtils.TIKA_$LI$().detect(content):contentType;
        }

        /**
         * Content type lookup.
         * 
         * @param {string} contentType the content type
         * @param {string} content the content
         * @return {string} the string
         */
        public static contentTypeLookup(contentType? : any, content? : any) : any {
            if(((typeof contentType === 'string') || contentType === null) && ((typeof content === 'string') || content === null)) {
                return <any>io.nem.xpx.utils.ContentTypeUtils.contentTypeLookup$java_lang_String$java_lang_String(contentType, content);
            } else if(((typeof contentType === 'string') || contentType === null) && ((content != null && content instanceof <any>Array && (content.length==0 || content[0] == null ||(typeof content[0] === 'number'))) || content === null)) {
                return <any>io.nem.xpx.utils.ContentTypeUtils.contentTypeLookup$java_lang_String$byte_A(contentType, content);
            } else throw new Error('invalid overload');
        }

        public static contentTypeLookup$java_lang_String$byte_A(contentType : string, content : number[]) : string {
            return io.nem.xpx.utils.StringUtils.isEmpty(contentType)?ContentTypeUtils.TIKA_$LI$().detect(content):contentType;
        }

        public static detectContentType$java_lang_String(content : string) : string {
            return io.nem.xpx.utils.StringUtils.isEmpty(content)?null:ContentTypeUtils.TIKA_$LI$().detect(content);
        }

        /**
         * Detect content type.
         * 
         * @param {string} content the content
         * @return {string} the string
         */
        public static detectContentType(content? : any) : any {
            if(((typeof content === 'string') || content === null)) {
                return <any>io.nem.xpx.utils.ContentTypeUtils.detectContentType$java_lang_String(content);
            } else if(((content != null && content instanceof <any>Array && (content.length==0 || content[0] == null ||(typeof content[0] === 'number'))) || content === null)) {
                return <any>io.nem.xpx.utils.ContentTypeUtils.detectContentType$byte_A(content);
            } else throw new Error('invalid overload');
        }

        public static detectContentType$byte_A(content : number[]) : string {
            return ContentTypeUtils.TIKA_$LI$().detect(content);
        }
    }
    ContentTypeUtils["__class"] = "io.nem.xpx.utils.ContentTypeUtils";

}
namespace io.nem.xpx.utils {
    /**
     * The Class CryptoUtil.
     * @class
     */
    export class CryptoUtils {
        /**
         * Encrypt.
         * 
         * @param {Array} binary the binary
         * @param {Array} password the password
         * @return {Array} the byte[]
         * @throws InvalidKeyException the invalid key exception
         * @throws InvalidKeySpecException the invalid key spec exception
         * @throws NoSuchAlgorithmException the no such algorithm exception
         * @throws NoSuchPaddingException the no such padding exception
         * @throws InvalidAlgorithmParameterException the invalid algorithm parameter exception
         * @throws IllegalBlockSizeException the illegal block size exception
         * @throws BadPaddingException the bad padding exception
         */
        public static encrypt(binary : number[], password : string[]) : number[] {
            let basicBinaryEncryptor : io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption = new io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption();
            return basicBinaryEncryptor.encrypt(binary, password);
        }

        /**
         * Encrypt to base 64 string.
         * 
         * @param {Array} binary the binary
         * @param {Array} password the password
         * @return {string} the string
         * @throws InvalidKeyException the invalid key exception
         * @throws InvalidKeySpecException the invalid key spec exception
         * @throws NoSuchAlgorithmException the no such algorithm exception
         * @throws NoSuchPaddingException the no such padding exception
         * @throws InvalidAlgorithmParameterException the invalid algorithm parameter exception
         * @throws IllegalBlockSizeException the illegal block size exception
         * @throws BadPaddingException the bad padding exception
         */
        public static encryptToBase64String(binary : number[], password : string[]) : string {
            let basicBinaryEncryptor : io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption = new io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption();
            return basicBinaryEncryptor.encryptToBase64String(binary, password);
        }

        /**
         * Decrypt.
         * 
         * @param {Array} binary the binary
         * @param {Array} password the password
         * @return {Array} the byte[]
         * @throws InvalidKeyException the invalid key exception
         * @throws InvalidAlgorithmParameterException the invalid algorithm parameter exception
         * @throws IllegalBlockSizeException the illegal block size exception
         * @throws BadPaddingException the bad padding exception
         * @throws InvalidKeySpecException the invalid key spec exception
         * @throws NoSuchAlgorithmException the no such algorithm exception
         * @throws NoSuchPaddingException the no such padding exception
         */
        public static decrypt(binary : number[], password : string[]) : number[] {
            let basicBinaryEncryptor : io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption = new io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption();
            return basicBinaryEncryptor.decrypt$byte_A$char_A(binary, password);
        }

        public static decryptToBase64String$byte_A$char_A(binary : number[], password : string[]) : string {
            let basicBinaryEncryptor : io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption = new io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption();
            return basicBinaryEncryptor.decryptToBase64String$byte_A$char_A(binary, password);
        }

        /**
         * Decrypt to base 64 string.
         * 
         * @param {Array} binary the binary
         * @param {Array} password the password
         * @return {string} the string
         * @throws InvalidKeyException the invalid key exception
         * @throws InvalidAlgorithmParameterException the invalid algorithm parameter exception
         * @throws IllegalBlockSizeException the illegal block size exception
         * @throws BadPaddingException the bad padding exception
         * @throws InvalidKeySpecException the invalid key spec exception
         * @throws NoSuchAlgorithmException the no such algorithm exception
         * @throws NoSuchPaddingException the no such padding exception
         */
        public static decryptToBase64String(binary? : any, password? : any) : any {
            if(((binary != null && binary instanceof <any>Array && (binary.length==0 || binary[0] == null ||(typeof binary[0] === 'number'))) || binary === null) && ((password != null && password instanceof <any>Array && (password.length==0 || password[0] == null ||(typeof password[0] === 'string'))) || password === null)) {
                return <any>io.nem.xpx.utils.CryptoUtils.decryptToBase64String$byte_A$char_A(binary, password);
            } else if(((typeof binary === 'string') || binary === null) && ((password != null && password instanceof <any>Array && (password.length==0 || password[0] == null ||(typeof password[0] === 'string'))) || password === null)) {
                return <any>io.nem.xpx.utils.CryptoUtils.decryptToBase64String$java_lang_String$char_A(binary, password);
            } else throw new Error('invalid overload');
        }

        public static decryptToBase64String$java_lang_String$char_A(cipherEncryptedText : string, password : string[]) : string {
            let basicBinaryEncryptor : io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption = new io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption();
            return basicBinaryEncryptor.decryptToBase64String$java_lang_String$char_A(cipherEncryptedText, password);
        }
    }
    CryptoUtils["__class"] = "io.nem.xpx.utils.CryptoUtils";

}
namespace io.nem.xpx.utils {
    /**
     * Utility class for handling JSON serialization and deserialization.
     * 
     * @class
     */
    export class JsonUtils {
        /**
         * Gson which handles the JSON conversion.
         */
        static gson : com.google.gson.Gson = null;

        constructor() {
        }

        /**
         * Initializes the current Gson object if null and returns it. The Gson
         * object has custom adapters to manage datatypes according to Facebook
         * formats.
         * 
         * @return {com.google.gson.Gson} the current instance of Gson.
         * @private
         */
        /*private*/ static getGson() : com.google.gson.Gson {
            if(JsonUtils.gson == null) {
                let builder : com.google.gson.GsonBuilder = new com.google.gson.GsonBuilder();
                JsonUtils.gson = builder.create();
            }
            return JsonUtils.gson;
        }

        /**
         * From json.
         * 
         * @param <T>
         * the generic type
         * @param {string} json
         * the string from which the object is to be deserialized.
         * @param {*} T
         * the type of the desired object.
         * @return {*} an object of type T from the string. Returns null if json is
         * null.
         * @see Gson#fromJson(String, Class)
         */
        public static fromJson<T>(json : string, T : any) : T {
            return <any>(JsonUtils.getGson().fromJson<any>(json, T));
        }

        /**
         * To json.
         * 
         * @param {*} src
         * the object for which Json representation is to be created
         * setting for Gson .
         * @return {string} Json representation of src.
         * @see Gson#toJson(Object)
         */
        public static toJson(src : any) : string {
            return JsonUtils.getGson().toJson(src);
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            return "JsonUtils []";
        }
    }
    JsonUtils["__class"] = "io.nem.xpx.utils.JsonUtils";

}
namespace io.nem.xpx.utils {
    /**
     * The Class KeyUtils.
     * @class
     */
    export class KeyUtils {
        /**
         * get address from private key.
         * 
         * @param {string} privateKeyString the private key string
         * @return {string} the address from private key
         */
        public static getAddressFromPrivateKey(privateKeyString : string) : string {
            let privateKey : org.nem.core.crypto.PrivateKey = org.nem.core.crypto.PrivateKey.fromHexString(privateKeyString);
            let keyPair : org.nem.core.crypto.KeyPair = new org.nem.core.crypto.KeyPair(privateKey);
            return org.nem.core.model.Address.fromPublicKey(keyPair.getPublicKey()).toString();
        }

        /**
         * get public key from private key.
         * 
         * @param {string} privateKeyString the private key string
         * @return {string} the public from private key
         */
        public static getPublicFromPrivateKey(privateKeyString : string) : string {
            let privateKey : org.nem.core.crypto.PrivateKey = org.nem.core.crypto.PrivateKey.fromHexString(privateKeyString);
            let keyPair : org.nem.core.crypto.KeyPair = new org.nem.core.crypto.KeyPair(privateKey);
            return keyPair.getPublicKey().toString();
        }

        /**
         * get address from public key.
         * 
         * @param {string} publicKeyString the public key string
         * @return {string} the address from public key
         */
        public static getAddressFromPublicKey(publicKeyString : string) : string {
            let publicKey : org.nem.core.crypto.PublicKey = org.nem.core.crypto.PublicKey.fromHexString(publicKeyString);
            let address : org.nem.core.model.Address = org.nem.core.model.Address.fromPublicKey(publicKey);
            return address.toString();
        }
    }
    KeyUtils["__class"] = "io.nem.xpx.utils.KeyUtils";

}
namespace io.nem.xpx.utils {
    /**
     * The Class ParameterValidationUtils.
     * @class
     */
    export class ParameterValidationUtils {
        constructor() {
        }

        /**
         * Check parameter.
         * 
         * @param {boolean} isValid the is valid
         * @param {string} invalidMessage the invalid message
         */
        public static checkParameter(isValid : boolean, invalidMessage : string) {
            if(!isValid) throw Object.defineProperty(new Error(invalidMessage), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.IllegalArgumentException','java.lang.Exception'] });
        }
    }
    ParameterValidationUtils["__class"] = "io.nem.xpx.utils.ParameterValidationUtils";

}
namespace io.nem.xpx.utils {
    /**
     * The Class ScannerUtils.
     * @class
     */
    export class ScannerUtils {
        /**
         * exit when enter string "exit".
         */
        public static monitorExit() {
            let scanner : java.util.Scanner = new java.util.Scanner(java.lang.System.in);
            try {
                while((true)) {
                    let line : string = scanner.nextLine();
                    if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })("exit",line))) {
                        break;
                    }
                };
            } catch(ex) {
            } finally {
                scanner.close();
            };
        }
    }
    ScannerUtils["__class"] = "io.nem.xpx.utils.ScannerUtils";

}
namespace io.nem.xpx.utils {
    /**
     * The Class StringUtils.
     * @class
     */
    export class StringUtils {
        /**
         * Check if the given array contains the given value (with case-insensitive comparison).
         * 
         * @param {Array} array The array
         * @param {string} value The value to search
         * @return {boolean} true if the array contains the value
         */
        public static containsIgnoreCase(array : string[], value : string) : boolean {
            for(let index175=0; index175 < array.length; index175++) {
                let str = array[index175];
                {
                    if(value == null && str == null) return true;
                    if(value != null && /* equalsIgnoreCase */((o1, o2) => o1.toUpperCase() === (o2===null?o2:o2.toUpperCase()))(value, str)) return true;
                }
            }
            return false;
        }

        /**
         * Join an array of strings with the given separator.
         * <p>
         * Note: This might be replaced by utility method from commons-lang or guava someday
         * if one of those libraries is added as dependency.
         * </p>
         * 
         * @param {Array} array     The array of strings
         * @param {string} separator The separator
         * @return {string} the resulting string
         */
        public static join(array : string[], separator : string) : string {
            let len : number = array.length;
            if(len === 0) return "";
            let out : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>array[0]); return sb; })(out);
            for(let i : number = 1; i < len; i++) {
                /* append */(sb => { sb.str = sb.str.concat(<any>array[i]); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>separator); return sb; })(out));
            };
            return /* toString */out.str;
        }

        /**
         * Checks if is empty.
         * 
         * @param {string} str the str
         * @return {boolean} true, if is empty
         */
        public static isEmpty(str : string) : boolean {
            return null == str || /* isEmpty */(str.length === 0);
        }
    }
    StringUtils["__class"] = "io.nem.xpx.utils.StringUtils";

}
namespace io.nem.xpx.websockets {
    /**
     * Instantiates a new confirmed transaction web socket client.
     * 
     * @param {java.net.URI} serverUri
     * the server uri
     * @param {org.java_websocket.drafts.Draft} draft
     * the draft
     * @class
     * @extends org.java_websocket.client.WebSocketClient
     */
    export class ConfirmedTransactionWebSocketClient extends org.java_websocket.client.WebSocketClient {
        /**
         * The logger.
         */
        LOGGER : java.util.logging.Logger;

        public constructor(serverUri? : any, draft? : any) {
            if(((serverUri != null && serverUri instanceof <any>java.net.URI) || serverUri === null) && ((draft != null && draft instanceof <any>org.java_websocket.drafts.Draft) || draft === null)) {
                let __args = Array.prototype.slice.call(arguments);
                super(serverUri, draft);
                this.LOGGER = java.util.logging.Logger.getAnonymousLogger();
            } else if(((serverUri != null && serverUri instanceof <any>java.net.URI) || serverUri === null) && draft === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                super(serverUri);
                this.LOGGER = java.util.logging.Logger.getAnonymousLogger();
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {number} arg0
         * @param {string} arg1
         * @param {boolean} arg2
         */
        public onClose(arg0 : number, arg1 : string, arg2 : boolean) {
            this.LOGGER.info("onClose connection " + arg0);
            this.LOGGER.info("onClose connection " + arg1);
            this.LOGGER.info("onClose connection " + arg2);
        }

        /**
         * 
         * @param {Error} arg0
         */
        public onError(arg0 : Error) {
            this.LOGGER.info("onError connection" + arg0.message);
        }

        /**
         * 
         * @param {string} arg0
         */
        public onMessage(arg0 : string) {
            this.LOGGER.info("onMessage connection");
        }

        /**
         * 
         * @param {*} arg0
         */
        public onOpen(arg0 : org.java_websocket.handshake.ServerHandshake) {
            this.LOGGER.info("opened connection");
        }

        /**
         * The main method.
         * 
         * @param {Array} args
         * the arguments
         * @throws URISyntaxException
         * the URI syntax exception
         * @throws InterruptedException
         * the interrupted exception
         */
        public static main(args : string[]) {
            let c : ConfirmedTransactionWebSocketClient = new ConfirmedTransactionWebSocketClient(new java.net.URI("ws://23.228.67.85:7778/w/api/account/get"));
            c.connect();
            c.send("{\"account\":\"TDZQB4XV6ZQ3X7PXGWYL4KWEY7DY2RGSLIN7PA3F\"}");
        }
    }
    ConfirmedTransactionWebSocketClient["__class"] = "io.nem.xpx.websockets.ConfirmedTransactionWebSocketClient";
    ConfirmedTransactionWebSocketClient["__interfaces"] = ["org.java_websocket.WebSocket","org.java_websocket.WebSocketListener","java.lang.Runnable"];


}
namespace io.nem.xpx.websockets {
    /**
     * Instantiates a new unconfirmed transaction web socket client.
     * 
     * @param {java.net.URI} serverUri the server uri
     * @class
     * @extends org.java_websocket.client.WebSocketClient
     */
    export class UnconfirmedTransactionWebSocketClient extends org.java_websocket.client.WebSocketClient {
        public constructor(serverUri : java.net.URI) {
            super(serverUri);
        }

        /**
         * 
         * @param {number} arg0
         * @param {string} arg1
         * @param {boolean} arg2
         */
        public onClose(arg0 : number, arg1 : string, arg2 : boolean) {
        }

        /**
         * 
         * @param {Error} arg0
         */
        public onError(arg0 : Error) {
        }

        /**
         * 
         * @param {string} arg0
         */
        public onMessage(arg0 : string) {
        }

        /**
         * 
         * @param {*} arg0
         */
        public onOpen(arg0 : org.java_websocket.handshake.ServerHandshake) {
        }
    }
    UnconfirmedTransactionWebSocketClient["__class"] = "io.nem.xpx.websockets.UnconfirmedTransactionWebSocketClient";
    UnconfirmedTransactionWebSocketClient["__interfaces"] = ["org.java_websocket.WebSocket","org.java_websocket.WebSocketListener","java.lang.Runnable"];


}
namespace io.nem.xpx.adapters.cipher {
    /**
     * The Class BinaryPBKDF2Cipher.
     * @class
     * @extends io.nem.xpx.adapters.cipher.SymmetricKeyEncryption
     */
    export class BinaryPBKDF2CipherEncryption extends io.nem.xpx.adapters.cipher.SymmetricKeyEncryption {
        /**
         * The Constant CONST_ALGO_PBKDF2.
         */
        static CONST_ALGO_PBKDF2 : string = "PBKDF2WithHmacSHA256";

        /**
         * The Constant SALT.
         */
        static SALT : number[]; public static SALT_$LI$() : number[] { if(BinaryPBKDF2CipherEncryption.SALT == null) BinaryPBKDF2CipherEncryption.SALT = [(<number>169|0), (<number>155|0), (<number>200|0), (<number>50|0), (<number>86|0), (<number>53|0), (<number>227|0), (<number>3|0)]; return BinaryPBKDF2CipherEncryption.SALT; };

        /**
         * The Constant FIXED_NONCE.
         */
        static FIXED_NONCE : number[]; public static FIXED_NONCE_$LI$() : number[] { if(BinaryPBKDF2CipherEncryption.FIXED_NONCE == null) BinaryPBKDF2CipherEncryption.FIXED_NONCE = [(<number>169|0), (<number>155|0), (<number>200|0), (<number>50|0), (<number>86|0), (<number>53|0), (<number>227|0), (<number>3|0)]; return BinaryPBKDF2CipherEncryption.FIXED_NONCE; };

        /**
         * Encrypt.
         * 
         * @param {Array} binary the binary
         * @param {Array} password the password
         * @return {Array} the byte[]
         * @throws InvalidKeySpecException the invalid key spec exception
         * @throws NoSuchAlgorithmException the no such algorithm exception
         * @throws NoSuchPaddingException the no such padding exception
         * @throws InvalidKeyException the invalid key exception
         * @throws InvalidAlgorithmParameterException the invalid algorithm parameter exception
         * @throws IllegalBlockSizeException the illegal block size exception
         * @throws BadPaddingException the bad padding exception
         */
        public encrypt(binary : number[], password : string[]) : number[] {
            let factory : javax.crypto.SecretKeyFactory = javax.crypto.SecretKeyFactory.getInstance(BinaryPBKDF2CipherEncryption.CONST_ALGO_PBKDF2);
            let keyspec : java.security.spec.KeySpec = new javax.crypto.spec.PBEKeySpec(password, BinaryPBKDF2CipherEncryption.SALT_$LI$(), 65536, 128);
            let tmp : javax.crypto.SecretKey = factory.generateSecret(keyspec);
            let key : javax.crypto.SecretKey = new javax.crypto.spec.SecretKeySpec(tmp.getEncoded(), "AES");
            let cipher : javax.crypto.Cipher = javax.crypto.Cipher.getInstance("AES/GCM/NoPadding");
            let spec : javax.crypto.spec.GCMParameterSpec = new javax.crypto.spec.GCMParameterSpec(16 * 8, BinaryPBKDF2CipherEncryption.FIXED_NONCE_$LI$());
            cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, key, spec);
            let byteCipher : number[] = cipher.doFinal(binary);
            return byteCipher;
        }

        /**
         * Encrypt to base 64 string.
         * 
         * @param {Array} binary the binary
         * @param {Array} password the password
         * @return {string} the string
         * @throws InvalidKeySpecException the invalid key spec exception
         * @throws NoSuchAlgorithmException the no such algorithm exception
         * @throws NoSuchPaddingException the no such padding exception
         * @throws InvalidKeyException the invalid key exception
         * @throws InvalidAlgorithmParameterException the invalid algorithm parameter exception
         * @throws IllegalBlockSizeException the illegal block size exception
         * @throws BadPaddingException the bad padding exception
         */
        public encryptToBase64String(binary : number[], password : string[]) : string {
            let factory : javax.crypto.SecretKeyFactory = javax.crypto.SecretKeyFactory.getInstance(BinaryPBKDF2CipherEncryption.CONST_ALGO_PBKDF2);
            let keyspec : java.security.spec.KeySpec = new javax.crypto.spec.PBEKeySpec(password, BinaryPBKDF2CipherEncryption.SALT_$LI$(), 65536, 128);
            let tmp : javax.crypto.SecretKey = factory.generateSecret(keyspec);
            let key : javax.crypto.SecretKey = new javax.crypto.spec.SecretKeySpec(tmp.getEncoded(), "AES");
            let cipher : javax.crypto.Cipher = javax.crypto.Cipher.getInstance("AES/GCM/NoPadding");
            let spec : javax.crypto.spec.GCMParameterSpec = new javax.crypto.spec.GCMParameterSpec(16 * 8, BinaryPBKDF2CipherEncryption.FIXED_NONCE_$LI$());
            cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, key, spec);
            let byteCipher : number[] = cipher.doFinal(binary);
            let cipherText : string = String.fromCharCode.apply(null, java.util.Base64.getEncoder().encode(byteCipher));
            return cipherText;
        }

        public decrypt$java_lang_String$char_A(encodedCipherText : string, password : string[]) : number[] {
            let factory : javax.crypto.SecretKeyFactory = javax.crypto.SecretKeyFactory.getInstance(BinaryPBKDF2CipherEncryption.CONST_ALGO_PBKDF2);
            let keyspec : java.security.spec.KeySpec = new javax.crypto.spec.PBEKeySpec(password, BinaryPBKDF2CipherEncryption.SALT_$LI$(), 65536, 128);
            let tmp : javax.crypto.SecretKey = factory.generateSecret(keyspec);
            let key : javax.crypto.SecretKey = new javax.crypto.spec.SecretKeySpec(tmp.getEncoded(), "AES");
            let cipher : javax.crypto.Cipher = javax.crypto.Cipher.getInstance("AES/GCM/NoPadding");
            let spec : javax.crypto.spec.GCMParameterSpec = new javax.crypto.spec.GCMParameterSpec(16 * 8, BinaryPBKDF2CipherEncryption.FIXED_NONCE_$LI$());
            cipher.init(javax.crypto.Cipher.DECRYPT_MODE, key, spec);
            let decryptedCipher : number[] = cipher.doFinal(java.util.Base64.getDecoder().decode(encodedCipherText));
            return decryptedCipher;
        }

        /**
         * Decrypt.
         * 
         * @param {string} encodedCipherText the encoded cipher text
         * @param {Array} password the password
         * @return {Array} the byte[]
         * @throws InvalidKeyException the invalid key exception
         * @throws InvalidAlgorithmParameterException the invalid algorithm parameter exception
         * @throws IllegalBlockSizeException the illegal block size exception
         * @throws BadPaddingException the bad padding exception
         * @throws InvalidKeySpecException the invalid key spec exception
         * @throws NoSuchAlgorithmException the no such algorithm exception
         * @throws NoSuchPaddingException the no such padding exception
         */
        public decrypt(encodedCipherText? : any, password? : any) : any {
            if(((typeof encodedCipherText === 'string') || encodedCipherText === null) && ((password != null && password instanceof <any>Array && (password.length==0 || password[0] == null ||(typeof password[0] === 'string'))) || password === null)) {
                return <any>this.decrypt$java_lang_String$char_A(encodedCipherText, password);
            } else if(((encodedCipherText != null && encodedCipherText instanceof <any>Array && (encodedCipherText.length==0 || encodedCipherText[0] == null ||(typeof encodedCipherText[0] === 'number'))) || encodedCipherText === null) && ((password != null && password instanceof <any>Array && (password.length==0 || password[0] == null ||(typeof password[0] === 'string'))) || password === null)) {
                return <any>this.decrypt$byte_A$char_A(encodedCipherText, password);
            } else throw new Error('invalid overload');
        }

        public decryptToBase64String$java_lang_String$char_A(encodedCipherText : string, password : string[]) : string {
            let factory : javax.crypto.SecretKeyFactory = javax.crypto.SecretKeyFactory.getInstance(BinaryPBKDF2CipherEncryption.CONST_ALGO_PBKDF2);
            let keyspec : java.security.spec.KeySpec = new javax.crypto.spec.PBEKeySpec(password, BinaryPBKDF2CipherEncryption.SALT_$LI$(), 65536, 128);
            let tmp : javax.crypto.SecretKey = factory.generateSecret(keyspec);
            let key : javax.crypto.SecretKey = new javax.crypto.spec.SecretKeySpec(tmp.getEncoded(), "AES");
            let cipher : javax.crypto.Cipher = javax.crypto.Cipher.getInstance("AES/GCM/NoPadding");
            let spec : javax.crypto.spec.GCMParameterSpec = new javax.crypto.spec.GCMParameterSpec(16 * 8, BinaryPBKDF2CipherEncryption.FIXED_NONCE_$LI$());
            cipher.init(javax.crypto.Cipher.DECRYPT_MODE, key, spec);
            let decryptedCipher : number[] = cipher.doFinal(java.util.Base64.getDecoder().decode(encodedCipherText));
            let decryptedCipherText : string = String.fromCharCode.apply(null, decryptedCipher);
            return decryptedCipherText;
        }

        /**
         * Decrypt to base 64 string.
         * 
         * @param {string} encodedCipherText the encoded cipher text
         * @param {Array} password the password
         * @return {string} the string
         * @throws InvalidKeyException the invalid key exception
         * @throws InvalidAlgorithmParameterException the invalid algorithm parameter exception
         * @throws IllegalBlockSizeException the illegal block size exception
         * @throws BadPaddingException the bad padding exception
         * @throws InvalidKeySpecException the invalid key spec exception
         * @throws NoSuchAlgorithmException the no such algorithm exception
         * @throws NoSuchPaddingException the no such padding exception
         */
        public decryptToBase64String(encodedCipherText? : any, password? : any) : any {
            if(((typeof encodedCipherText === 'string') || encodedCipherText === null) && ((password != null && password instanceof <any>Array && (password.length==0 || password[0] == null ||(typeof password[0] === 'string'))) || password === null)) {
                return <any>this.decryptToBase64String$java_lang_String$char_A(encodedCipherText, password);
            } else if(((encodedCipherText != null && encodedCipherText instanceof <any>Array && (encodedCipherText.length==0 || encodedCipherText[0] == null ||(typeof encodedCipherText[0] === 'number'))) || encodedCipherText === null) && ((password != null && password instanceof <any>Array && (password.length==0 || password[0] == null ||(typeof password[0] === 'string'))) || password === null)) {
                return <any>this.decryptToBase64String$byte_A$char_A(encodedCipherText, password);
            } else throw new Error('invalid overload');
        }

        public decrypt$byte_A$char_A(binary : number[], password : string[]) : number[] {
            let factory : javax.crypto.SecretKeyFactory = javax.crypto.SecretKeyFactory.getInstance(BinaryPBKDF2CipherEncryption.CONST_ALGO_PBKDF2);
            let keyspec : java.security.spec.KeySpec = new javax.crypto.spec.PBEKeySpec(password, BinaryPBKDF2CipherEncryption.SALT_$LI$(), 65536, 128);
            let tmp : javax.crypto.SecretKey = factory.generateSecret(keyspec);
            let key : javax.crypto.SecretKey = new javax.crypto.spec.SecretKeySpec(tmp.getEncoded(), "AES");
            let cipher : javax.crypto.Cipher = javax.crypto.Cipher.getInstance("AES/GCM/NoPadding");
            let spec : javax.crypto.spec.GCMParameterSpec = new javax.crypto.spec.GCMParameterSpec(16 * 8, BinaryPBKDF2CipherEncryption.FIXED_NONCE_$LI$());
            cipher.init(javax.crypto.Cipher.DECRYPT_MODE, key, spec);
            let decryptedCipher : number[] = cipher.doFinal(binary);
            return decryptedCipher;
        }

        public decryptToBase64String$byte_A$char_A(binary : number[], password : string[]) : string {
            let factory : javax.crypto.SecretKeyFactory = javax.crypto.SecretKeyFactory.getInstance(BinaryPBKDF2CipherEncryption.CONST_ALGO_PBKDF2);
            let keyspec : java.security.spec.KeySpec = new javax.crypto.spec.PBEKeySpec(password, BinaryPBKDF2CipherEncryption.SALT_$LI$(), 65536, 128);
            let tmp : javax.crypto.SecretKey = factory.generateSecret(keyspec);
            let key : javax.crypto.SecretKey = new javax.crypto.spec.SecretKeySpec(tmp.getEncoded(), "AES");
            let cipher : javax.crypto.Cipher = javax.crypto.Cipher.getInstance("AES/GCM/NoPadding");
            let spec : javax.crypto.spec.GCMParameterSpec = new javax.crypto.spec.GCMParameterSpec(16 * 8, BinaryPBKDF2CipherEncryption.FIXED_NONCE_$LI$());
            cipher.init(javax.crypto.Cipher.DECRYPT_MODE, key, spec);
            let decryptedCipher : number[] = cipher.doFinal(binary);
            let decryptedCipherText : string = String.fromCharCode.apply(null, decryptedCipher);
            return decryptedCipherText;
        }

        constructor() {
            super();
        }
    }
    BinaryPBKDF2CipherEncryption["__class"] = "io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption";
    BinaryPBKDF2CipherEncryption["__interfaces"] = ["io.nem.xpx.adapters.cipher.CustomEncryption"];


}
namespace io.nem.xpx.facade.account {
    /**
     * Instantiates a new account async.
     * 
     * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection the peer connection
     * @param {string} publicKey the public key
     * @class
     * @extends io.nem.xpx.facade.AbstractAsyncFacadeService
     */
    export class AccountAsync extends io.nem.xpx.facade.AbstractAsyncFacadeService {
        /**
         * The account.
         */
        /*private*/ account : io.nem.xpx.facade.account.Account;

        public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection, publicKey : string) {
            super();
            if(this.account===undefined) this.account = null;
            this.account = new io.nem.xpx.facade.account.Account(peerConnection, publicKey);
        }

        /**
         * Gets the incoming transactions.
         * 
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the incoming transactions
         */
        public getIncomingTransactions(callback : io.nem.xpx.callback.ServiceAsyncCallback<Array<org.nem.core.model.ncc.TransactionMetaDataPair>>) : java.util.concurrent.CompletableFuture<Array<org.nem.core.model.ncc.TransactionMetaDataPair>> {
            return this.runAsync<any>(() => {
                try {
                    return this.account.getIncomingTransactions();
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Gets the all transactions.
         * 
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the all transactions
         */
        public getAllTransactions(callback : io.nem.xpx.callback.ServiceAsyncCallback<Array<org.nem.core.model.ncc.TransactionMetaDataPair>>) : java.util.concurrent.CompletableFuture<Array<org.nem.core.model.ncc.TransactionMetaDataPair>> {
            return this.runAsync<any>(() => {
                try {
                    return this.account.getAllTransactions();
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Gets the outgoing transactions.
         * 
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the outgoing transactions
         */
        public getOutgoingTransactions(callback : io.nem.xpx.callback.ServiceAsyncCallback<Array<org.nem.core.model.ncc.TransactionMetaDataPair>>) : java.util.concurrent.CompletableFuture<Array<org.nem.core.model.ncc.TransactionMetaDataPair>> {
            return this.runAsync<any>(() => {
                try {
                    return this.account.getOutgoingTransactions();
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Gets the unconfirmed transactions.
         * 
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the unconfirmed transactions
         */
        public getUnconfirmedTransactions(callback : io.nem.xpx.callback.ServiceAsyncCallback<Array<org.nem.core.model.ncc.TransactionMetaDataPair>>) : java.util.concurrent.CompletableFuture<Array<org.nem.core.model.ncc.TransactionMetaDataPair>> {
            return this.runAsync<any>(() => {
                try {
                    return this.account.getUnconfirmedTransactions();
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }
    }
    AccountAsync["__class"] = "io.nem.xpx.facade.account.AccountAsync";

}
namespace io.nem.xpx.facade.download {
    /**
     * Instantiates a new download async.
     * 
     * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection the peer connection
     * @class
     * @extends io.nem.xpx.facade.AbstractAsyncFacadeService
     */
    export class DownloadAsync extends io.nem.xpx.facade.AbstractAsyncFacadeService {
        /**
         * The download.
         */
        /*private*/ download : io.nem.xpx.facade.download.Download;

        public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection) {
            super();
            if(this.download===undefined) this.download = null;
            this.download = new io.nem.xpx.facade.download.Download(peerConnection);
        }

        /**
         * Download binary.
         * 
         * @param {io.nem.xpx.facade.download.DownloadParameter} downloadParameter the download parameter
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the completable future
         */
        public downloadBinary(downloadParameter : io.nem.xpx.facade.download.DownloadParameter, callback : io.nem.xpx.callback.ServiceAsyncCallback<io.nem.xpx.facade.download.DownloadBinaryResult>) : java.util.concurrent.CompletableFuture<io.nem.xpx.facade.download.DownloadBinaryResult> {
            return this.runAsync<any>(() => {
                try {
                    return this.download.downloadBinary(downloadParameter);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Download text data.
         * 
         * @param {io.nem.xpx.facade.download.DownloadParameter} downloadParameter the download parameter
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the completable future
         */
        public downloadTextData(downloadParameter : io.nem.xpx.facade.download.DownloadParameter, callback : io.nem.xpx.callback.ServiceAsyncCallback<io.nem.xpx.facade.download.DownloadTextDataResult>) : java.util.concurrent.CompletableFuture<io.nem.xpx.facade.download.DownloadTextDataResult> {
            return this.runAsync<any>(() => {
                try {
                    return this.download.downloadTextData(downloadParameter);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Download file.
         * 
         * @param {io.nem.xpx.facade.download.DownloadParameter} downloadParameter the download parameter
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the completable future
         */
        public downloadFile(downloadParameter : io.nem.xpx.facade.download.DownloadParameter, callback : io.nem.xpx.callback.ServiceAsyncCallback<io.nem.xpx.facade.download.DownloadFileResult>) : java.util.concurrent.CompletableFuture<io.nem.xpx.facade.download.DownloadFileResult> {
            return this.runAsync<any>(() => {
                try {
                    return this.download.downloadFile(downloadParameter);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }
    }
    DownloadAsync["__class"] = "io.nem.xpx.facade.download.DownloadAsync";

}
namespace io.nem.xpx.facade.multisigcosign {
    /**
     * Instantiates a new multisig co sign.
     * 
     * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection
     * the peer connection
     * @class
     * @extends io.nem.xpx.facade.AbstractAsyncFacadeService
     */
    export class MultisigCoSignAsync extends io.nem.xpx.facade.AbstractAsyncFacadeService {
        /**
         * The multisig co sign.
         */
        /*private*/ multisigCoSign : io.nem.xpx.facade.multisigcosign.MultisigCoSign;

        public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection) {
            super();
            if(this.multisigCoSign===undefined) this.multisigCoSign = null;
            this.multisigCoSign = new io.nem.xpx.facade.multisigcosign.MultisigCoSign(peerConnection);
        }

        /**
         * Co sign.
         * 
         * @param {string} nemHash            the nem hash
         * @param {string} multisigAccount            the multisig account
         * @param {org.nem.core.model.Account[]} signers            the signers
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the multisig signature transaction
         */
        public coSign(nemHash : string, multisigAccount : string, signers : Array<org.nem.core.model.Account>, callback : io.nem.xpx.callback.ServiceAsyncCallback<org.nem.core.model.MultisigSignatureTransaction>) : java.util.concurrent.CompletableFuture<org.nem.core.model.MultisigSignatureTransaction> {
            return this.runAsync<any>(() => {
                try {
                    return this.multisigCoSign.coSign(nemHash, multisigAccount, signers);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }
    }
    MultisigCoSignAsync["__class"] = "io.nem.xpx.facade.multisigcosign.MultisigCoSignAsync";

}
namespace io.nem.xpx.facade.multisigupload {
    /**
     * Instantiates a new upload.
     * 
     * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection
     * the peer connection
     * @throws PeerConnectionNotFoundException
     * the peer connection not found exception
     * @class
     * @extends io.nem.xpx.facade.AbstractAsyncFacadeService
     */
    export class MultisigUploadAsync extends io.nem.xpx.facade.AbstractAsyncFacadeService {
        /**
         * The multisig upload.
         */
        /*private*/ multisigUpload : io.nem.xpx.facade.multisigupload.MultisigUpload;

        public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection) {
            super();
            if(this.multisigUpload===undefined) this.multisigUpload = null;
            this.multisigUpload = new io.nem.xpx.facade.multisigupload.MultisigUpload(peerConnection);
        }

        /**
         * Upload data on multisig transaction.
         * 
         * @param {io.nem.xpx.facade.multisigupload.MultisigUploadTextDataParameter} parameters the parameters
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the completable future
         */
        public uploadDataOnMultisigTransaction(parameters : io.nem.xpx.facade.multisigupload.MultisigUploadTextDataParameter, callback : io.nem.xpx.callback.ServiceAsyncCallback<io.nem.xpx.facade.multisigupload.MultisigUploadResult>) : java.util.concurrent.CompletableFuture<io.nem.xpx.facade.multisigupload.MultisigUploadResult> {
            return this.runAsync<any>(() => {
                try {
                    return this.multisigUpload.uploadDataOnMultisigTransaction(parameters);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Upload file on multisig transaction.
         * 
         * @param {io.nem.xpx.facade.multisigupload.MultisigUploadFileParameter} parameters the parameters
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the completable future
         */
        public uploadFileOnMultisigTransaction(parameters : io.nem.xpx.facade.multisigupload.MultisigUploadFileParameter, callback : io.nem.xpx.callback.ServiceAsyncCallback<io.nem.xpx.facade.multisigupload.MultisigUploadResult>) : java.util.concurrent.CompletableFuture<io.nem.xpx.facade.multisigupload.MultisigUploadResult> {
            return this.runAsync<any>(() => {
                try {
                    return this.multisigUpload.uploadFileOnMultisigTransaction(parameters);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Upload binary on multisig transaction.
         * 
         * @param {io.nem.xpx.facade.multisigupload.MultisigUploadBinaryParameter} parameters the parameters
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the completable future
         */
        public uploadBinaryOnMultisigTransaction(parameters : io.nem.xpx.facade.multisigupload.MultisigUploadBinaryParameter, callback : io.nem.xpx.callback.ServiceAsyncCallback<io.nem.xpx.facade.multisigupload.MultisigUploadResult>) : java.util.concurrent.CompletableFuture<io.nem.xpx.facade.multisigupload.MultisigUploadResult> {
            return this.runAsync<any>(() => {
                try {
                    return this.multisigUpload.uploadBinaryOnMultisigTransaction(parameters);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }
    }
    MultisigUploadAsync["__class"] = "io.nem.xpx.facade.multisigupload.MultisigUploadAsync";

}
namespace io.nem.xpx.facade.search {
    /**
     * Instantiates a new search.
     * 
     * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection            the peer connection
     * @class
     * @extends io.nem.xpx.facade.AbstractAsyncFacadeService
     */
    export class SearchAsync extends io.nem.xpx.facade.AbstractAsyncFacadeService {
        /**
         * The search.
         */
        /*private*/ search : io.nem.xpx.facade.search.Search;

        public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection) {
            super();
            if(this.search===undefined) this.search = null;
            this.search = new io.nem.xpx.facade.search.Search(peerConnection);
        }

        /**
         * Search by name.
         * 
         * @param {string} xPvkey the x pvkey
         * @param {string} xPubkey the x pubkey
         * @param {string} name the name
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the completable future
         */
        public searchByName(xPvkey : string, xPubkey : string, name : string, callback : io.nem.xpx.callback.ServiceAsyncCallback<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>>) : java.util.concurrent.CompletableFuture<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>> {
            return this.runAsync<any>(() => {
                try {
                    return this.search.searchByName(xPvkey, xPubkey, name);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Search by keyword.
         * 
         * @param {string} xPvkey the x pvkey
         * @param {string} xPubkey the x pubkey
         * @param {string} keywords the keywords
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the completable future
         */
        public searchByKeyword(xPvkey : string, xPubkey : string, keywords : string, callback : io.nem.xpx.callback.ServiceAsyncCallback<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>>) : java.util.concurrent.CompletableFuture<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>> {
            return this.runAsync<any>(() => {
                try {
                    return this.search.searchByKeyword(xPvkey, xPubkey, keywords);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Search by keyword.
         * 
         * @param {string} xPvkey the x pvkey
         * @param {string} xPubkey the x pubkey
         * @param {string} key the key
         * @param {string} value the value
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the completable future
         */
        public searchByMetaDataKeyValue(xPvkey : string, xPubkey : string, key : string, value : string, callback : io.nem.xpx.callback.ServiceAsyncCallback<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>>) : java.util.concurrent.CompletableFuture<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>> {
            return this.runAsync<any>(() => {
                try {
                    return this.search.searchByMetaDataKeyValue(xPvkey, xPubkey, key, value);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }
    }
    SearchAsync["__class"] = "io.nem.xpx.facade.search.SearchAsync";

}
namespace io.nem.xpx.facade.transaction {
    /**
     * Instantiates a new transaction async.
     * 
     * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection the peer connection
     * @class
     * @extends io.nem.xpx.facade.AbstractAsyncFacadeService
     */
    export class TransactionAsync extends io.nem.xpx.facade.AbstractAsyncFacadeService {
        /**
         * The transaction.
         */
        /*private*/ transaction : io.nem.xpx.facade.transaction.Transaction;

        public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection) {
            super();
            if(this.transaction===undefined) this.transaction = null;
            this.transaction = new io.nem.xpx.facade.transaction.Transaction(peerConnection);
        }

        /**
         * Gets the transaction.
         * 
         * @param {string} hash the hash
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the transaction
         */
        public getTransaction(hash : string, callback : io.nem.xpx.callback.ServiceAsyncCallback<org.nem.core.model.ncc.TransactionMetaDataPair>) : java.util.concurrent.CompletableFuture<org.nem.core.model.ncc.TransactionMetaDataPair> {
            return this.runAsync<any>(() => {
                try {
                    return this.transaction.getTransaction(hash);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Gets the all transactions.
         * 
         * @param {string} publicKey the public key
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the all transactions
         */
        public getAllTransactions(publicKey : string, callback : io.nem.xpx.callback.ServiceAsyncCallback<Array<org.nem.core.model.ncc.TransactionMetaDataPair>>) : java.util.concurrent.CompletableFuture<Array<org.nem.core.model.ncc.TransactionMetaDataPair>> {
            return this.runAsync<any>(() => {
                try {
                    return this.transaction.getAllTransactions(publicKey);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Gets the incoming transactions.
         * 
         * @param {string} publicKey the public key
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the incoming transactions
         */
        public getIncomingTransactions(publicKey : string, callback : io.nem.xpx.callback.ServiceAsyncCallback<Array<org.nem.core.model.ncc.TransactionMetaDataPair>>) : java.util.concurrent.CompletableFuture<Array<org.nem.core.model.ncc.TransactionMetaDataPair>> {
            return this.runAsync<any>(() => {
                try {
                    return this.transaction.getIncomingTransactions(publicKey);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Gets the outgoing transactions.
         * 
         * @param {string} publicKey the public key
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the outgoing transactions
         */
        public getOutgoingTransactions(publicKey : string, callback : io.nem.xpx.callback.ServiceAsyncCallback<Array<org.nem.core.model.ncc.TransactionMetaDataPair>>) : java.util.concurrent.CompletableFuture<Array<org.nem.core.model.ncc.TransactionMetaDataPair>> {
            return this.runAsync<any>(() => {
                try {
                    return this.transaction.getOutgoingTransactions(publicKey);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Gets the unconfirmed transactions.
         * 
         * @param {string} publicKey the public key
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the unconfirmed transactions
         */
        public getUnconfirmedTransactions(publicKey : string, callback : io.nem.xpx.callback.ServiceAsyncCallback<Array<org.nem.core.model.ncc.TransactionMetaDataPair>>) : java.util.concurrent.CompletableFuture<Array<org.nem.core.model.ncc.TransactionMetaDataPair>> {
            return this.runAsync<any>(() => {
                try {
                    return this.transaction.getUnconfirmedTransactions(publicKey);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }
    }
    TransactionAsync["__class"] = "io.nem.xpx.facade.transaction.TransactionAsync";

}
namespace io.nem.xpx.facade.upload {
    /**
     * Instantiates a new upload.
     * 
     * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection
     * the peer connection
     * @class
     * @extends io.nem.xpx.facade.AbstractAsyncFacadeService
     */
    export class UploadAsync extends io.nem.xpx.facade.AbstractAsyncFacadeService {
        /**
         * The upload.
         */
        /*private*/ upload : io.nem.xpx.facade.upload.Upload;

        public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection) {
            super();
            if(this.upload===undefined) this.upload = null;
            this.upload = new io.nem.xpx.facade.upload.Upload(peerConnection);
        }

        /**
         * Upload file.
         * 
         * @param {io.nem.xpx.facade.upload.UploadFileParameter} uploadParameter the upload parameter
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the future
         */
        public uploadFile(uploadParameter : io.nem.xpx.facade.upload.UploadFileParameter, callback : io.nem.xpx.callback.ServiceAsyncCallback<io.nem.xpx.facade.upload.UploadResult>) : java.util.concurrent.CompletableFuture<io.nem.xpx.facade.upload.UploadResult> {
            return this.runAsync<any>(() => {
                try {
                    return this.upload.uploadFile(uploadParameter);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Upload text data.
         * 
         * @param {io.nem.xpx.facade.upload.UploadTextDataParameter} uploadParameter the upload parameter
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the future
         */
        public uploadTextData(uploadParameter : io.nem.xpx.facade.upload.UploadTextDataParameter, callback : io.nem.xpx.callback.ServiceAsyncCallback<io.nem.xpx.facade.upload.UploadResult>) : java.util.concurrent.CompletableFuture<io.nem.xpx.facade.upload.UploadResult> {
            return this.runAsync<any>(() => {
                try {
                    return this.upload.uploadTextData(uploadParameter);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Upload binary.
         * 
         * @param {io.nem.xpx.facade.upload.UploadBinaryParameter} uploadParameter the upload parameter
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the future
         */
        public uploadBinary(uploadParameter : io.nem.xpx.facade.upload.UploadBinaryParameter, callback : io.nem.xpx.callback.ServiceAsyncCallback<io.nem.xpx.facade.upload.UploadResult>) : java.util.concurrent.CompletableFuture<io.nem.xpx.facade.upload.UploadResult> {
            return this.runAsync<any>(() => {
                try {
                    return this.upload.uploadBinary(uploadParameter);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Upload path.
         * 
         * @param {io.nem.xpx.facade.upload.UploadPathParameter} uploadParameter the upload parameter
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the future
         */
        public uploadPath(uploadParameter : io.nem.xpx.facade.upload.UploadPathParameter, callback : io.nem.xpx.callback.ServiceAsyncCallback<io.nem.xpx.facade.upload.UploadResult>) : java.util.concurrent.CompletableFuture<io.nem.xpx.facade.upload.UploadResult> {
            return this.runAsync<any>(() => {
                try {
                    return this.upload.uploadPath(uploadParameter);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Upload files as zip.
         * 
         * @param {io.nem.xpx.facade.upload.UploadFilesAsZipParameter} uploadParameter the upload parameter
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the completable future
         */
        public uploadFilesAsZip(uploadParameter : io.nem.xpx.facade.upload.UploadFilesAsZipParameter, callback : io.nem.xpx.callback.ServiceAsyncCallback<io.nem.xpx.facade.upload.UploadResult>) : java.util.concurrent.CompletableFuture<io.nem.xpx.facade.upload.UploadResult> {
            return this.runAsync<any>(() => {
                try {
                    return this.upload.uploadFilesAsZip(uploadParameter);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Upload multiple files.
         * 
         * @param {io.nem.xpx.facade.upload.UploadMultipleFilesParameter} uploadParameter the upload parameter
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the completable future
         */
        public uploadMultipleFiles(uploadParameter : io.nem.xpx.facade.upload.UploadMultipleFilesParameter, callback : io.nem.xpx.callback.ServiceAsyncCallback<io.nem.xpx.facade.upload.MultiFileUploadResult>) : java.util.concurrent.CompletableFuture<io.nem.xpx.facade.upload.MultiFileUploadResult> {
            return this.runAsync<any>(() => {
                try {
                    return this.upload.uploadMultipleFiles(uploadParameter);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }

        /**
         * Upload from URL.
         * 
         * @param {io.nem.xpx.facade.upload.UploadFromUrlParameter} uploadParameter the upload parameter
         * @param {*} callback the callback
         * @return {java.util.concurrent.CompletableFuture} the completable future
         */
        public uploadFromUrl(uploadParameter : io.nem.xpx.facade.upload.UploadFromUrlParameter, callback : io.nem.xpx.callback.ServiceAsyncCallback<io.nem.xpx.facade.upload.UploadResult>) : java.util.concurrent.CompletableFuture<io.nem.xpx.facade.upload.UploadResult> {
            return this.runAsync<any>(() => {
                try {
                    return this.upload.uploadFromUrl(uploadParameter);
                } catch(e) {
                    throw Object.defineProperty(new Error(e.message), '__classes', { configurable: true, value: ['java.lang.Throwable','java.util.concurrent.CompletionException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                };
            }, <any>(callback));
        }
    }
    UploadAsync["__class"] = "io.nem.xpx.facade.upload.UploadAsync";

}
namespace io.nem.xpx.facade.account {
    /**
     * Instantiates a new search.
     * 
     * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection            the peer connection
     * @param {string} publicKey the public key
     * @throws PeerConnectionNotFoundException             the peer connection not found exception
     * @class
     * @extends io.nem.xpx.facade.AbstractFacadeService
     */
    export class Account extends io.nem.xpx.facade.AbstractFacadeService {
        /**
         * The public key.
         */
        publicKey : string;

        /**
         * The peer connection.
         */
        /*private*/ peerConnection : io.nem.xpx.facade.connection.PeerConnection;

        /**
         * The engine.
         */
        /*private*/ engine : org.nem.core.crypto.CryptoEngine;

        /**
         * The account api.
         */
        /*private*/ accountApi : io.nem.xpx.service.intf.AccountApi;

        /**
         * The nem transaction api.
         */
        nemTransactionApi : io.nem.xpx.service.NemTransactionApi;

        /**
         * The search api.
         */
        searchApi : io.nem.xpx.service.intf.SearchApi;

        /**
         * The is local peer connection.
         */
        /*private*/ isLocalPeerConnection : boolean;

        public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection, publicKey : string) {
            super();
            if(this.publicKey===undefined) this.publicKey = null;
            if(this.peerConnection===undefined) this.peerConnection = null;
            if(this.engine===undefined) this.engine = null;
            if(this.accountApi===undefined) this.accountApi = null;
            if(this.nemTransactionApi===undefined) this.nemTransactionApi = null;
            if(this.searchApi===undefined) this.searchApi = null;
            if(this.isLocalPeerConnection===undefined) this.isLocalPeerConnection = false;
            if(peerConnection == null) {
                throw new io.nem.xpx.exceptions.PeerConnectionNotFoundException("PeerConnection can\'t be null");
            }
            this.accountApi = peerConnection.getAccountApi();
            this.searchApi = peerConnection.getSearchApi();
            this.isLocalPeerConnection = peerConnection.isLocal();
            this.peerConnection = peerConnection;
            this.nemTransactionApi = peerConnection.getNemTransactionApi();
            this.engine = org.nem.core.crypto.CryptoEngines.ed25519Engine();
            this.publicKey = publicKey;
        }

        /**
         * Gets the incoming transactions.
         * 
         * @return {org.nem.core.model.ncc.TransactionMetaDataPair[]} the incoming transactions
         * @throws ApiException             the api exception
         * @throws InterruptedException             the interrupted exception
         * @throws ExecutionException             the execution exception
         */
        public getIncomingTransactions() : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let returnListOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = <any>([]);
            let listOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = this.nemTransactionApi.getIncomingTransactions$java_lang_String(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(this.publicKey)).getEncoded());
            for(let index176=0; index176 < listOfTxnMetaDataPair.length; index176++) {
                let metaDataPair = listOfTxnMetaDataPair[index176];
                {
                    if(this.checkIfTxnHaveXPXMosaic(metaDataPair.getEntity())) {
                        /* add */(returnListOfTxnMetaDataPair.push(metaDataPair)>0);
                    }
                }
            }
            return returnListOfTxnMetaDataPair;
        }

        /**
         * Gets the all transactions.
         * 
         * @return {org.nem.core.model.ncc.TransactionMetaDataPair[]} the all transactions
         * @throws ApiException             the api exception
         * @throws InterruptedException             the interrupted exception
         * @throws ExecutionException             the execution exception
         */
        public getAllTransactions() : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let returnListOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = <any>([]);
            let listOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = this.nemTransactionApi.getAllTransactions$java_lang_String(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(this.publicKey)).getEncoded());
            for(let index177=0; index177 < listOfTxnMetaDataPair.length; index177++) {
                let metaDataPair = listOfTxnMetaDataPair[index177];
                {
                    if(this.checkIfTxnHaveXPXMosaic(metaDataPair.getEntity())) {
                        /* add */(returnListOfTxnMetaDataPair.push(metaDataPair)>0);
                    }
                }
            }
            return returnListOfTxnMetaDataPair;
        }

        /**
         * Gets the outgoing transactions.
         * 
         * @return {org.nem.core.model.ncc.TransactionMetaDataPair[]} the outgoing transactions
         * @throws ApiException             the api exception
         * @throws InterruptedException             the interrupted exception
         * @throws ExecutionException             the execution exception
         */
        public getOutgoingTransactions() : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let returnListOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = <any>([]);
            let listOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = this.nemTransactionApi.getOutgoingTransactions$java_lang_String(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(this.publicKey)).getEncoded());
            for(let index178=0; index178 < listOfTxnMetaDataPair.length; index178++) {
                let metaDataPair = listOfTxnMetaDataPair[index178];
                {
                    if(this.checkIfTxnHaveXPXMosaic(metaDataPair.getEntity())) {
                        /* add */(returnListOfTxnMetaDataPair.push(metaDataPair)>0);
                    }
                }
            }
            return returnListOfTxnMetaDataPair;
        }

        /**
         * Gets the unconfirmed transactions.
         * 
         * @return {org.nem.core.model.ncc.TransactionMetaDataPair[]} the unconfirmed transactions
         * @throws ApiException             the api exception
         * @throws InterruptedException             the interrupted exception
         * @throws ExecutionException             the execution exception
         */
        public getUnconfirmedTransactions() : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let returnListOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = <any>([]);
            let listOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = this.nemTransactionApi.getUnconfirmedTransactions(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(this.publicKey)).getEncoded());
            for(let index179=0; index179 < listOfTxnMetaDataPair.length; index179++) {
                let metaDataPair = listOfTxnMetaDataPair[index179];
                {
                    if(this.checkIfTxnHaveXPXMosaic(metaDataPair.getEntity())) {
                        /* add */(returnListOfTxnMetaDataPair.push(metaDataPair)>0);
                    }
                }
            }
            return returnListOfTxnMetaDataPair;
        }

        /**
         * Search by name.
         * 
         * @param {string} xPvkey the x pvkey
         * @param {string} name the name
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]} the list
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        public searchByName(xPvkey : string, name : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            return this.searchApi['searchTransactionWithKeywordUsingGET$java_lang_String$java_lang_String$java_lang_String'](xPvkey, this.publicKey, name);
        }

        /**
         * Search by keyword.
         * 
         * @param {string} xPvkey            the x pvkey
         * @param {string} keywords            the keywords
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]} the list
         * @throws ApiException             the api exception
         * @throws InterruptedException             the interrupted exception
         * @throws ExecutionException             the execution exception
         */
        public searchByKeyword(xPvkey : string, keywords : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            return this.searchApi['searchTransactionWithKeywordUsingGET$java_lang_String$java_lang_String$java_lang_String'](xPvkey, this.publicKey, keywords);
        }

        /**
         * Search by meta data key value.
         * 
         * @param {string} xPvkey            the x pvkey
         * @param {string} key            the key
         * @param {string} value            the value
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]} the string
         * @throws ApiException             the api exception
         * @throws InterruptedException             the interrupted exception
         * @throws ExecutionException             the execution exception
         */
        public searchByMetaDataKeyValue(xPvkey : string, key : string, value : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            return this.searchApi.searchTransactionWithMetadataKeyValuePair(xPvkey, this.publicKey, key, value);
        }
    }
    Account["__class"] = "io.nem.xpx.facade.account.Account";

}
namespace io.nem.xpx.facade.download {
    /**
     * Instantiates a new download.
     * 
     * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection            the peer connection
     * @throws PeerConnectionNotFoundException the peer connection not found exception
     * @class
     * @extends io.nem.xpx.facade.AbstractFacadeService
     */
    export class Download extends io.nem.xpx.facade.AbstractFacadeService {
        /**
         * The download api.
         */
        /*private*/ downloadApi : io.nem.xpx.service.intf.DownloadApi;

        /**
         * The nem transaction api.
         */
        /*private*/ nemTransactionApi : io.nem.xpx.service.NemTransactionApi;

        public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection) {
            super();
            if(this.downloadApi===undefined) this.downloadApi = null;
            if(this.nemTransactionApi===undefined) this.nemTransactionApi = null;
            if(peerConnection == null) {
                throw new io.nem.xpx.exceptions.PeerConnectionNotFoundException("PeerConnection can\'t be null");
            }
            this.downloadApi = peerConnection.getDownloadApi();
            this.nemTransactionApi = peerConnection.getNemTransactionApi();
        }

        /**
         * Download binary.
         * 
         * @param {io.nem.xpx.facade.download.DownloadParameter} downloadParameter the download parameter
         * @return {io.nem.xpx.facade.download.DownloadBinaryResult} the download binary result
         * @throws DownloadException the download exception
         */
        public downloadBinary(downloadParameter : io.nem.xpx.facade.download.DownloadParameter) : io.nem.xpx.facade.download.DownloadBinaryResult {
            return io.nem.xpx.facade.download.DownloadBinaryResult.fromDownloadResult(this.download(downloadParameter));
        }

        /**
         * Download text data.
         * 
         * @param {io.nem.xpx.facade.download.DownloadParameter} downloadParameter the download parameter
         * @return {io.nem.xpx.facade.download.DownloadTextDataResult} the download text data result
         * @throws DownloadException the download exception
         */
        public downloadTextData(downloadParameter : io.nem.xpx.facade.download.DownloadParameter) : io.nem.xpx.facade.download.DownloadTextDataResult {
            return io.nem.xpx.facade.download.DownloadTextDataResult.fromDownloadResult(this.download(downloadParameter));
        }

        /**
         * Download file.
         * 
         * @param {io.nem.xpx.facade.download.DownloadParameter} downloadParameter the download parameter
         * @return {io.nem.xpx.facade.download.DownloadFileResult} the download file result
         * @throws DownloadException the download exception
         */
        public downloadFile(downloadParameter : io.nem.xpx.facade.download.DownloadParameter) : io.nem.xpx.facade.download.DownloadFileResult {
            return io.nem.xpx.facade.download.DownloadFileResult.fromDownloadResult(this.download(downloadParameter));
        }

        /**
         * Download.
         * 
         * @param {io.nem.xpx.facade.download.DownloadParameter} downloadParameter the download parameter
         * @return {io.nem.xpx.facade.download.DownloadResult} the download result
         * @throws DownloadException the download exception
         * @private
         */
        /*private*/ download(downloadParameter : io.nem.xpx.facade.download.DownloadParameter) : io.nem.xpx.facade.download.DownloadResult {
            if(downloadParameter.getNemHash() != null) {
                let transaction : org.nem.core.model.TransferTransaction = this.getNemTransaction(downloadParameter.getNemHash());
                let decodedDataFromNemMessage : number[] = downloadParameter.getPrivacyStrategy().decodeTransaction(transaction);
                let resourceMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage = this.deserializeResourceMessageHash(decodedDataFromNemMessage);
                let downloadedData : number[] = this.downloadUsingDataHash(resourceMessage.hash());
                let decryptedDownloadedData : number[] = downloadParameter.getPrivacyStrategy().decrypt(downloadedData, transaction, resourceMessage);
                return new io.nem.xpx.facade.download.DownloadResult(resourceMessage, decryptedDownloadedData, io.nem.xpx.model.NemMessageType_$WRAPPER.fromInt(transaction.getMessage().getType()));
            } else {
                let downloadedData : number[] = this.downloadUsingDataHash(downloadParameter.getIpfsHash());
                let decryptedDownloadedData : number[] = downloadParameter.getPrivacyStrategy().decrypt(downloadedData, null, null);
                return new io.nem.xpx.facade.download.DownloadResult(null, decryptedDownloadedData, null);
            }
        }

        /**
         * Gets the nem transaction.
         * 
         * @param {string} nemHash the nem hash
         * @return {org.nem.core.model.TransferTransaction} the nem transaction
         * @throws DownloadException the download exception
         * @private
         */
        /*private*/ getNemTransaction(nemHash : string) : org.nem.core.model.TransferTransaction {
            try {
                return <org.nem.core.model.TransferTransaction>this.nemTransactionApi.getTransaction(nemHash).getEntity();
            } catch(e) {
                throw new io.nem.xpx.facade.download.DownloadException(java.lang.String.format("Failed to retrieve a Nem Transaction for hash %s", nemHash), e);
            };
        }

        /**
         * Download using data hash.
         * 
         * @param {string} hash the hash
         * @return {Array} the byte[]
         * @throws DownloadException the download exception
         * @private
         */
        /*private*/ downloadUsingDataHash(hash : string) : number[] {
            try {
                return this.downloadApi.downloadUsingDataHashUsingGET(hash);
            } catch(e) {
                throw new io.nem.xpx.facade.download.DownloadException(java.lang.String.format("Failed to download using data hash %s", hash), e);
            };
        }
    }
    Download["__class"] = "io.nem.xpx.facade.download.Download";

}
namespace io.nem.xpx.facade.multisigcosign {
    /**
     * Instantiates a new multisig co sign.
     * 
     * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection the peer connection
     * @class
     * @extends io.nem.xpx.facade.AbstractFacadeService
     */
    export class MultisigCoSign extends io.nem.xpx.facade.AbstractFacadeService {
        /**
         * The peer connection.
         */
        peerConnection : io.nem.xpx.facade.connection.PeerConnection;

        public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection) {
            super();
            if(this.peerConnection===undefined) this.peerConnection = null;
            this.peerConnection = peerConnection;
        }

        /**
         * Co sign.
         * 
         * @param {string} nemHash the nem hash
         * @param {string} multisigAccount the multisig account
         * @param {org.nem.core.model.Account[]} signers the signers
         * @return {org.nem.core.model.MultisigSignatureTransaction} the multisig signature transaction
         * @throws ApiException the api exception
         */
        public coSign(nemHash : string, multisigAccount : string, signers : Array<org.nem.core.model.Account>) : org.nem.core.model.MultisigSignatureTransaction {
            let multisigSignatureTransaction : org.nem.core.model.MultisigSignatureTransaction = io.nem.xpx.builder.MultisigSignatureTransactionBuilder.peerConnection(this.peerConnection).multisig(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PublicKey.fromHexString(multisigAccount)))).addSigners(signers)['otherTransaction$org_nem_core_crypto_Hash'](org.nem.core.crypto.Hash.fromHexString(nemHash)).coSign();
            return multisigSignatureTransaction;
        }
    }
    MultisigCoSign["__class"] = "io.nem.xpx.facade.multisigcosign.MultisigCoSign";

}
namespace io.nem.xpx.facade.multisigupload {
    /**
     * Instantiates a new upload.
     * 
     * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection            the peer connection
     * @class
     * @extends io.nem.xpx.facade.AbstractFacadeService
     */
    export class MultisigUpload extends io.nem.xpx.facade.AbstractFacadeService {
        /**
         * The peer connection.
         */
        /*private*/ peerConnection : io.nem.xpx.facade.connection.PeerConnection;

        /**
         * The engine.
         */
        /*private*/ engine : org.nem.core.crypto.CryptoEngine;

        /*private*/ uploadDelegate : io.nem.xpx.service.UploadDelegate;

        /**
         * The publish and announce api.
         */
        /*private*/ transactionAndAnnounceApi : io.nem.xpx.service.intf.TransactionAndAnnounceApi;

        /**
         * The is local peer connection.
         */
        /*private*/ isLocalPeerConnection : boolean;

        /*private*/ ipfsGatewaySyncService : io.nem.xpx.service.IpfsGatewaySyncService;

        public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection) {
            super();
            if(this.peerConnection===undefined) this.peerConnection = null;
            if(this.engine===undefined) this.engine = null;
            if(this.uploadDelegate===undefined) this.uploadDelegate = null;
            if(this.transactionAndAnnounceApi===undefined) this.transactionAndAnnounceApi = null;
            if(this.isLocalPeerConnection===undefined) this.isLocalPeerConnection = false;
            if(this.ipfsGatewaySyncService===undefined) this.ipfsGatewaySyncService = null;
            if(peerConnection == null) {
                throw new io.nem.xpx.exceptions.PeerConnectionNotFoundException("PeerConnection can\'t be null");
            }
            this.peerConnection = peerConnection;
            this.transactionAndAnnounceApi = peerConnection.getTransactionAndAnnounceApi();
            this.isLocalPeerConnection = peerConnection.isLocal();
            this.engine = org.nem.core.crypto.CryptoEngines.ed25519Engine();
            this.ipfsGatewaySyncService = new io.nem.xpx.service.IpfsGatewaySyncService(peerConnection.getSyncGateways());
            this.uploadDelegate = new io.nem.xpx.service.UploadDelegate(peerConnection.getUploadApi());
        }

        /**
         * Upload data on multisig transaction.
         * 
         * @param {io.nem.xpx.facade.multisigupload.MultisigUploadTextDataParameter} parameters the parameters
         * @return {io.nem.xpx.facade.multisigupload.MultisigUploadResult} the multisig upload data
         * @throws ApiException the api exception
         * @throws NoSuchAlgorithmException the no such algorithm exception
         * @throws InvalidKeyException the invalid key exception
         * @throws InvalidKeySpecException the invalid key spec exception
         * @throws NoSuchPaddingException the no such padding exception
         * @throws InvalidAlgorithmParameterException the invalid algorithm parameter exception
         * @throws IllegalBlockSizeException the illegal block size exception
         * @throws BadPaddingException the bad padding exception
         * @throws IOException Signals that an I/O exception has occurred.
         * @throws UploadException the upload exception
         */
        public uploadDataOnMultisigTransaction(parameters : io.nem.xpx.facade.multisigupload.MultisigUploadTextDataParameter) : io.nem.xpx.facade.multisigupload.MultisigUploadResult {
            let multisigUploadData : io.nem.xpx.facade.multisigupload.MultisigUploadResult = this.handleMultisigDataUpload(parameters);
            return multisigUploadData;
        }

        /**
         * Upload file on multisig transaction.
         * 
         * @param {io.nem.xpx.facade.multisigupload.MultisigUploadFileParameter} uploadParameter the upload parameter
         * @return {io.nem.xpx.facade.multisigupload.MultisigUploadResult} the multisig upload data
         * @throws IOException Signals that an I/O exception has occurred.
         * @throws ApiException the api exception
         * @throws InvalidKeyException the invalid key exception
         * @throws InvalidKeySpecException the invalid key spec exception
         * @throws NoSuchAlgorithmException the no such algorithm exception
         * @throws NoSuchPaddingException the no such padding exception
         * @throws InvalidAlgorithmParameterException the invalid algorithm parameter exception
         * @throws IllegalBlockSizeException the illegal block size exception
         * @throws BadPaddingException the bad padding exception
         * @throws UploadException the upload exception
         */
        public uploadFileOnMultisigTransaction(uploadParameter : io.nem.xpx.facade.multisigupload.MultisigUploadFileParameter) : io.nem.xpx.facade.multisigupload.MultisigUploadResult {
            let multisigUploadData : io.nem.xpx.facade.multisigupload.MultisigUploadResult = this.handleMultisigFileUpload(uploadParameter);
            return multisigUploadData;
        }

        /**
         * Upload binary on multisig transaction.
         * 
         * @param {io.nem.xpx.facade.multisigupload.MultisigUploadBinaryParameter} uploadParameter the upload parameter
         * @return {io.nem.xpx.facade.multisigupload.MultisigUploadResult} the multisig upload data
         * @throws IOException Signals that an I/O exception has occurred.
         * @throws ApiException the api exception
         * @throws InvalidKeyException the invalid key exception
         * @throws InvalidKeySpecException the invalid key spec exception
         * @throws NoSuchAlgorithmException the no such algorithm exception
         * @throws NoSuchPaddingException the no such padding exception
         * @throws InvalidAlgorithmParameterException the invalid algorithm parameter exception
         * @throws IllegalBlockSizeException the illegal block size exception
         * @throws BadPaddingException the bad padding exception
         * @throws UploadException the upload exception
         */
        public uploadBinaryOnMultisigTransaction(uploadParameter : io.nem.xpx.facade.multisigupload.MultisigUploadBinaryParameter) : io.nem.xpx.facade.multisigupload.MultisigUploadResult {
            let multisigUploadData : io.nem.xpx.facade.multisigupload.MultisigUploadResult = this.handleMultisigBinaryUpload(uploadParameter);
            return multisigUploadData;
        }

        /**
         * Handle multisig data upload.
         * 
         * @param {io.nem.xpx.facade.multisigupload.MultisigUploadTextDataParameter} param the upload parameter
         * @return {io.nem.xpx.facade.multisigupload.MultisigUploadResult} the multisig upload data
         * @throws IOException Signals that an I/O exception has occurred.
         * @throws ApiException the api exception
         * @throws UploadException the upload exception
         */
        public handleMultisigDataUpload(param : io.nem.xpx.facade.multisigupload.MultisigUploadTextDataParameter) : io.nem.xpx.facade.multisigupload.MultisigUploadResult {
            let encrypted : number[] = null;
            let response : number[] = null;
            let hashMessageWrapper : io.nem.xpx.service.UploadDelegate.ResourceHashMessageWrapper = null;
            let publishedData : string = "";
            let secretKey : string = null;
            try {
                if(param.getPrivacyStrategy().getNemMessageType() === io.nem.xpx.model.NemMessageType.SECURE) {
                    let keyGen : javax.crypto.KeyGenerator = javax.crypto.KeyGenerator.getInstance("AES");
                    keyGen.init(128);
                    let keyRandom : string = org.apache.commons.codec.binary.Base64.encodeBase64String(keyGen.generateKey().getEncoded());
                    encrypted = io.nem.xpx.utils.CryptoUtils.encrypt(/* getBytes */(param.getData()).split('').map(s => s.charCodeAt(0)), /* toCharArray */(keyRandom).split(''));
                    hashMessageWrapper = this.uploadDelegate.uploadTextToIpfs(encrypted, param.getName(), param.getContentType(), param.getEncoding(), param.getKeywords(), param.getMetaDataAsString());
                    secretKey = keyRandom;
                } else {
                    hashMessageWrapper = this.uploadDelegate.uploadTextToIpfs(/* getBytes */(param.getData()).split('').map(s => s.charCodeAt(0)), param.getName(), param.getContentType(), param.getEncoding(), param.getKeywords(), param.getMetaDataAsString());
                }
                let nemMessage : org.nem.core.model.Message = param.getPrivacyStrategy().encodeToMessage(hashMessageWrapper.getData());
                if(this.isLocalPeerConnection) {
                    let transaction : org.nem.core.model.TransferTransaction = new io.nem.xpx.builder.TransferTransactionBuilder(this.peerConnection.getTransactionFeeCalculators()).sender(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PublicKey.fromHexString(param.getMultisigPublicKey())))).recipient(new org.nem.core.model.Account(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(param.getReceiverPublicKey())))).amount(org.nem.core.model.primitive.Amount.fromNem(1)).version(2).message(nemMessage).buildTransaction();
                    let announceResult : org.nem.core.model.ncc.NemAnnounceResult = io.nem.xpx.builder.MultisigTransactionBuilder.peerConnection(this.peerConnection).sender(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PrivateKey.fromHexString(param.getSenderPrivateKey())))).otherTransaction(transaction).buildAndSendMultisigTransaction();
                    publishedData = announceResult.getTransactionHash().toString();
                } else {
                    let transaction : org.nem.core.model.TransferTransaction = (o => o.addMosaics.apply(o, param.getMosaics()))(new io.nem.xpx.builder.TransferTransactionBuilder(this.peerConnection.getTransactionFeeCalculators()).sender(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PublicKey.fromHexString(param.getMultisigPublicKey())))).recipient(new org.nem.core.model.Account(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(param.getReceiverPublicKey()))))).amount(org.nem.core.model.primitive.Amount.fromNem(1)).message(nemMessage).buildTransaction();
                    let requestAnnounceDataSignature : io.nem.xpx.model.RequestAnnounceDataSignature = io.nem.xpx.builder.MultisigTransactionBuilder.peerConnection(this.peerConnection).sender(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PrivateKey.fromHexString(param.getSenderPrivateKey())))).otherTransaction(transaction).buildAndSignMultisigTransaction();
                    publishedData = this.transactionAndAnnounceApi.announceRequestPublishDataSignatureUsingPOST(requestAnnounceDataSignature);
                }
            } catch(e) {
                this.uploadDelegate.deletePinnedContent(hashMessageWrapper.getResourceHashMessage().hash());
                throw new io.nem.xpx.facade.upload.UploadException(e);
            } finally {
                this.ipfsGatewaySyncService.syncToGatewaysAsynchronously(hashMessageWrapper.getResourceHashMessage().hash());
            };
            return new io.nem.xpx.facade.multisigupload.MultisigUploadResult(new io.nem.xpx.facade.upload.UploadResult(hashMessageWrapper.getResourceHashMessage(), publishedData), secretKey);
        }

        /**
         * Handle multisig file upload.
         * 
         * @param {io.nem.xpx.facade.multisigupload.MultisigUploadFileParameter} param the upload parameter
         * @return {io.nem.xpx.facade.multisigupload.MultisigUploadResult} the multisig upload data
         * @throws IOException Signals that an I/O exception has occurred.
         * @throws ApiException the api exception
         * @throws UploadException the upload exception
         */
        public handleMultisigFileUpload(param : io.nem.xpx.facade.multisigupload.MultisigUploadFileParameter) : io.nem.xpx.facade.multisigupload.MultisigUploadResult {
            let encrypted : number[] = null;
            let response : number[] = null;
            let hashMessageWrapper : io.nem.xpx.service.UploadDelegate.ResourceHashMessageWrapper = null;
            let publishedData : string = "";
            let secretKey : string = null;
            try {
                if(param.getPrivacyStrategy().getNemMessageType() === io.nem.xpx.model.NemMessageType.SECURE) {
                    let keyGen : javax.crypto.KeyGenerator = javax.crypto.KeyGenerator.getInstance("AES");
                    keyGen.init(128);
                    let keyRandom : string = org.apache.commons.codec.binary.Base64.encodeBase64String(keyGen.generateKey().getEncoded());
                    encrypted = io.nem.xpx.utils.CryptoUtils.encrypt(org.apache.commons.io.FileUtils.readFileToByteArray(param.getFile()), /* toCharArray */(keyRandom).split(''));
                    hashMessageWrapper = this.uploadDelegate.uploadBinaryToIpfs(encrypted, param.getName(), param.getContentType(), param.getKeywords(), param.getMetaDataAsString());
                    secretKey = keyRandom;
                } else {
                    hashMessageWrapper = this.uploadDelegate.uploadBinaryToIpfs(org.apache.commons.io.FileUtils.readFileToByteArray(param.getFile()), param.getName(), param.getContentType(), param.getKeywords(), param.getMetaDataAsString());
                }
                let nemMessage : org.nem.core.model.Message = param.getPrivacyStrategy().encodeToMessage(response);
                if(this.isLocalPeerConnection) {
                    let transaction : org.nem.core.model.TransferTransaction = new io.nem.xpx.builder.TransferTransactionBuilder(this.peerConnection.getTransactionFeeCalculators()).sender(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PublicKey.fromHexString(param.getMultisigPublicKey())))).recipient(new org.nem.core.model.Account(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(param.getReceiverPublicKey())))).amount(org.nem.core.model.primitive.Amount.fromNem(1)).message(nemMessage).buildTransaction();
                    let announceResult : org.nem.core.model.ncc.NemAnnounceResult = io.nem.xpx.builder.MultisigTransactionBuilder.peerConnection(this.peerConnection).sender(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PrivateKey.fromHexString(param.getSenderPrivateKey())))).otherTransaction(transaction).buildAndSendMultisigTransaction();
                    publishedData = announceResult.getTransactionHash().toString();
                } else {
                    let transaction : org.nem.core.model.TransferTransaction = (o => o.addMosaics.apply(o, param.getMosaics()))(new io.nem.xpx.builder.TransferTransactionBuilder(this.peerConnection.getTransactionFeeCalculators()).sender(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PublicKey.fromHexString(param.getMultisigPublicKey())))).recipient(new org.nem.core.model.Account(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(param.getReceiverPublicKey()))))).amount(org.nem.core.model.primitive.Amount.fromNem(1)).message(nemMessage).buildTransaction();
                    let requestAnnounceDataSignature : io.nem.xpx.model.RequestAnnounceDataSignature = io.nem.xpx.builder.MultisigTransactionBuilder.peerConnection(this.peerConnection).sender(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PrivateKey.fromHexString(param.getSenderPrivateKey())))).otherTransaction(transaction).buildAndSignMultisigTransaction();
                    publishedData = this.transactionAndAnnounceApi.announceRequestPublishDataSignatureUsingPOST(requestAnnounceDataSignature);
                }
            } catch(e) {
                this.uploadDelegate.deletePinnedContent(hashMessageWrapper.getResourceHashMessage().hash());
                throw new io.nem.xpx.facade.upload.UploadException(e);
            };
            return new io.nem.xpx.facade.multisigupload.MultisigUploadResult(new io.nem.xpx.facade.upload.UploadResult(hashMessageWrapper.getResourceHashMessage(), publishedData), secretKey);
        }

        /**
         * Handle multisig binary upload.
         * 
         * @param {io.nem.xpx.facade.multisigupload.MultisigUploadBinaryParameter} param the upload parameter
         * @return {io.nem.xpx.facade.multisigupload.MultisigUploadResult} the multisig upload data
         * @throws IOException Signals that an I/O exception has occurred.
         * @throws ApiException the api exception
         * @throws UploadException the upload exception
         */
        public handleMultisigBinaryUpload(param : io.nem.xpx.facade.multisigupload.MultisigUploadBinaryParameter) : io.nem.xpx.facade.multisigupload.MultisigUploadResult {
            let encrypted : number[] = null;
            let response : number[] = null;
            let hashMessageWrapper : io.nem.xpx.service.UploadDelegate.ResourceHashMessageWrapper = null;
            let publishedData : string = "";
            let secretKey : string = null;
            try {
                if(param.getPrivacyStrategy().getNemMessageType() === io.nem.xpx.model.NemMessageType.SECURE) {
                    let keyGen : javax.crypto.KeyGenerator = javax.crypto.KeyGenerator.getInstance("AES");
                    keyGen.init(128);
                    let keyRandom : string = org.apache.commons.codec.binary.Base64.encodeBase64String(keyGen.generateKey().getEncoded());
                    encrypted = io.nem.xpx.utils.CryptoUtils.encrypt(param.getData(), /* toCharArray */(keyRandom).split(''));
                    hashMessageWrapper = this.uploadDelegate.uploadBinaryToIpfs(encrypted, param.getName(), param.getContentType(), param.getKeywords(), param.getMetaDataAsString());
                    secretKey = keyRandom;
                } else {
                    hashMessageWrapper = this.uploadDelegate.uploadBinaryToIpfs(param.getData(), param.getName(), param.getContentType(), param.getKeywords(), param.getMetaDataAsString());
                }
                let nemMessage : org.nem.core.model.Message = param.getPrivacyStrategy().encodeToMessage(response);
                if(this.isLocalPeerConnection) {
                    let transaction : org.nem.core.model.TransferTransaction = new io.nem.xpx.builder.TransferTransactionBuilder(this.peerConnection.getTransactionFeeCalculators()).sender(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PublicKey.fromHexString(param.getMultisigPublicKey())))).recipient(new org.nem.core.model.Account(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(param.getReceiverPublicKey())))).amount(org.nem.core.model.primitive.Amount.fromNem(1)).message(nemMessage).buildTransaction();
                    let announceResult : org.nem.core.model.ncc.NemAnnounceResult = io.nem.xpx.builder.MultisigTransactionBuilder.peerConnection(this.peerConnection).sender(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PrivateKey.fromHexString(param.getSenderPrivateKey())))).otherTransaction(transaction).buildAndSendMultisigTransaction();
                    publishedData = announceResult.getTransactionHash().toString();
                } else {
                    let transaction : org.nem.core.model.TransferTransaction = (o => o.addMosaics.apply(o, param.getMosaics()))(new io.nem.xpx.builder.TransferTransactionBuilder(this.peerConnection.getTransactionFeeCalculators()).sender(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PublicKey.fromHexString(param.getMultisigPublicKey())))).recipient(new org.nem.core.model.Account(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(param.getReceiverPublicKey()))))).amount(org.nem.core.model.primitive.Amount.fromNem(1)).message(nemMessage).buildTransaction();
                    let requestAnnounceDataSignature : io.nem.xpx.model.RequestAnnounceDataSignature = io.nem.xpx.builder.MultisigTransactionBuilder.peerConnection(this.peerConnection).sender(new org.nem.core.model.Account(new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PrivateKey.fromHexString(param.getSenderPrivateKey())))).otherTransaction(transaction).buildAndSignMultisigTransaction();
                    publishedData = this.transactionAndAnnounceApi.announceRequestPublishDataSignatureUsingPOST(requestAnnounceDataSignature);
                }
            } catch(e) {
                this.uploadDelegate.deletePinnedContent(hashMessageWrapper.getResourceHashMessage().hash());
                throw new io.nem.xpx.facade.upload.UploadException(e);
            };
            return new io.nem.xpx.facade.multisigupload.MultisigUploadResult(new io.nem.xpx.facade.upload.UploadResult(hashMessageWrapper.getResourceHashMessage(), publishedData), secretKey);
        }
    }
    MultisigUpload["__class"] = "io.nem.xpx.facade.multisigupload.MultisigUpload";

}
namespace io.nem.xpx.facade.search {
    /**
     * Instantiates a new search.
     * 
     * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection            the peer connection
     * @class
     * @extends io.nem.xpx.facade.AbstractFacadeService
     */
    export class Search extends io.nem.xpx.facade.AbstractFacadeService {
        /**
         * The peer connection.
         */
        /*private*/ peerConnection : io.nem.xpx.facade.connection.PeerConnection;

        /**
         * The engine.
         */
        engine : org.nem.core.crypto.CryptoEngine;

        /**
         * The search api.
         */
        searchApi : io.nem.xpx.service.intf.SearchApi;

        /**
         * The is local peer connection.
         */
        isLocalPeerConnection : boolean;

        public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection) {
            super();
            if(this.peerConnection===undefined) this.peerConnection = null;
            if(this.engine===undefined) this.engine = null;
            if(this.searchApi===undefined) this.searchApi = null;
            if(this.isLocalPeerConnection===undefined) this.isLocalPeerConnection = false;
            if(peerConnection == null) {
                throw new io.nem.xpx.exceptions.PeerConnectionNotFoundException("PeerConnection can\'t be null");
            }
            this.searchApi = peerConnection.getSearchApi();
            this.isLocalPeerConnection = peerConnection.isLocal();
            this.peerConnection = peerConnection;
            this.engine = org.nem.core.crypto.CryptoEngines.ed25519Engine();
        }

        /**
         * Search by name.
         * 
         * @param {string} xPvkey the x pvkey
         * @param {string} xPubkey the x pubkey
         * @param {string} name the name
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]} the list
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        public searchByName(xPvkey : string, xPubkey : string, name : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            return this.searchApi.searchTransactionWithNameUsingGET(xPvkey, xPubkey, name);
        }

        /**
         * Search by keyword.
         * 
         * @param {string} xPvkey the x pvkey
         * @param {string} xPubkey the x pubkey
         * @param {string} keywords the keywords
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]} the list
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        public searchByKeyword(xPvkey : string, xPubkey : string, keywords : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            return this.searchApi['searchTransactionWithKeywordUsingGET$java_lang_String$java_lang_String$java_lang_String'](xPvkey, xPubkey, keywords);
        }

        /**
         * Search by meta data key value.
         * 
         * @param {string} xPvkey the x pvkey
         * @param {string} xPubkey the x pubkey
         * @param {string} key the key
         * @param {string} value the value
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]} the string
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        public searchByMetaDataKeyValue(xPvkey : string, xPubkey : string, key : string, value : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            return this.searchApi.searchTransactionWithMetadataKeyValuePair(xPvkey, xPubkey, key, value);
        }
    }
    Search["__class"] = "io.nem.xpx.facade.search.Search";

}
namespace io.nem.xpx.facade.transaction {
    /**
     * Instantiates a new search.
     * 
     * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection
     * the peer connection
     * @throws PeerConnectionNotFoundException
     * the peer connection not found exception
     * @class
     * @extends io.nem.xpx.facade.AbstractFacadeService
     */
    export class Transaction extends io.nem.xpx.facade.AbstractFacadeService {
        /**
         * The peer connection.
         */
        /*private*/ peerConnection : io.nem.xpx.facade.connection.PeerConnection;

        /**
         * The engine.
         */
        /*private*/ engine : org.nem.core.crypto.CryptoEngine;

        /**
         * The account api.
         */
        /*private*/ accountApi : io.nem.xpx.service.intf.AccountApi;

        /**
         * The nem transaction api.
         */
        nemTransactionApi : io.nem.xpx.service.NemTransactionApi;

        /**
         * The is local peer connection.
         */
        /*private*/ isLocalPeerConnection : boolean;

        public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection) {
            super();
            if(this.peerConnection===undefined) this.peerConnection = null;
            if(this.engine===undefined) this.engine = null;
            if(this.accountApi===undefined) this.accountApi = null;
            if(this.nemTransactionApi===undefined) this.nemTransactionApi = null;
            if(this.isLocalPeerConnection===undefined) this.isLocalPeerConnection = false;
            if(peerConnection == null) {
                throw new io.nem.xpx.exceptions.PeerConnectionNotFoundException("PeerConnection can\'t be null");
            }
            this.accountApi = peerConnection.getAccountApi();
            this.isLocalPeerConnection = peerConnection.isLocal();
            this.peerConnection = peerConnection;
            this.nemTransactionApi = peerConnection.getNemTransactionApi();
            this.engine = org.nem.core.crypto.CryptoEngines.ed25519Engine();
        }

        /**
         * Gets the transaction.
         * 
         * @param {string} hash the hash
         * @return {org.nem.core.model.ncc.TransactionMetaDataPair} the transaction
         * @throws ApiException the api exception
         * @throws InterruptedException the interrupted exception
         * @throws ExecutionException the execution exception
         */
        public getTransaction(hash : string) : org.nem.core.model.ncc.TransactionMetaDataPair {
            let transaction : org.nem.core.model.ncc.TransactionMetaDataPair = this.nemTransactionApi.getTransaction(hash);
            return transaction;
        }

        /**
         * Gets the incoming transactions.
         * 
         * @param {string} publicKey
         * the public key
         * @return {org.nem.core.model.ncc.TransactionMetaDataPair[]} the incoming transactions
         * @throws ApiException
         * the api exception
         * @throws InterruptedException
         * the interrupted exception
         * @throws ExecutionException
         * the execution exception
         */
        public getIncomingTransactions(publicKey : string) : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let returnListOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = <any>([]);
            let listOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = this.nemTransactionApi.getIncomingTransactions$java_lang_String(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(publicKey)).getEncoded());
            for(let index180=0; index180 < listOfTxnMetaDataPair.length; index180++) {
                let metaDataPair = listOfTxnMetaDataPair[index180];
                {
                    if(this.checkIfTxnHaveXPXMosaic(metaDataPair.getEntity())) {
                        /* add */(returnListOfTxnMetaDataPair.push(metaDataPair)>0);
                    }
                }
            }
            return returnListOfTxnMetaDataPair;
        }

        /**
         * Gets the all transactions.
         * 
         * @param {string} publicKey
         * the public key
         * @return {org.nem.core.model.ncc.TransactionMetaDataPair[]} the all transactions
         * @throws ApiException
         * the api exception
         * @throws InterruptedException
         * the interrupted exception
         * @throws ExecutionException
         * the execution exception
         */
        public getAllTransactions(publicKey : string) : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let returnListOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = <any>([]);
            let listOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = this.nemTransactionApi.getAllTransactions$java_lang_String(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(publicKey)).getEncoded());
            for(let index181=0; index181 < listOfTxnMetaDataPair.length; index181++) {
                let metaDataPair = listOfTxnMetaDataPair[index181];
                {
                    if(this.checkIfTxnHaveXPXMosaic(metaDataPair.getEntity())) {
                        /* add */(returnListOfTxnMetaDataPair.push(metaDataPair)>0);
                    }
                }
            }
            return returnListOfTxnMetaDataPair;
        }

        /**
         * Gets the outgoing transactions.
         * 
         * @param {string} publicKey            the public key
         * @return {org.nem.core.model.ncc.TransactionMetaDataPair[]} the outgoing transactions
         * @throws ApiException             the api exception
         * @throws InterruptedException             the interrupted exception
         * @throws ExecutionException             the execution exception
         */
        public getOutgoingTransactions(publicKey : string) : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let returnListOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = <any>([]);
            let listOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = this.nemTransactionApi.getOutgoingTransactions$java_lang_String(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(publicKey)).getEncoded());
            for(let index182=0; index182 < listOfTxnMetaDataPair.length; index182++) {
                let metaDataPair = listOfTxnMetaDataPair[index182];
                {
                    if(this.checkIfTxnHaveXPXMosaic(metaDataPair.getEntity())) {
                        /* add */(returnListOfTxnMetaDataPair.push(metaDataPair)>0);
                    }
                }
            }
            return returnListOfTxnMetaDataPair;
        }

        /**
         * Gets the unconfirmed transactions.
         * 
         * @param {string} publicKey            the public key
         * @return {org.nem.core.model.ncc.TransactionMetaDataPair[]} the unconfirmed transactions
         * @throws ApiException             the api exception
         * @throws InterruptedException             the interrupted exception
         * @throws ExecutionException             the execution exception
         */
        public getUnconfirmedTransactions(publicKey : string) : Array<org.nem.core.model.ncc.TransactionMetaDataPair> {
            let returnListOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = <any>([]);
            let listOfTxnMetaDataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = this.nemTransactionApi.getUnconfirmedTransactions(org.nem.core.model.Address.fromPublicKey(org.nem.core.crypto.PublicKey.fromHexString(publicKey)).getEncoded());
            for(let index183=0; index183 < listOfTxnMetaDataPair.length; index183++) {
                let metaDataPair = listOfTxnMetaDataPair[index183];
                {
                    if(this.checkIfTxnHaveXPXMosaic(metaDataPair.getEntity())) {
                        /* add */(returnListOfTxnMetaDataPair.push(metaDataPair)>0);
                    }
                }
            }
            return returnListOfTxnMetaDataPair;
        }
    }
    Transaction["__class"] = "io.nem.xpx.facade.transaction.Transaction";

}
namespace io.nem.xpx.facade.upload {
    /**
     * Instantiates a new upload.
     * 
     * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection
     * the peer connection
     * @throws PeerConnectionNotFoundException
     * the peer connection not found exception
     * @class
     * @extends io.nem.xpx.facade.AbstractFacadeService
     */
    export class Upload extends io.nem.xpx.facade.AbstractFacadeService {
        /**
         * The peer connection.
         */
        /*private*/ peerConnection : io.nem.xpx.facade.connection.PeerConnection;

        /**
         * The upload api.
         */
        /*private*/ uploadApi : io.nem.xpx.service.intf.UploadApi;

        /**
         * The transaction announcer.
         */
        /*private*/ transactionAnnouncer : io.nem.xpx.service.TransactionAnnouncer;

        /*private*/ uploadDelegate : io.nem.xpx.service.UploadDelegate;

        /*private*/ ipfsGatewaySyncService : io.nem.xpx.service.IpfsGatewaySyncService;

        public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection) {
            super();
            if(this.peerConnection===undefined) this.peerConnection = null;
            if(this.uploadApi===undefined) this.uploadApi = null;
            if(this.transactionAnnouncer===undefined) this.transactionAnnouncer = null;
            if(this.uploadDelegate===undefined) this.uploadDelegate = null;
            if(this.ipfsGatewaySyncService===undefined) this.ipfsGatewaySyncService = null;
            if(peerConnection == null) {
                throw new io.nem.xpx.exceptions.PeerConnectionNotFoundException("PeerConnection can\'t be null");
            }
            this.uploadApi = peerConnection.getUploadApi();
            this.transactionAnnouncer = peerConnection.getTransactionAnnouncer();
            this.peerConnection = peerConnection;
            this.uploadDelegate = new io.nem.xpx.service.UploadDelegate(peerConnection.getUploadApi());
            this.ipfsGatewaySyncService = new io.nem.xpx.service.IpfsGatewaySyncService(peerConnection.getSyncGateways());
        }

        /**
         * Upload file.
         * 
         * @param {io.nem.xpx.facade.upload.UploadFileParameter} param
         * the upload parameter
         * @return {io.nem.xpx.facade.upload.UploadResult} the upload data
         * @throws UploadException
         * the upload exception
         */
        public uploadFile(param : io.nem.xpx.facade.upload.UploadFileParameter) : io.nem.xpx.facade.upload.UploadResult {
            try {
                let binaryContent : number[] = org.apache.commons.io.FileUtils.readFileToByteArray(param.getFile());
                return this.handleBinaryUpload(param.getPrivacyStrategy(), param.getSenderPrivateKey(), param.getReceiverPublicKey(), param.getContentType(), param.getKeywords(), param.getMetaDataAsString(), param.getName(), param.getMosaics(), binaryContent);
            } catch(__e) {
                if(__e != null && __e instanceof <any>io.nem.xpx.facade.upload.UploadException) {
                    let e : io.nem.xpx.facade.upload.UploadException = <io.nem.xpx.facade.upload.UploadException>__e;
                    throw e;

                }
                if(__e != null && (__e["__classes"] && __e["__classes"].indexOf("java.lang.Exception") >= 0) || __e != null && __e instanceof <any>Error) {
                    let e : Error = <Error>__e;
                    throw new io.nem.xpx.facade.upload.UploadException(java.lang.String.format("Error on uploading file data: %s", param.getFile().getAbsolutePath()), e);

                }
            };
        }

        /**
         * Upload data.
         * 
         * @param {io.nem.xpx.facade.upload.UploadTextDataParameter} param
         * the upload parameter
         * @return {io.nem.xpx.facade.upload.UploadResult} the upload data
         * @throws UploadException
         * the upload exception
         */
        public uploadTextData(param : io.nem.xpx.facade.upload.UploadTextDataParameter) : io.nem.xpx.facade.upload.UploadResult {
            return this.handleTextDataUpload(param.getPrivacyStrategy(), param.getSenderPrivateKey(), param.getReceiverPublicKey(), param.getContentType(), param.getKeywords(), param.getMetaDataAsString(), param.getName(), param.getMosaics(), param.getData(), param.getEncoding());
        }

        /**
         * Upload a binary file.
         * 
         * @param {io.nem.xpx.facade.upload.UploadBinaryParameter} param the upload parameter
         * @return {io.nem.xpx.facade.upload.UploadResult} the upload data
         * @throws UploadException the upload exception
         */
        public uploadBinary(param : io.nem.xpx.facade.upload.UploadBinaryParameter) : io.nem.xpx.facade.upload.UploadResult {
            try {
                return this.handleBinaryUpload(param.getPrivacyStrategy(), param.getSenderPrivateKey(), param.getReceiverPublicKey(), param.getContentType(), param.getKeywords(), param.getMetaDataAsString(), param.getName(), param.getMosaics(), param.getData());
            } catch(__e) {
                if(__e != null && __e instanceof <any>io.nem.xpx.facade.upload.UploadException) {
                    let e : io.nem.xpx.facade.upload.UploadException = <io.nem.xpx.facade.upload.UploadException>__e;
                    throw e;

                }
                if(__e != null && (__e["__classes"] && __e["__classes"].indexOf("java.lang.Exception") >= 0) || __e != null && __e instanceof <any>Error) {
                    let e : Error = <Error>__e;
                    throw new io.nem.xpx.facade.upload.UploadException("Error on uploading binary data", e);

                }
            };
        }

        /**
         * Upload path.
         * 
         * @param {io.nem.xpx.facade.upload.UploadPathParameter} param            the upload parameter
         * @return {io.nem.xpx.facade.upload.UploadResult} the upload data
         * @throws UploadException             the upload exception
         */
        public uploadPath(param : io.nem.xpx.facade.upload.UploadPathParameter) : io.nem.xpx.facade.upload.UploadResult {
            try {
                let resourceHashMessageWrapper : io.nem.xpx.service.UploadDelegate.ResourceHashMessageWrapper = this.uploadDelegate.uploadPathToIpfs(param.getPath(), param.getName(), param.getKeywords(), param.getMetaDataAsString());
                return this.handlePostUpload(param.getPrivacyStrategy(), param.getSenderPrivateKey(), param.getReceiverPublicKey(), param.getMosaics(), resourceHashMessageWrapper);
            } catch(__e) {
                if(__e != null && __e instanceof <any>io.nem.xpx.facade.upload.UploadException) {
                    let e : io.nem.xpx.facade.upload.UploadException = <io.nem.xpx.facade.upload.UploadException>__e;
                    throw e;

                }
                if(__e != null && (__e["__classes"] && __e["__classes"].indexOf("java.lang.Exception") >= 0) || __e != null && __e instanceof <any>Error) {
                    let e : Error = <Error>__e;
                    throw new io.nem.xpx.facade.upload.UploadException(java.lang.String.format("Error on uploading path: %s", param.getPath()), e);

                }
            };
        }

        /**
         * Upload files as zip.
         * 
         * @param {io.nem.xpx.facade.upload.UploadFilesAsZipParameter} param the param
         * @return {io.nem.xpx.facade.upload.UploadResult} the upload result
         * @throws UploadException the upload exception
         */
        public uploadFilesAsZip(param : io.nem.xpx.facade.upload.UploadFilesAsZipParameter) : io.nem.xpx.facade.upload.UploadResult {
            try {
                let binaryContent : number[] = this.zipFiles(param.getFiles());
                return this.handleBinaryUpload(param.getPrivacyStrategy(), param.getSenderPrivateKey(), param.getReceiverPublicKey(), param.getContentType(), param.getKeywords(), param.getMetaDataAsString(), param.getName(), param.getMosaics(), binaryContent);
            } catch(__e) {
                if(__e != null && __e instanceof <any>io.nem.xpx.facade.upload.UploadException) {
                    let e : io.nem.xpx.facade.upload.UploadException = <io.nem.xpx.facade.upload.UploadException>__e;
                    throw e;

                }
                if(__e != null && (__e["__classes"] && __e["__classes"].indexOf("java.lang.Exception") >= 0) || __e != null && __e instanceof <any>Error) {
                    let e : Error = <Error>__e;
                    throw new io.nem.xpx.facade.upload.UploadException("Error on uploading files as zip", e);

                }
            };
        }

        /**
         * Upload multiple files.
         * 
         * @param {io.nem.xpx.facade.upload.UploadMultipleFilesParameter} param the param
         * @return {io.nem.xpx.facade.upload.MultiFileUploadResult} the multi file upload result
         * @throws UploadException the upload exception
         */
        public uploadMultipleFiles(param : io.nem.xpx.facade.upload.UploadMultipleFilesParameter) : io.nem.xpx.facade.upload.MultiFileUploadResult {
            if(/* size */(<number>param.getFiles().length) === 0) throw new io.nem.xpx.facade.upload.UploadException("No file to upload");
            let fileUploadResults : Array<io.nem.xpx.facade.upload.MultiFileUploadResult.FileUploadResult> = <any>(param.getFiles().parallelStream().map<any>((file) => {
                try {
                    let binaryContent : number[] = org.apache.commons.io.FileUtils.readFileToByteArray(file);
                    return new io.nem.xpx.facade.upload.MultiFileUploadResult.FileUploadResult(file, this.handleBinaryUpload(param.getPrivacyStrategy(), param.getSenderPrivateKey(), param.getReceiverPublicKey(), io.nem.xpx.utils.ContentTypeUtils.detectContentType$byte_A(binaryContent), param.getKeywords(), param.getMetaDataAsString(), file.getName(), param.getMosaics(), binaryContent));
                } catch(e) {
                    return new io.nem.xpx.facade.upload.MultiFileUploadResult.FileUploadResult(file, new io.nem.xpx.facade.upload.UploadException(java.lang.String.format("Error on uploading file data: %s", file.getAbsolutePath()), e));
                };
            }).collect<any, any>(java.util.stream.Collectors.toList<any>()));
            return new io.nem.xpx.facade.upload.MultiFileUploadResult(fileUploadResults);
        }

        /**
         * Upload from URL.
         * 
         * @param {io.nem.xpx.facade.upload.UploadFromUrlParameter} param
         * the upload parameter
         * @return {io.nem.xpx.facade.upload.UploadResult} the upload data
         * @throws UploadException
         * the upload exception
         */
        public uploadFromUrl(param : io.nem.xpx.facade.upload.UploadFromUrlParameter) : io.nem.xpx.facade.upload.UploadResult {
            try {
                let downloadedBinary : number[] = org.apache.commons.io.IOUtils.toByteArray(param.getUrl());
                let contentTypeOrDetected : string = param.getContentType() != null?param.getContentType():io.nem.xpx.utils.ContentTypeUtils.detectContentType$byte_A(downloadedBinary);
                return this.handleBinaryUpload(param.getPrivacyStrategy(), param.getSenderPrivateKey(), param.getReceiverPublicKey(), contentTypeOrDetected, param.getKeywords(), param.getMetaDataAsString(), param.getName(), param.getMosaics(), downloadedBinary);
            } catch(__e) {
                if(__e != null && __e instanceof <any>io.nem.xpx.facade.upload.UploadException) {
                    let e : io.nem.xpx.facade.upload.UploadException = <io.nem.xpx.facade.upload.UploadException>__e;
                    throw e;

                }
                if(__e != null && (__e["__classes"] && __e["__classes"].indexOf("java.lang.Exception") >= 0) || __e != null && __e instanceof <any>Error) {
                    let e : Error = <Error>__e;
                    throw new io.nem.xpx.facade.upload.UploadException(java.lang.String.format("Error on uploading from URL: %s", param.getUrl().toString()), e);

                }
            };
        }

        /**
         * Handle text data upload.
         * 
         * @param {io.nem.xpx.strategy.privacy.PrivacyStrategy} privacyStrategy the privacy strategy
         * @param {string} senderPrivateKey the sender private key
         * @param {string} receiverPublicKey the receiver public key
         * @param {string} contentType the content type
         * @param {string} keywords the keywords
         * @param {string} metadata the metadata
         * @param {string} name the name
         * @param {Array} mosaics the mosaics
         * @param {string} textData the text data
         * @param {string} encoding the encoding
         * @return {io.nem.xpx.facade.upload.UploadResult} the upload result
         * @throws UploadException the upload exception
         * @private
         */
        /*private*/ handleTextDataUpload(privacyStrategy : io.nem.xpx.strategy.privacy.PrivacyStrategy, senderPrivateKey : string, receiverPublicKey : string, contentType : string, keywords : string, metadata : string, name : string, mosaics : org.nem.core.model.mosaic.Mosaic[], textData : string, encoding : string) : io.nem.xpx.facade.upload.UploadResult {
            try {
                let textInBytes : number[] = /* getBytes */(textData).split('').map(s => s.charCodeAt(0));
                let encryptedTextInBytes : number[] = privacyStrategy.encrypt(textInBytes);
                let hashMessageWrapper : io.nem.xpx.service.UploadDelegate.ResourceHashMessageWrapper = this.uploadDelegate.uploadTextToIpfs(encryptedTextInBytes, name, contentType, encoding, keywords, metadata);
                return this.handlePostUpload(privacyStrategy, senderPrivateKey, receiverPublicKey, mosaics, hashMessageWrapper);
            } catch(__e) {
                if(__e != null && __e instanceof <any>io.nem.xpx.facade.upload.UploadException) {
                    let e : io.nem.xpx.facade.upload.UploadException = <io.nem.xpx.facade.upload.UploadException>__e;
                    throw e;

                }
                if(__e != null && (__e["__classes"] && __e["__classes"].indexOf("java.lang.Exception") >= 0) || __e != null && __e instanceof <any>Error) {
                    let e : Error = <Error>__e;
                    throw new io.nem.xpx.facade.upload.UploadException("Error on uploading text data", e);

                }
            };
        }

        /**
         * Handle binary upload.
         * 
         * @param {io.nem.xpx.strategy.privacy.PrivacyStrategy} privacyStrategy the privacy strategy
         * @param {string} senderPrivateKey the sender private key
         * @param {string} receiverPublicKey the receiver public key
         * @param {string} contentType the content type
         * @param {string} keywords the keywords
         * @param {string} metadata the metadata
         * @param {string} name the name
         * @param {Array} mosaics the mosaics
         * @param {Array} binaryContent the binary content
         * @return {io.nem.xpx.facade.upload.UploadResult} the upload result
         * @throws UploadException the upload exception
         * @private
         */
        /*private*/ handleBinaryUpload(privacyStrategy : io.nem.xpx.strategy.privacy.PrivacyStrategy, senderPrivateKey : string, receiverPublicKey : string, contentType : string, keywords : string, metadata : string, name : string, mosaics : org.nem.core.model.mosaic.Mosaic[], binaryContent : number[]) : io.nem.xpx.facade.upload.UploadResult {
            try {
                let encryptedContent : number[] = privacyStrategy.encrypt(binaryContent);
                let hashMessageWrapper : io.nem.xpx.service.UploadDelegate.ResourceHashMessageWrapper = this.uploadDelegate.uploadBinaryToIpfs(encryptedContent, name, contentType, keywords, metadata);
                return this.handlePostUpload(privacyStrategy, senderPrivateKey, receiverPublicKey, mosaics, hashMessageWrapper);
            } catch(__e) {
                if(__e != null && __e instanceof <any>io.nem.xpx.facade.upload.UploadException) {
                    let e : io.nem.xpx.facade.upload.UploadException = <io.nem.xpx.facade.upload.UploadException>__e;
                    throw e;

                }
                if(__e != null && (__e["__classes"] && __e["__classes"].indexOf("java.lang.Exception") >= 0) || __e != null && __e instanceof <any>Error) {
                    let e : Error = <Error>__e;
                    throw new io.nem.xpx.facade.upload.UploadException("Error on uploading binary data", e);

                }
            };
        }

        /**
         * Zip files.
         * 
         * @param {java.io.File[]} files the files
         * @return {Array} the byte[]
         * @throws UploadException the upload exception
         * @private
         */
        /*private*/ zipFiles(files : Array<java.io.File>) : number[] {
            this.validateZipFilesArguments(files);
            let baos : java.io.ByteArrayOutputStream = new java.io.ByteArrayOutputStream();
            let zos : java.util.zip.ZipOutputStream = new java.util.zip.ZipOutputStream(baos);
            try {
                for(let index184=0; index184 < files.length; index184++) {
                    let file = files[index184];
                    {
                        let entry : java.util.zip.ZipEntry = new java.util.zip.ZipEntry(file.getName());
                        zos.putNextEntry(entry);
                        zos.write(org.apache.commons.io.FileUtils.readFileToByteArray(file));
                        zos.closeEntry();
                    }
                }
            } catch(e) {
                throw new io.nem.xpx.facade.upload.UploadException(java.lang.String.format("Unable to zip files together: %s", javaemul.internal.StringHelper.join(",", files.stream().map<any>((file) => file.getAbsolutePath()).collect<any, any>(java.util.stream.Collectors.toList<any>()))), e);
            } finally {
                zos.close();
            };
            return baos.toByteArray();
        }

        /**
         * Validate zip files arguments.
         * 
         * @param {java.io.File[]} files the files
         * @throws UploadException the upload exception
         * @private
         */
        /*private*/ validateZipFilesArguments(files : Array<java.io.File>) {
            if(/* size */(<number>files.length) === 0) throw new io.nem.xpx.facade.upload.UploadException("No file to upload");
            let uniqueFileNameCount : number = files.stream().map<any>((file) => file.getName()).distinct().count();
            if(uniqueFileNameCount < /* size */(<number>files.length)) throw new io.nem.xpx.facade.upload.UploadException(java.lang.String.format("File names should be unique to zip files together: %s", javaemul.internal.StringHelper.join(",", files.stream().map<any>((file) => file.getName()).collect<any, any>(java.util.stream.Collectors.toList<any>()))));
        }

        /**
         * Handle post upload.
         * 
         * @param {io.nem.xpx.strategy.privacy.PrivacyStrategy} privacyStrategy the privacy strategy
         * @param {string} senderPrivateKey the sender private key
         * @param {string} receiverPublicKey the receiver public key
         * @param {Array} mosaics the mosaics
         * @return {io.nem.xpx.facade.upload.UploadResult} the upload result
         * @throws Exception the exception
         * @param {io.nem.xpx.service.UploadDelegate.ResourceHashMessageWrapper} hashMessageWrapper
         * @private
         */
        /*private*/ handlePostUpload(privacyStrategy : io.nem.xpx.strategy.privacy.PrivacyStrategy, senderPrivateKey : string, receiverPublicKey : string, mosaics : org.nem.core.model.mosaic.Mosaic[], hashMessageWrapper : io.nem.xpx.service.UploadDelegate.ResourceHashMessageWrapper) : io.nem.xpx.facade.upload.UploadResult {
            try {
                let nemHash : string = this.createNemTransaction(privacyStrategy, senderPrivateKey, receiverPublicKey, mosaics, hashMessageWrapper.getData());
                this.ipfsGatewaySyncService.syncToGatewaysAsynchronously(hashMessageWrapper.getResourceHashMessage().hash());
                return new io.nem.xpx.facade.upload.UploadResult(hashMessageWrapper.getResourceHashMessage(), nemHash);
            } catch(e) {
                java.util.concurrent.Executors.newSingleThreadExecutor().submit<any>(() => this.uploadDelegate.deletePinnedContent(hashMessageWrapper.getResourceHashMessage().hash()));
                throw e;
            };
        }

        /**
         * Creates the nem transaction.
         * 
         * @param {io.nem.xpx.strategy.privacy.PrivacyStrategy} privacyStrategy the privacy strategy
         * @param {string} senderPrivateKey the sender private key
         * @param {string} receiverPublicKey the receiver public key
         * @param {Array} mosaics the mosaics
         * @param {Array} response the response
         * @return {string} the string
         * @throws Exception the exception
         * @private
         */
        /*private*/ createNemTransaction(privacyStrategy : io.nem.xpx.strategy.privacy.PrivacyStrategy, senderPrivateKey : string, receiverPublicKey : string, mosaics : org.nem.core.model.mosaic.Mosaic[], response : number[]) : string {
            let nemMessage : org.nem.core.model.Message = privacyStrategy.encodeToMessage(response);
            return this.transactionAnnouncer.announceTransactionForUploadedContent(nemMessage, senderPrivateKey, receiverPublicKey, mosaics);
        }
    }
    Upload["__class"] = "io.nem.xpx.facade.upload.Upload";

}
namespace io.nem.xpx.facade.connection {
    /**
     * The Class AbstractLocalPeerConnection.
     * @extends io.nem.xpx.facade.connection.PeerConnection
     * @class
     */
    export abstract class AbstractLocalPeerConnection extends io.nem.xpx.facade.connection.PeerConnection {
        /**
         * The Ipfs *.
         */
        /*private*/ proximaxIpfsConnection : io.ipfs.api.IPFS;

        /**
         * The account api.
         */
        /*private*/ accountApi : io.nem.xpx.service.intf.AccountApi;

        /**
         * The data hash api.
         */
        /*private*/ dataHashApi : io.nem.xpx.service.intf.DataHashApi;

        /**
         * The download api.
         */
        /*private*/ downloadApi : io.nem.xpx.service.intf.DownloadApi;

        /**
         * The node api.
         */
        /*private*/ nodeApi : io.nem.xpx.service.intf.NodeApi;

        /**
         * The publish and subscribe api.
         */
        /*private*/ publishAndSubscribeApi : io.nem.xpx.service.intf.PublishAndSubscribeApi;

        /**
         * The search api.
         */
        /*private*/ searchApi : io.nem.xpx.service.intf.SearchApi;

        /**
         * The transaction and announce api.
         */
        /*private*/ transactionAndAnnounceApi : io.nem.xpx.service.intf.TransactionAndAnnounceApi;

        /*private*/ fileAndNamingRouteApi : io.nem.xpx.service.common.FileAndNamingRouteApi;

        /**
         * The upload api.
         */
        /*private*/ uploadApi : io.nem.xpx.service.intf.UploadApi;

        /**
         * The async nem connector.
         */
        /*private*/ __io_nem_xpx_facade_connection_AbstractLocalPeerConnection_asyncNemConnector : org.nem.core.connect.client.DefaultAsyncNemConnector<org.nem.core.node.ApiId>;

        /**
         * The nem transaction api.
         */
        /*private*/ __io_nem_xpx_facade_connection_AbstractLocalPeerConnection_nemTransactionApi : io.nem.xpx.service.NemTransactionApi;

        /**
         * The nem account api.
         */
        /*private*/ __io_nem_xpx_facade_connection_AbstractLocalPeerConnection_nemAccountApi : io.nem.xpx.service.NemAccountApi;

        /**
         * The transaction sender.
         */
        /*private*/ __io_nem_xpx_facade_connection_AbstractLocalPeerConnection_transactionSender : io.nem.xpx.service.TransactionSender;

        /**
         * The transaction fee calculators.
         */
        /*private*/ __io_nem_xpx_facade_connection_AbstractLocalPeerConnection_transactionFeeCalculators : io.nem.xpx.service.TransactionFeeCalculators;

        constructor(nodeEndpoint : org.nem.core.node.NodeEndpoint, ipfsConnection : io.ipfs.api.IPFS, syncGateways : Array<string>) {
            super();
            if(this.proximaxIpfsConnection===undefined) this.proximaxIpfsConnection = null;
            if(this.accountApi===undefined) this.accountApi = null;
            if(this.dataHashApi===undefined) this.dataHashApi = null;
            if(this.downloadApi===undefined) this.downloadApi = null;
            if(this.nodeApi===undefined) this.nodeApi = null;
            if(this.publishAndSubscribeApi===undefined) this.publishAndSubscribeApi = null;
            if(this.searchApi===undefined) this.searchApi = null;
            if(this.transactionAndAnnounceApi===undefined) this.transactionAndAnnounceApi = null;
            if(this.fileAndNamingRouteApi===undefined) this.fileAndNamingRouteApi = null;
            if(this.uploadApi===undefined) this.uploadApi = null;
            if(this.__io_nem_xpx_facade_connection_AbstractLocalPeerConnection_asyncNemConnector===undefined) this.__io_nem_xpx_facade_connection_AbstractLocalPeerConnection_asyncNemConnector = null;
            if(this.__io_nem_xpx_facade_connection_AbstractLocalPeerConnection_nemTransactionApi===undefined) this.__io_nem_xpx_facade_connection_AbstractLocalPeerConnection_nemTransactionApi = null;
            if(this.__io_nem_xpx_facade_connection_AbstractLocalPeerConnection_nemAccountApi===undefined) this.__io_nem_xpx_facade_connection_AbstractLocalPeerConnection_nemAccountApi = null;
            if(this.__io_nem_xpx_facade_connection_AbstractLocalPeerConnection_transactionSender===undefined) this.__io_nem_xpx_facade_connection_AbstractLocalPeerConnection_transactionSender = null;
            if(this.__io_nem_xpx_facade_connection_AbstractLocalPeerConnection_transactionFeeCalculators===undefined) this.__io_nem_xpx_facade_connection_AbstractLocalPeerConnection_transactionFeeCalculators = null;
            this.nodeEndpoint = nodeEndpoint;
            this.proximaxIpfsConnection = ipfsConnection;
            this.setSyncGateways(syncGateways);
        }

        /**
         * 
         * @return {boolean}
         */
        public isLocal() : boolean {
            return true;
        }

        /**
         * 
         * @return {*}
         */
        public getAccountApi() : io.nem.xpx.service.intf.AccountApi {
            if(this.accountApi == null) this.accountApi = new io.nem.xpx.service.local.LocalAccountApi(this.getNemTransactionApi());
            return this.accountApi;
        }

        /**
         * 
         * @return {*}
         */
        public getDataHashApi() : io.nem.xpx.service.intf.DataHashApi {
            if(this.dataHashApi == null) this.dataHashApi = new io.nem.xpx.service.local.LocalDataHashApi(this.proximaxIpfsConnection);
            return this.dataHashApi;
        }

        /**
         * 
         * @return {*}
         */
        public getDirectoryLoadApi() : io.nem.xpx.service.intf.DirectoryLoadApi {
            throw Object.defineProperty(new Error("not supported"), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
        }

        /**
         * 
         * @return {io.nem.xpx.service.common.FileAndNamingRouteApi}
         */
        public getFileAndNamingRouteApi() : io.nem.xpx.service.common.FileAndNamingRouteApi {
            throw Object.defineProperty(new Error("not supported"), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
        }

        /**
         * 
         * @return {*}
         */
        public getDownloadApi() : io.nem.xpx.service.intf.DownloadApi {
            if(this.downloadApi == null) this.downloadApi = new io.nem.xpx.service.local.LocalDownloadApi(this.getNemTransactionApi(), this.proximaxIpfsConnection);
            return this.downloadApi;
        }

        /**
         * 
         * @return {*}
         */
        public getNodeApi() : io.nem.xpx.service.intf.NodeApi {
            if(this.nodeApi == null) this.nodeApi = new io.nem.xpx.service.local.LocalNodeApi(this.proximaxIpfsConnection);
            return this.nodeApi;
        }

        /**
         * 
         * @return {*}
         */
        public getPublishAndSubscribeApi() : io.nem.xpx.service.intf.PublishAndSubscribeApi {
            if(this.publishAndSubscribeApi == null) this.publishAndSubscribeApi = new io.nem.xpx.service.local.LocalPublishAndSubscribeApi(this.proximaxIpfsConnection);
            return this.publishAndSubscribeApi;
        }

        /**
         * 
         * @return {*}
         */
        public getSearchApi() : io.nem.xpx.service.intf.SearchApi {
            if(this.searchApi == null) this.searchApi = new io.nem.xpx.service.local.LocalSearchApi(this.getNemTransactionApi());
            return this.searchApi;
        }

        /**
         * 
         * @return {*}
         */
        public getTransactionAndAnnounceApi() : io.nem.xpx.service.intf.TransactionAndAnnounceApi {
            if(this.transactionAndAnnounceApi == null) this.transactionAndAnnounceApi = new io.nem.xpx.service.local.LocalTransactionAndAnnounceApi(this.getNemTransactionApi());
            return this.transactionAndAnnounceApi;
        }

        /**
         * 
         * @return {*}
         */
        public getUploadApi() : io.nem.xpx.service.intf.UploadApi {
            if(this.uploadApi == null) this.uploadApi = new io.nem.xpx.service.local.LocalUploadApi(this.proximaxIpfsConnection);
            return this.uploadApi;
        }
    }
    AbstractLocalPeerConnection["__class"] = "io.nem.xpx.facade.connection.AbstractLocalPeerConnection";

}
namespace io.nem.xpx.facade.connection {
    /**
     * Instantiates a new remote peer connection.
     * 
     * @param {string} baseUrl the base url
     * @param {Array} syncGateways list of gateway URLs where uploads will be sync
     * @class
     * @extends io.nem.xpx.facade.connection.PeerConnection
     */
    export class RemotePeerConnection extends io.nem.xpx.facade.connection.PeerConnection {
        /**
         * The api client.
         */
        /*private*/ apiClient : io.nem.ApiClient;

        /**
         * The account api.
         */
        /*private*/ accountApi : io.nem.xpx.service.intf.AccountApi;

        /**
         * The data hash api.
         */
        /*private*/ dataHashApi : io.nem.xpx.service.intf.DataHashApi;

        /**
         * The directory load api.
         */
        /*private*/ directoryLoadApi : io.nem.xpx.service.intf.DirectoryLoadApi;

        /**
         * The download api.
         */
        /*private*/ downloadApi : io.nem.xpx.service.intf.DownloadApi;

        /**
         * The node api.
         */
        /*private*/ nodeApi : io.nem.xpx.service.intf.NodeApi;

        /**
         * The publish and subscribe api.
         */
        /*private*/ publishAndSubscribeApi : io.nem.xpx.service.intf.PublishAndSubscribeApi;

        /**
         * The search api.
         */
        /*private*/ searchApi : io.nem.xpx.service.intf.SearchApi;

        /**
         * The transaction and announce api.
         */
        /*private*/ transactionAndAnnounceApi : io.nem.xpx.service.intf.TransactionAndAnnounceApi;

        /*private*/ fileAndNamingRouteApi : io.nem.xpx.service.common.FileAndNamingRouteApi;

        /**
         * The upload api.
         */
        /*private*/ uploadApi : io.nem.xpx.service.intf.UploadApi;

        public constructor(baseUrl? : any, syncGateways? : any, remoteNodeApi? : any) {
            if(((typeof baseUrl === 'string') || baseUrl === null) && ((syncGateways != null && (syncGateways instanceof Array)) || syncGateways === null) && ((remoteNodeApi != null && remoteNodeApi instanceof <any>io.nem.xpx.service.remote.RemoteNodeApi) || remoteNodeApi === null)) {
                let __args = Array.prototype.slice.call(arguments);
                super();
                if(this.apiClient===undefined) this.apiClient = null;
                if(this.accountApi===undefined) this.accountApi = null;
                if(this.dataHashApi===undefined) this.dataHashApi = null;
                if(this.directoryLoadApi===undefined) this.directoryLoadApi = null;
                if(this.downloadApi===undefined) this.downloadApi = null;
                if(this.nodeApi===undefined) this.nodeApi = null;
                if(this.publishAndSubscribeApi===undefined) this.publishAndSubscribeApi = null;
                if(this.searchApi===undefined) this.searchApi = null;
                if(this.transactionAndAnnounceApi===undefined) this.transactionAndAnnounceApi = null;
                if(this.fileAndNamingRouteApi===undefined) this.fileAndNamingRouteApi = null;
                if(this.uploadApi===undefined) this.uploadApi = null;
                if(this.apiClient===undefined) this.apiClient = null;
                if(this.accountApi===undefined) this.accountApi = null;
                if(this.dataHashApi===undefined) this.dataHashApi = null;
                if(this.directoryLoadApi===undefined) this.directoryLoadApi = null;
                if(this.downloadApi===undefined) this.downloadApi = null;
                if(this.nodeApi===undefined) this.nodeApi = null;
                if(this.publishAndSubscribeApi===undefined) this.publishAndSubscribeApi = null;
                if(this.searchApi===undefined) this.searchApi = null;
                if(this.transactionAndAnnounceApi===undefined) this.transactionAndAnnounceApi = null;
                if(this.fileAndNamingRouteApi===undefined) this.fileAndNamingRouteApi = null;
                if(this.uploadApi===undefined) this.uploadApi = null;
                (() => {
                    this.init(baseUrl, syncGateways, remoteNodeApi);
                })();
            } else if(((typeof baseUrl === 'string') || baseUrl === null) && ((syncGateways != null && syncGateways instanceof <any>Array && (syncGateways.length==0 || syncGateways[0] == null ||(typeof syncGateways[0] === 'string'))) || syncGateways === null) && remoteNodeApi === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                {
                    let __args = Array.prototype.slice.call(arguments);
                    let syncGateways : any = /* asList */__args[1].slice(0);
                    super();
                    if(this.apiClient===undefined) this.apiClient = null;
                    if(this.accountApi===undefined) this.accountApi = null;
                    if(this.dataHashApi===undefined) this.dataHashApi = null;
                    if(this.directoryLoadApi===undefined) this.directoryLoadApi = null;
                    if(this.downloadApi===undefined) this.downloadApi = null;
                    if(this.nodeApi===undefined) this.nodeApi = null;
                    if(this.publishAndSubscribeApi===undefined) this.publishAndSubscribeApi = null;
                    if(this.searchApi===undefined) this.searchApi = null;
                    if(this.transactionAndAnnounceApi===undefined) this.transactionAndAnnounceApi = null;
                    if(this.fileAndNamingRouteApi===undefined) this.fileAndNamingRouteApi = null;
                    if(this.uploadApi===undefined) this.uploadApi = null;
                    if(this.apiClient===undefined) this.apiClient = null;
                    if(this.accountApi===undefined) this.accountApi = null;
                    if(this.dataHashApi===undefined) this.dataHashApi = null;
                    if(this.directoryLoadApi===undefined) this.directoryLoadApi = null;
                    if(this.downloadApi===undefined) this.downloadApi = null;
                    if(this.nodeApi===undefined) this.nodeApi = null;
                    if(this.publishAndSubscribeApi===undefined) this.publishAndSubscribeApi = null;
                    if(this.searchApi===undefined) this.searchApi = null;
                    if(this.transactionAndAnnounceApi===undefined) this.transactionAndAnnounceApi = null;
                    if(this.fileAndNamingRouteApi===undefined) this.fileAndNamingRouteApi = null;
                    if(this.uploadApi===undefined) this.uploadApi = null;
                    (() => {
                        this.init(baseUrl, syncGateways, null);
                    })();
                }
            } else if(((typeof baseUrl === 'string') || baseUrl === null) && ((syncGateways != null && (syncGateways instanceof Array)) || syncGateways === null) && remoteNodeApi === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                super();
                if(this.apiClient===undefined) this.apiClient = null;
                if(this.accountApi===undefined) this.accountApi = null;
                if(this.dataHashApi===undefined) this.dataHashApi = null;
                if(this.directoryLoadApi===undefined) this.directoryLoadApi = null;
                if(this.downloadApi===undefined) this.downloadApi = null;
                if(this.nodeApi===undefined) this.nodeApi = null;
                if(this.publishAndSubscribeApi===undefined) this.publishAndSubscribeApi = null;
                if(this.searchApi===undefined) this.searchApi = null;
                if(this.transactionAndAnnounceApi===undefined) this.transactionAndAnnounceApi = null;
                if(this.fileAndNamingRouteApi===undefined) this.fileAndNamingRouteApi = null;
                if(this.uploadApi===undefined) this.uploadApi = null;
                if(this.apiClient===undefined) this.apiClient = null;
                if(this.accountApi===undefined) this.accountApi = null;
                if(this.dataHashApi===undefined) this.dataHashApi = null;
                if(this.directoryLoadApi===undefined) this.directoryLoadApi = null;
                if(this.downloadApi===undefined) this.downloadApi = null;
                if(this.nodeApi===undefined) this.nodeApi = null;
                if(this.publishAndSubscribeApi===undefined) this.publishAndSubscribeApi = null;
                if(this.searchApi===undefined) this.searchApi = null;
                if(this.transactionAndAnnounceApi===undefined) this.transactionAndAnnounceApi = null;
                if(this.fileAndNamingRouteApi===undefined) this.fileAndNamingRouteApi = null;
                if(this.uploadApi===undefined) this.uploadApi = null;
                (() => {
                    this.init(baseUrl, syncGateways, null);
                })();
            } else throw new Error('invalid overload');
        }

        /*private*/ init(baseUrl : string, syncGateways : Array<string>, remoteNodeApi : io.nem.xpx.service.remote.RemoteNodeApi) {
            this.apiClient = new io.nem.ApiClient().setBasePath(baseUrl);
            this.nodeApi = remoteNodeApi == null?new io.nem.xpx.service.remote.RemoteNodeApi(this.apiClient):remoteNodeApi;
            try {
                let nodeInfo : io.nem.xpx.model.NodeInfo = this.nodeApi.getNodeInfoUsingGET();
                io.nem.xpx.factory.ConnectionFactory.setNetwork(nodeInfo.getNetwork());
                this.nodeEndpoint = new org.nem.core.node.NodeEndpoint("http", nodeInfo.getNetworkAddress(), parseFloat(nodeInfo.getNetworkPort()));
                this.setSyncGateways(syncGateways, nodeInfo.getSyncGateways());
            } catch(e) {
                throw new io.nem.xpx.exceptions.PeerConnectionInitFailureException(java.lang.String.format("Failed it initialise due exception on API: %s", baseUrl), e);
            };
        }

        /**
         * Gets the api client.
         * 
         * @return {io.nem.ApiClient} the api client
         */
        public getApiClient() : io.nem.ApiClient {
            return this.apiClient;
        }

        /**
         * 
         * @return {boolean}
         */
        public isLocal() : boolean {
            return false;
        }

        /**
         * 
         * @return {*}
         */
        public getAccountApi() : io.nem.xpx.service.intf.AccountApi {
            if(this.accountApi == null) this.accountApi = new io.nem.xpx.service.remote.RemoteAccountApi(this.apiClient);
            return this.accountApi;
        }

        /**
         * 
         * @return {*}
         */
        public getDataHashApi() : io.nem.xpx.service.intf.DataHashApi {
            if(this.dataHashApi == null) this.dataHashApi = new io.nem.xpx.service.remote.RemoteDataHashApi(this.apiClient);
            return this.dataHashApi;
        }

        /**
         * 
         * @return {*}
         */
        public getDirectoryLoadApi() : io.nem.xpx.service.intf.DirectoryLoadApi {
            if(this.directoryLoadApi == null) this.directoryLoadApi = new io.nem.xpx.service.remote.RemoteDirectoryLoadApi(this.apiClient);
            return this.directoryLoadApi;
        }

        /**
         * 
         * @return {*}
         */
        public getDownloadApi() : io.nem.xpx.service.intf.DownloadApi {
            if(this.downloadApi == null) this.downloadApi = new io.nem.xpx.service.remote.RemoteDownloadApi(this.apiClient);
            return this.downloadApi;
        }

        /**
         * 
         * @return {*}
         */
        public getNodeApi() : io.nem.xpx.service.intf.NodeApi {
            return this.nodeApi;
        }

        /**
         * 
         * @return {*}
         */
        public getPublishAndSubscribeApi() : io.nem.xpx.service.intf.PublishAndSubscribeApi {
            if(this.publishAndSubscribeApi == null) this.publishAndSubscribeApi = new io.nem.xpx.service.remote.RemotePublishAndSubscribeApi(this.apiClient);
            return this.publishAndSubscribeApi;
        }

        /**
         * 
         * @return {io.nem.xpx.service.common.FileAndNamingRouteApi}
         */
        public getFileAndNamingRouteApi() : io.nem.xpx.service.common.FileAndNamingRouteApi {
            if(this.fileAndNamingRouteApi == null) this.fileAndNamingRouteApi = new io.nem.xpx.service.common.FileAndNamingRouteApi(this.apiClient);
            return this.fileAndNamingRouteApi;
        }

        /**
         * 
         * @return {*}
         */
        public getSearchApi() : io.nem.xpx.service.intf.SearchApi {
            if(this.searchApi == null) this.searchApi = new io.nem.xpx.service.remote.RemoteSearchApi(this.apiClient, this.getNemTransactionApi());
            return this.searchApi;
        }

        /**
         * 
         * @return {*}
         */
        public getTransactionAndAnnounceApi() : io.nem.xpx.service.intf.TransactionAndAnnounceApi {
            if(this.transactionAndAnnounceApi == null) this.transactionAndAnnounceApi = new io.nem.xpx.service.remote.RemoteTransactionAndAnnounceApi(this.apiClient);
            return this.transactionAndAnnounceApi;
        }

        /**
         * 
         * @return {*}
         */
        public getUploadApi() : io.nem.xpx.service.intf.UploadApi {
            if(this.uploadApi == null) this.uploadApi = new io.nem.xpx.service.remote.RemoteUploadApi(this.apiClient);
            return this.uploadApi;
        }
    }
    RemotePeerConnection["__class"] = "io.nem.xpx.facade.connection.RemotePeerConnection";

}
namespace io.nem.xpx.facade.download {
    /**
     * The Class DownloadBinaryResult.
     * @extends io.nem.xpx.facade.download.DownloadResult
     * @class
     */
    export class DownloadBinaryResult extends io.nem.xpx.facade.download.DownloadResult {
        constructor(dataMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage, data : number[], messageType : io.nem.xpx.model.NemMessageType) {
            super(dataMessage, data, messageType);
        }

        /**
         * From download result.
         * 
         * @param {io.nem.xpx.facade.download.DownloadResult} downloadResult the download result
         * @return {io.nem.xpx.facade.download.DownloadBinaryResult} the download binary result
         */
        public static fromDownloadResult(downloadResult : io.nem.xpx.facade.download.DownloadResult) : DownloadBinaryResult {
            return new DownloadBinaryResult(downloadResult.getDataMessage(), downloadResult.getData(), downloadResult.getMessageType());
        }
    }
    DownloadBinaryResult["__class"] = "io.nem.xpx.facade.download.DownloadBinaryResult";
    DownloadBinaryResult["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.facade.download {
    /**
     * The Class DownloadFileResult.
     * @extends io.nem.xpx.facade.download.DownloadResult
     * @class
     */
    export class DownloadFileResult extends io.nem.xpx.facade.download.DownloadResult {
        constructor(dataMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage, data : number[], messageType : io.nem.xpx.model.NemMessageType) {
            super(dataMessage, data, messageType);
        }

        /**
         * From download result.
         * 
         * @param {io.nem.xpx.facade.download.DownloadResult} downloadResult the download result
         * @return {io.nem.xpx.facade.download.DownloadFileResult} the download file result
         */
        public static fromDownloadResult(downloadResult : io.nem.xpx.facade.download.DownloadResult) : DownloadFileResult {
            return new DownloadFileResult(downloadResult.getDataMessage(), downloadResult.getData(), downloadResult.getMessageType());
        }

        /**
         * Save to file.
         * 
         * @param {java.io.File} file the file
         * @throws IOException Signals that an I/O exception has occurred.
         */
        public saveToFile(file : java.io.File) {
            let outputStream : java.io.FileOutputStream = new java.io.FileOutputStream(file);
            try {
                outputStream.write(this.getData());
            } finally {
                outputStream.close();
            };
        }

        /**
         * Gets the file name.
         * 
         * @return {string} the file name
         */
        public getFileName() : string {
            return this.getDataMessage() != null?this.getDataMessage().name():null;
        }

        /**
         * Gets the content type.
         * 
         * @return {string} the content type
         */
        public getContentType() : string {
            return this.getDataMessage() != null?this.getDataMessage().type():null;
        }
    }
    DownloadFileResult["__class"] = "io.nem.xpx.facade.download.DownloadFileResult";
    DownloadFileResult["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.facade.download {
    /**
     * The Class DownloadTextDataResult.
     * @extends io.nem.xpx.facade.download.DownloadResult
     * @class
     */
    export class DownloadTextDataResult extends io.nem.xpx.facade.download.DownloadResult {
        constructor(dataMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage, data : number[], messageType : io.nem.xpx.model.NemMessageType) {
            super(dataMessage, data, messageType);
        }

        /**
         * From download result.
         * 
         * @param {io.nem.xpx.facade.download.DownloadResult} downloadResult the download result
         * @return {io.nem.xpx.facade.download.DownloadTextDataResult} the download text data result
         */
        public static fromDownloadResult(downloadResult : io.nem.xpx.facade.download.DownloadResult) : DownloadTextDataResult {
            return new DownloadTextDataResult(downloadResult.getDataMessage(), downloadResult.getData(), downloadResult.getMessageType());
        }

        public getString$java_lang_String(encoding : string) : string {
            return String.fromCharCode.apply(null, this.getData());
        }

        /**
         * Gets the string.
         * 
         * @param {string} encoding the encoding
         * @return {string} the string
         */
        public getString(encoding? : any) : any {
            if(((typeof encoding === 'string') || encoding === null)) {
                return <any>this.getString$java_lang_String(encoding);
            } else if(encoding === undefined) {
                return <any>this.getString$();
            } else throw new Error('invalid overload');
        }

        public getString$() : string {
            return String.fromCharCode.apply(null, this.getData());
        }
    }
    DownloadTextDataResult["__class"] = "io.nem.xpx.facade.download.DownloadTextDataResult";
    DownloadTextDataResult["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.facade.publishandsubscribe {
    /**
     * Instantiates a new publish and subscribe async.
     * 
     * @param {io.nem.xpx.facade.connection.PeerConnection} peerConnection the peer connection
     * @class
     * @extends io.nem.xpx.facade.publishandsubscribe.PublishAndSubscribe
     */
    export class PublishAndSubscribeAsync extends io.nem.xpx.facade.publishandsubscribe.PublishAndSubscribe {
        public constructor(peerConnection : io.nem.xpx.facade.connection.PeerConnection) {
            super(peerConnection);
            if(peerConnection == null) {
                throw new io.nem.xpx.exceptions.PeerConnectionNotFoundException("PeerConnection can\'t be null");
            }
        }
    }
    PublishAndSubscribeAsync["__class"] = "io.nem.xpx.facade.publishandsubscribe.PublishAndSubscribeAsync";

}
namespace io.nem.xpx.facade.upload {
    /**
     * The Class UploadBinaryParameter.
     * @class
     * @extends io.nem.xpx.facade.upload.AbstractUploadParameter
     */
    export class UploadBinaryParameter extends io.nem.xpx.facade.upload.AbstractUploadParameter {
        /**
         * The data.
         */
        /*private*/ data : number[];

        /**
         * Gets the data.
         * 
         * @return {Array} the data
         */
        public getData() : number[] {
            return this.data;
        }

        /**
         * Sets the data.
         * 
         * @param {Array} data the new data
         */
        public setData(data : number[]) {
            this.data = data;
        }

        /**
         * Creates the.
         * 
         * @return {*} the sender private key step
         */
        public static create() : io.nem.xpx.builder.steps.SenderPrivateKeyStep<io.nem.xpx.builder.steps.ReceiverPublicKeyStep<io.nem.xpx.builder.steps.BinaryDataStep<UploadBinaryParameter.FinalBuildSteps>>> {
            return new UploadBinaryParameter.Builder();
        }

        constructor() {
            super();
            if(this.data===undefined) this.data = null;
        }
    }
    UploadBinaryParameter["__class"] = "io.nem.xpx.facade.upload.UploadBinaryParameter";
    UploadBinaryParameter["__interfaces"] = ["java.io.Serializable"];



    export namespace UploadBinaryParameter {

        /**
         * The Interface FinalBuildSteps.
         * @class
         */
        export interface FinalBuildSteps extends io.nem.xpx.builder.steps.ContentTypeStep<UploadBinaryParameter.FinalBuildSteps>, io.nem.xpx.builder.steps.NameStep<UploadBinaryParameter.FinalBuildSteps>, io.nem.xpx.builder.steps.CommonUploadBuildSteps<UploadBinaryParameter.FinalBuildSteps> {
            /**
             * Builds the.
             * 
             * @return {io.nem.xpx.facade.upload.UploadBinaryParameter} the upload binary parameter
             */
            build() : io.nem.xpx.facade.upload.UploadBinaryParameter;
        }

        /**
         * The Class Builder.
         * @extends io.nem.xpx.facade.upload.AbstractUploadParameterBuilder
         * @class
         */
        export class Builder extends io.nem.xpx.facade.upload.AbstractUploadParameterBuilder<io.nem.xpx.builder.steps.BinaryDataStep<any>, UploadBinaryParameter.FinalBuildSteps> implements io.nem.xpx.builder.steps.BinaryDataStep<any>, UploadBinaryParameter.FinalBuildSteps {
            /**
             * The instance.
             */
            instance : io.nem.xpx.facade.upload.UploadBinaryParameter;

            public constructor(instance? : any) {
                if(((instance != null && instance instanceof <any>io.nem.xpx.facade.upload.UploadBinaryParameter) || instance === null)) {
                    let __args = Array.prototype.slice.call(arguments);
                    super(instance);
                    if(this.instance===undefined) this.instance = null;
                    if(this.instance===undefined) this.instance = null;
                    (() => {
                        this.instance = instance;
                    })();
                } else if(instance === undefined) {
                    let __args = Array.prototype.slice.call(arguments);
                    super(new io.nem.xpx.facade.upload.UploadBinaryParameter());
                    if(this.instance===undefined) this.instance = null;
                    if(this.instance===undefined) this.instance = null;
                    (() => {
                        this.instance = <io.nem.xpx.facade.upload.UploadBinaryParameter>this.instance;
                    })();
                } else throw new Error('invalid overload');
            }

            /**
             * 
             * @param {Array} data
             * @return {*}
             */
            public data(data : number[]) : UploadBinaryParameter.FinalBuildSteps {
                this.instance.setData(data);
                return this;
            }

            /**
             * 
             * @param {string} contentType
             * @return {*}
             */
            public contentType(contentType : string) : UploadBinaryParameter.FinalBuildSteps {
                this.instance.setContentType(contentType);
                return this;
            }

            /**
             * 
             * @param {string} name
             * @return {*}
             */
            public name(name : string) : UploadBinaryParameter.FinalBuildSteps {
                this.instance.setName(name);
                return this;
            }

            /**
             * 
             * @return {io.nem.xpx.facade.upload.UploadBinaryParameter}
             */
            public build() : io.nem.xpx.facade.upload.UploadBinaryParameter {
                if(io.nem.xpx.utils.StringUtils.isEmpty(this.instance.getContentType())) this.instance.setContentType(io.nem.xpx.utils.ContentTypeUtils.detectContentType$byte_A(this.instance.data));
                return this.instance;
            }
        }
        Builder["__class"] = "io.nem.xpx.facade.upload.UploadBinaryParameter.Builder";
        Builder["__interfaces"] = ["io.nem.xpx.builder.steps.KeywordsStep","io.nem.xpx.builder.steps.ContentTypeStep","io.nem.xpx.builder.steps.PrivacyStrategyUploadStep","io.nem.xpx.builder.steps.MosaicsStep","io.nem.xpx.builder.steps.ReceiverPublicKeyStep","io.nem.xpx.builder.steps.NameStep","io.nem.xpx.builder.steps.MetadataStep","io.nem.xpx.builder.steps.SenderPrivateKeyStep","io.nem.xpx.builder.steps.CommonUploadBuildSteps","io.nem.xpx.facade.upload.UploadBinaryParameter.FinalBuildSteps","io.nem.xpx.builder.steps.BinaryDataStep"];


    }

}
namespace io.nem.xpx.facade.upload {
    /**
     * The Class UploadFileParameter.
     * @class
     * @extends io.nem.xpx.facade.upload.AbstractUploadParameter
     */
    export class UploadFileParameter extends io.nem.xpx.facade.upload.AbstractUploadParameter {
        /**
         * The file.
         */
        /*private*/ file : java.io.File;

        /**
         * Gets the file.
         * 
         * @return {java.io.File} the file
         */
        public getFile() : java.io.File {
            return this.file;
        }

        /**
         * Sets the file.
         * 
         * @param {java.io.File} file the new file
         */
        public setFile(file : java.io.File) {
            this.file = file;
        }

        /**
         * Creates the.
         * 
         * @return {*} the sender private key step
         */
        public static create() : io.nem.xpx.builder.steps.SenderPrivateKeyStep<io.nem.xpx.builder.steps.ReceiverPublicKeyStep<io.nem.xpx.builder.steps.FileStep<UploadFileParameter.FinalBuildSteps>>> {
            return new UploadFileParameter.Builder();
        }

        constructor() {
            super();
            if(this.file===undefined) this.file = null;
        }
    }
    UploadFileParameter["__class"] = "io.nem.xpx.facade.upload.UploadFileParameter";
    UploadFileParameter["__interfaces"] = ["java.io.Serializable"];



    export namespace UploadFileParameter {

        /**
         * The Interface FinalBuildSteps.
         * @class
         */
        export interface FinalBuildSteps extends io.nem.xpx.builder.steps.FileNameStep<UploadFileParameter.FinalBuildSteps>, io.nem.xpx.builder.steps.ContentTypeStep<UploadFileParameter.FinalBuildSteps>, io.nem.xpx.builder.steps.CommonUploadBuildSteps<UploadFileParameter.FinalBuildSteps> {
            /**
             * Builds the.
             * 
             * @return {io.nem.xpx.facade.upload.UploadFileParameter} the upload file parameter
             * @throws IOException Signals that an I/O exception has occurred.
             */
            build() : io.nem.xpx.facade.upload.UploadFileParameter;
        }

        /**
         * The Class Builder.
         * @extends io.nem.xpx.facade.upload.AbstractUploadParameterBuilder
         * @class
         */
        export class Builder extends io.nem.xpx.facade.upload.AbstractUploadParameterBuilder<io.nem.xpx.builder.steps.FileStep<any>, UploadFileParameter.FinalBuildSteps> implements io.nem.xpx.builder.steps.FileStep<any>, UploadFileParameter.FinalBuildSteps {
            /**
             * The instance.
             */
            instance : io.nem.xpx.facade.upload.UploadFileParameter;

            public constructor(instance? : any) {
                if(((instance != null && instance instanceof <any>io.nem.xpx.facade.upload.UploadFileParameter) || instance === null)) {
                    let __args = Array.prototype.slice.call(arguments);
                    super(instance);
                    if(this.instance===undefined) this.instance = null;
                    if(this.instance===undefined) this.instance = null;
                    (() => {
                        this.instance = instance;
                    })();
                } else if(instance === undefined) {
                    let __args = Array.prototype.slice.call(arguments);
                    super(new io.nem.xpx.facade.upload.UploadFileParameter());
                    if(this.instance===undefined) this.instance = null;
                    if(this.instance===undefined) this.instance = null;
                    (() => {
                        this.instance = <io.nem.xpx.facade.upload.UploadFileParameter>this.instance;
                    })();
                } else throw new Error('invalid overload');
            }

            /**
             * 
             * @param {java.io.File} file
             * @return {*}
             */
            public file(file : java.io.File) : UploadFileParameter.FinalBuildSteps {
                this.instance.setFile(file);
                return this;
            }

            /**
             * 
             * @param {string} fileName
             * @return {*}
             */
            public fileName(fileName : string) : UploadFileParameter.FinalBuildSteps {
                this.instance.setName(fileName);
                return this;
            }

            /**
             * 
             * @param {string} contentType
             * @return {*}
             */
            public contentType(contentType : string) : UploadFileParameter.FinalBuildSteps {
                this.instance.setContentType(contentType);
                return this;
            }

            /**
             * 
             * @return {io.nem.xpx.facade.upload.UploadFileParameter}
             */
            public build() : io.nem.xpx.facade.upload.UploadFileParameter {
                if(io.nem.xpx.utils.StringUtils.isEmpty(this.instance.getName())) this.instance.setName(this.instance.getFile().getName());
                if(io.nem.xpx.utils.StringUtils.isEmpty(this.instance.getContentType())) this.instance.setContentType(io.nem.xpx.utils.ContentTypeUtils.detectContentType$byte_A(org.apache.commons.io.FileUtils.readFileToByteArray(this.instance.getFile())));
                return this.instance;
            }
        }
        Builder["__class"] = "io.nem.xpx.facade.upload.UploadFileParameter.Builder";
        Builder["__interfaces"] = ["io.nem.xpx.facade.upload.UploadFileParameter.FinalBuildSteps","io.nem.xpx.builder.steps.KeywordsStep","io.nem.xpx.builder.steps.ContentTypeStep","io.nem.xpx.builder.steps.PrivacyStrategyUploadStep","io.nem.xpx.builder.steps.MosaicsStep","io.nem.xpx.builder.steps.FileNameStep","io.nem.xpx.builder.steps.ReceiverPublicKeyStep","io.nem.xpx.builder.steps.FileStep","io.nem.xpx.builder.steps.MetadataStep","io.nem.xpx.builder.steps.SenderPrivateKeyStep","io.nem.xpx.builder.steps.CommonUploadBuildSteps"];


    }

}
namespace io.nem.xpx.facade.upload {
    /**
     * The Class UploadFilesAsZipParameter.
     * @class
     * @extends io.nem.xpx.facade.upload.AbstractUploadParameter
     */
    export class UploadFilesAsZipParameter extends io.nem.xpx.facade.upload.AbstractUploadParameter {
        /**
         * The files.
         */
        /*private*/ files : Array<java.io.File> = <any>([]);

        /**
         * Gets the files.
         * 
         * @return {java.io.File[]} the files
         */
        public getFiles() : Array<java.io.File> {
            return this.files;
        }

        public addFiles$java_util_List(files : Array<java.io.File>) {
            /* addAll */((l1, l2) => l1.push.apply(l1, l2))(this.files, files);
        }

        /**
         * Adds the files.
         * 
         * @param {java.io.File[]} files the files
         */
        public addFiles(files? : any) : any {
            if(((files != null && (files instanceof Array)) || files === null)) {
                return <any>this.addFiles$java_util_List(files);
            } else if(((files != null && files instanceof <any>Array && (files.length==0 || files[0] == null ||(files[0] != null && files[0] instanceof <any>java.io.File))) || files === null)) {
                return <any>this.addFiles$java_io_File_A(files);
            } else throw new Error('invalid overload');
        }

        public addFiles$java_io_File_A(...files : java.io.File[]) {
            /* addAll */((l1, l2) => l1.push.apply(l1, l2))(this.files, /* asList */files.slice(0));
        }

        /**
         * Adds the file.
         * 
         * @param {java.io.File} file the file
         */
        public addFile(file : java.io.File) {
            /* add */(this.files.push(file)>0);
        }

        /**
         * Creates the.
         * 
         * @return {*} the sender private key step
         */
        public static create() : io.nem.xpx.builder.steps.SenderPrivateKeyStep<io.nem.xpx.builder.steps.ReceiverPublicKeyStep<io.nem.xpx.builder.steps.ZipFileNameStep<UploadFilesAsZipParameter.FinalBuildSteps>>> {
            return new UploadFilesAsZipParameter.Builder();
        }

        constructor() {
            super();
        }
    }
    UploadFilesAsZipParameter["__class"] = "io.nem.xpx.facade.upload.UploadFilesAsZipParameter";
    UploadFilesAsZipParameter["__interfaces"] = ["java.io.Serializable"];



    export namespace UploadFilesAsZipParameter {

        /**
         * The Interface FinalBuildSteps.
         * @class
         */
        export interface FinalBuildSteps extends io.nem.xpx.builder.steps.FilesStep<UploadFilesAsZipParameter.FinalBuildSteps>, io.nem.xpx.builder.steps.CommonUploadBuildSteps<UploadFilesAsZipParameter.FinalBuildSteps> {
            /**
             * Builds the.
             * 
             * @return {io.nem.xpx.facade.upload.UploadFilesAsZipParameter} the upload files as zip parameter
             */
            build() : io.nem.xpx.facade.upload.UploadFilesAsZipParameter;
        }

        /**
         * The Class Builder.
         * @extends io.nem.xpx.facade.upload.AbstractUploadParameterBuilder
         * @class
         */
        export class Builder extends io.nem.xpx.facade.upload.AbstractUploadParameterBuilder<io.nem.xpx.builder.steps.ZipFileNameStep<any>, UploadFilesAsZipParameter.FinalBuildSteps> implements io.nem.xpx.builder.steps.ZipFileNameStep<any>, UploadFilesAsZipParameter.FinalBuildSteps {
            /**
             * The instance.
             */
            instance : io.nem.xpx.facade.upload.UploadFilesAsZipParameter;

            constructor() {
                super(new io.nem.xpx.facade.upload.UploadFilesAsZipParameter());
                if(this.instance===undefined) this.instance = null;
                this.instance = <io.nem.xpx.facade.upload.UploadFilesAsZipParameter>this.instance;
                this.instance.setContentType(io.nem.xpx.facade.DataTextContentType["_$wrappers"][io.nem.xpx.facade.DataTextContentType.APPLICATION_ZIP].toString());
            }

            /**
             * 
             * @param {string} name
             * @return {*}
             */
            public zipFileName(name : string) : UploadFilesAsZipParameter.FinalBuildSteps {
                this.instance.setName(name);
                return this;
            }

            public addFiles$java_io_File_A(...files : java.io.File[]) : UploadFilesAsZipParameter.FinalBuildSteps {
                (o => o.addFiles.apply(o, files))(this.instance);
                return this;
            }

            /**
             * 
             * @param {Array} files
             * @return {*}
             */
            public addFiles(...files : any[]) : any {
                if(((files != null && files instanceof <any>Array && (files.length==0 || files[0] == null ||(files[0] != null && files[0] instanceof <any>java.io.File))) || files === null)) {
                    return <any>this.addFiles$java_io_File_A(files);
                } else if(((files != null && (files instanceof Array)) || files === null)) {
                    return <any>this.addFiles$java_util_List(files);
                } else throw new Error('invalid overload');
            }

            public addFiles$java_util_List(files : Array<java.io.File>) : UploadFilesAsZipParameter.FinalBuildSteps {
                this.instance.addFiles$java_util_List(files);
                return this;
            }

            /**
             * 
             * @param {java.io.File} file
             * @return {*}
             */
            public addFile(file : java.io.File) : UploadFilesAsZipParameter.FinalBuildSteps {
                this.instance.addFile(file);
                return this;
            }

            /**
             * 
             * @return {io.nem.xpx.facade.upload.UploadFilesAsZipParameter}
             */
            public build() : io.nem.xpx.facade.upload.UploadFilesAsZipParameter {
                return this.instance;
            }
        }
        Builder["__class"] = "io.nem.xpx.facade.upload.UploadFilesAsZipParameter.Builder";
        Builder["__interfaces"] = ["io.nem.xpx.builder.steps.KeywordsStep","io.nem.xpx.builder.steps.PrivacyStrategyUploadStep","io.nem.xpx.builder.steps.MosaicsStep","io.nem.xpx.builder.steps.FilesStep","io.nem.xpx.builder.steps.ReceiverPublicKeyStep","io.nem.xpx.builder.steps.MetadataStep","io.nem.xpx.builder.steps.SenderPrivateKeyStep","io.nem.xpx.facade.upload.UploadFilesAsZipParameter.FinalBuildSteps","io.nem.xpx.builder.steps.CommonUploadBuildSteps","io.nem.xpx.builder.steps.ZipFileNameStep"];


    }

}
namespace io.nem.xpx.facade.upload {
    /**
     * The Class UploadFromUrlParameter.
     * @class
     * @extends io.nem.xpx.facade.upload.AbstractUploadParameter
     */
    export class UploadFromUrlParameter extends io.nem.xpx.facade.upload.AbstractUploadParameter {
        /**
         * The Constant serialVersionUID.
         */
        static serialVersionUID : number = 1;

        /**
         * The data.
         */
        /*private*/ url : java.net.URL;

        public getUrl() : java.net.URL {
            return this.url;
        }

        public setUrl(url : java.net.URL) {
            this.url = url;
        }

        /**
         * Creates the.
         * 
         * @return {*} the sender private key step
         */
        public static create() : io.nem.xpx.builder.steps.SenderPrivateKeyStep<io.nem.xpx.builder.steps.ReceiverPublicKeyStep<io.nem.xpx.builder.steps.UrlStep<UploadFromUrlParameter.FinalBuildSteps>>> {
            return new UploadFromUrlParameter.Builder();
        }

        constructor() {
            super();
            if(this.url===undefined) this.url = null;
        }
    }
    UploadFromUrlParameter["__class"] = "io.nem.xpx.facade.upload.UploadFromUrlParameter";
    UploadFromUrlParameter["__interfaces"] = ["java.io.Serializable"];



    export namespace UploadFromUrlParameter {

        /**
         * The Interface FinalBuildSteps.
         * @class
         */
        export interface FinalBuildSteps extends io.nem.xpx.builder.steps.NameStep<UploadFromUrlParameter.FinalBuildSteps>, io.nem.xpx.builder.steps.ContentTypeStep<UploadFromUrlParameter.FinalBuildSteps>, io.nem.xpx.builder.steps.CommonUploadBuildSteps<UploadFromUrlParameter.FinalBuildSteps> {
            /**
             * Builds the.
             * 
             * @return {io.nem.xpx.facade.upload.UploadFromUrlParameter} the upload from url parameter
             */
            build() : io.nem.xpx.facade.upload.UploadFromUrlParameter;
        }

        /**
         * The Class Builder.
         * @extends io.nem.xpx.facade.upload.AbstractUploadParameterBuilder
         * @class
         */
        export class Builder extends io.nem.xpx.facade.upload.AbstractUploadParameterBuilder<io.nem.xpx.builder.steps.UrlStep<any>, UploadFromUrlParameter.FinalBuildSteps> implements io.nem.xpx.builder.steps.UrlStep<any>, UploadFromUrlParameter.FinalBuildSteps {
            /**
             * The instance.
             */
            instance : io.nem.xpx.facade.upload.UploadFromUrlParameter;

            public constructor(instance? : any) {
                if(((instance != null && instance instanceof <any>io.nem.xpx.facade.upload.UploadFromUrlParameter) || instance === null)) {
                    let __args = Array.prototype.slice.call(arguments);
                    super(instance);
                    if(this.instance===undefined) this.instance = null;
                    if(this.instance===undefined) this.instance = null;
                    (() => {
                        this.instance = instance;
                    })();
                } else if(instance === undefined) {
                    let __args = Array.prototype.slice.call(arguments);
                    super(new io.nem.xpx.facade.upload.UploadFromUrlParameter());
                    if(this.instance===undefined) this.instance = null;
                    if(this.instance===undefined) this.instance = null;
                    (() => {
                        this.instance = <io.nem.xpx.facade.upload.UploadFromUrlParameter>this.instance;
                    })();
                } else throw new Error('invalid overload');
            }

            /**
             * 
             * @param {java.net.URL} url
             * @return {*}
             */
            public url(url : java.net.URL) : UploadFromUrlParameter.FinalBuildSteps {
                this.instance.setUrl(url);
                return this;
            }

            /**
             * 
             * @param {string} contentType
             * @return {*}
             */
            public contentType(contentType : string) : UploadFromUrlParameter.FinalBuildSteps {
                this.instance.setContentType(contentType);
                return this;
            }

            /**
             * 
             * @param {string} name
             * @return {*}
             */
            public name(name : string) : UploadFromUrlParameter.FinalBuildSteps {
                this.instance.setName(name);
                return this;
            }

            /**
             * 
             * @return {io.nem.xpx.facade.upload.UploadFromUrlParameter}
             */
            public build() : io.nem.xpx.facade.upload.UploadFromUrlParameter {
                return this.instance;
            }
        }
        Builder["__class"] = "io.nem.xpx.facade.upload.UploadFromUrlParameter.Builder";
        Builder["__interfaces"] = ["io.nem.xpx.builder.steps.KeywordsStep","io.nem.xpx.builder.steps.ContentTypeStep","io.nem.xpx.builder.steps.PrivacyStrategyUploadStep","io.nem.xpx.builder.steps.MosaicsStep","io.nem.xpx.builder.steps.ReceiverPublicKeyStep","io.nem.xpx.builder.steps.NameStep","io.nem.xpx.builder.steps.MetadataStep","io.nem.xpx.builder.steps.SenderPrivateKeyStep","io.nem.xpx.facade.upload.UploadFromUrlParameter.FinalBuildSteps","io.nem.xpx.builder.steps.CommonUploadBuildSteps","io.nem.xpx.builder.steps.UrlStep"];


    }

}
namespace io.nem.xpx.facade.upload {
    /**
     * The Class UploadMultipleFilesParameter.
     * @class
     * @extends io.nem.xpx.facade.upload.AbstractUploadParameter
     */
    export class UploadMultipleFilesParameter extends io.nem.xpx.facade.upload.AbstractUploadParameter {
        /**
         * The files.
         */
        /*private*/ files : Array<java.io.File> = <any>([]);

        /**
         * Gets the files.
         * 
         * @return {java.io.File[]} the files
         */
        public getFiles() : Array<java.io.File> {
            return this.files;
        }

        public addFiles$java_util_List(files : Array<java.io.File>) {
            /* addAll */((l1, l2) => l1.push.apply(l1, l2))(this.files, files);
        }

        /**
         * Adds the files.
         * 
         * @param {java.io.File[]} files the files
         */
        public addFiles(files? : any) : any {
            if(((files != null && (files instanceof Array)) || files === null)) {
                return <any>this.addFiles$java_util_List(files);
            } else if(((files != null && files instanceof <any>Array && (files.length==0 || files[0] == null ||(files[0] != null && files[0] instanceof <any>java.io.File))) || files === null)) {
                return <any>this.addFiles$java_io_File_A(files);
            } else throw new Error('invalid overload');
        }

        public addFiles$java_io_File_A(...files : java.io.File[]) {
            /* addAll */((l1, l2) => l1.push.apply(l1, l2))(this.files, /* asList */files.slice(0));
        }

        /**
         * Adds the file.
         * 
         * @param {java.io.File} file the file
         */
        public addFile(file : java.io.File) {
            /* add */(this.files.push(file)>0);
        }

        /**
         * Creates the.
         * 
         * @return {*} the sender private key step
         */
        public static create() : io.nem.xpx.builder.steps.SenderPrivateKeyStep<io.nem.xpx.builder.steps.ReceiverPublicKeyStep<UploadMultipleFilesParameter.FinalBuildSteps>> {
            return new UploadMultipleFilesParameter.Builder();
        }

        constructor() {
            super();
        }
    }
    UploadMultipleFilesParameter["__class"] = "io.nem.xpx.facade.upload.UploadMultipleFilesParameter";
    UploadMultipleFilesParameter["__interfaces"] = ["java.io.Serializable"];



    export namespace UploadMultipleFilesParameter {

        /**
         * The Interface FinalBuildSteps.
         * @class
         */
        export interface FinalBuildSteps extends io.nem.xpx.builder.steps.FilesStep<UploadMultipleFilesParameter.FinalBuildSteps>, io.nem.xpx.builder.steps.CommonUploadBuildSteps<UploadMultipleFilesParameter.FinalBuildSteps> {
            /**
             * Builds the.
             * 
             * @return {io.nem.xpx.facade.upload.UploadMultipleFilesParameter} the upload multiple files parameter
             */
            build() : io.nem.xpx.facade.upload.UploadMultipleFilesParameter;
        }

        /**
         * The Class Builder.
         * @extends io.nem.xpx.facade.upload.AbstractUploadParameterBuilder
         * @class
         */
        export class Builder extends io.nem.xpx.facade.upload.AbstractUploadParameterBuilder<UploadMultipleFilesParameter.FinalBuildSteps, UploadMultipleFilesParameter.FinalBuildSteps> implements UploadMultipleFilesParameter.FinalBuildSteps {
            /**
             * The instance.
             */
            instance : io.nem.xpx.facade.upload.UploadMultipleFilesParameter;

            constructor() {
                super(new io.nem.xpx.facade.upload.UploadMultipleFilesParameter());
                if(this.instance===undefined) this.instance = null;
                this.instance = <io.nem.xpx.facade.upload.UploadMultipleFilesParameter>this.instance;
            }

            public addFiles$java_io_File_A(...files : java.io.File[]) : UploadMultipleFilesParameter.FinalBuildSteps {
                (o => o.addFiles.apply(o, files))(this.instance);
                return this;
            }

            /**
             * 
             * @param {Array} files
             * @return {*}
             */
            public addFiles(...files : any[]) : any {
                if(((files != null && files instanceof <any>Array && (files.length==0 || files[0] == null ||(files[0] != null && files[0] instanceof <any>java.io.File))) || files === null)) {
                    return <any>this.addFiles$java_io_File_A(files);
                } else if(((files != null && (files instanceof Array)) || files === null)) {
                    return <any>this.addFiles$java_util_List(files);
                } else throw new Error('invalid overload');
            }

            public addFiles$java_util_List(files : Array<java.io.File>) : UploadMultipleFilesParameter.FinalBuildSteps {
                this.instance.addFiles$java_util_List(files);
                return this;
            }

            /**
             * 
             * @param {java.io.File} file
             * @return {*}
             */
            public addFile(file : java.io.File) : UploadMultipleFilesParameter.FinalBuildSteps {
                this.instance.addFile(file);
                return this;
            }

            /**
             * 
             * @return {io.nem.xpx.facade.upload.UploadMultipleFilesParameter}
             */
            public build() : io.nem.xpx.facade.upload.UploadMultipleFilesParameter {
                return this.instance;
            }
        }
        Builder["__class"] = "io.nem.xpx.facade.upload.UploadMultipleFilesParameter.Builder";
        Builder["__interfaces"] = ["io.nem.xpx.builder.steps.KeywordsStep","io.nem.xpx.builder.steps.PrivacyStrategyUploadStep","io.nem.xpx.builder.steps.MosaicsStep","io.nem.xpx.builder.steps.FilesStep","io.nem.xpx.builder.steps.ReceiverPublicKeyStep","io.nem.xpx.builder.steps.MetadataStep","io.nem.xpx.builder.steps.SenderPrivateKeyStep","io.nem.xpx.builder.steps.CommonUploadBuildSteps","io.nem.xpx.facade.upload.UploadMultipleFilesParameter.FinalBuildSteps"];


    }

}
namespace io.nem.xpx.facade.upload {
    /**
     * The Class UploadPathParameter.
     * @class
     * @extends io.nem.xpx.facade.upload.AbstractUploadParameter
     */
    export class UploadPathParameter extends io.nem.xpx.facade.upload.AbstractUploadParameter {
        /**
         * The path.
         */
        /*private*/ path : string;

        /**
         * Gets the path.
         * 
         * @return {string} the path
         */
        public getPath() : string {
            return this.path;
        }

        /**
         * Sets the path.
         * 
         * @param {string} path the new path
         */
        public setPath(path : string) {
            this.path = path;
        }

        /**
         * Creates the.
         * 
         * @return {*} the sender private key step
         */
        public static create() : io.nem.xpx.builder.steps.SenderPrivateKeyStep<io.nem.xpx.builder.steps.ReceiverPublicKeyStep<io.nem.xpx.builder.steps.PathStep<UploadPathParameter.FinalBuildSteps>>> {
            return new UploadPathParameter.Builder();
        }

        constructor() {
            super();
            if(this.path===undefined) this.path = null;
        }
    }
    UploadPathParameter["__class"] = "io.nem.xpx.facade.upload.UploadPathParameter";
    UploadPathParameter["__interfaces"] = ["java.io.Serializable"];



    export namespace UploadPathParameter {

        /**
         * The Interface FinalBuildSteps.
         * @class
         */
        export interface FinalBuildSteps extends io.nem.xpx.builder.steps.CommonUploadBuildSteps<UploadPathParameter.FinalBuildSteps> {
            /**
             * Builds the.
             * 
             * @return {io.nem.xpx.facade.upload.UploadPathParameter} the upload path parameter
             */
            build() : io.nem.xpx.facade.upload.UploadPathParameter;
        }

        /**
         * The Class Builder.
         * @extends io.nem.xpx.facade.upload.AbstractUploadParameterBuilder
         * @class
         */
        export class Builder extends io.nem.xpx.facade.upload.AbstractUploadParameterBuilder<io.nem.xpx.builder.steps.PathStep<any>, UploadPathParameter.FinalBuildSteps> implements io.nem.xpx.builder.steps.PathStep<any>, UploadPathParameter.FinalBuildSteps {
            /**
             * The instance.
             */
            instance : io.nem.xpx.facade.upload.UploadPathParameter;

            constructor() {
                super(new io.nem.xpx.facade.upload.UploadPathParameter());
                if(this.instance===undefined) this.instance = null;
                this.instance = <io.nem.xpx.facade.upload.UploadPathParameter>this.instance;
            }

            /**
             * 
             * @param {string} path
             * @return {*}
             */
            public path(path : string) : UploadPathParameter.FinalBuildSteps {
                this.instance.setPath(path);
                return this;
            }

            /**
             * 
             * @return {io.nem.xpx.facade.upload.UploadPathParameter}
             */
            public build() : io.nem.xpx.facade.upload.UploadPathParameter {
                return this.instance;
            }
        }
        Builder["__class"] = "io.nem.xpx.facade.upload.UploadPathParameter.Builder";
        Builder["__interfaces"] = ["io.nem.xpx.builder.steps.KeywordsStep","io.nem.xpx.builder.steps.PrivacyStrategyUploadStep","io.nem.xpx.builder.steps.MosaicsStep","io.nem.xpx.builder.steps.ReceiverPublicKeyStep","io.nem.xpx.builder.steps.MetadataStep","io.nem.xpx.builder.steps.SenderPrivateKeyStep","io.nem.xpx.builder.steps.CommonUploadBuildSteps","io.nem.xpx.builder.steps.PathStep","io.nem.xpx.facade.upload.UploadPathParameter.FinalBuildSteps"];


    }

}
namespace io.nem.xpx.facade.upload {
    /**
     * The Class UploadTextDataParameter.
     * @class
     * @extends io.nem.xpx.facade.upload.AbstractUploadParameter
     */
    export class UploadTextDataParameter extends io.nem.xpx.facade.upload.AbstractUploadParameter {
        /**
         * The Constant serialVersionUID.
         */
        static serialVersionUID : number = 1;

        /**
         * The data.
         */
        /*private*/ data : string;

        /**
         * The encoding.
         */
        /*private*/ encoding : string;

        /**
         * Gets the data.
         * 
         * @return {string} the data
         */
        public getData() : string {
            return this.data;
        }

        /**
         * Sets the data.
         * 
         * @param {string} data the new data
         */
        public setData(data : string) {
            this.data = data;
        }

        /**
         * Gets the encoding.
         * 
         * @return {string} the encoding
         */
        public getEncoding() : string {
            return this.encoding;
        }

        /**
         * Sets the encoding.
         * 
         * @param {string} encoding the new encoding
         */
        public setEncoding(encoding : string) {
            this.encoding = encoding;
        }

        /**
         * Creates the.
         * 
         * @return {*} the sender private key step
         */
        public static create() : io.nem.xpx.builder.steps.SenderPrivateKeyStep<io.nem.xpx.builder.steps.ReceiverPublicKeyStep<io.nem.xpx.builder.steps.TextDataStep<UploadTextDataParameter.FinalBuildSteps>>> {
            return new UploadTextDataParameter.Builder();
        }

        constructor() {
            super();
            if(this.data===undefined) this.data = null;
            if(this.encoding===undefined) this.encoding = null;
        }
    }
    UploadTextDataParameter["__class"] = "io.nem.xpx.facade.upload.UploadTextDataParameter";
    UploadTextDataParameter["__interfaces"] = ["java.io.Serializable"];



    export namespace UploadTextDataParameter {

        /**
         * The Interface FinalBuildSteps.
         * @class
         */
        export interface FinalBuildSteps extends io.nem.xpx.builder.steps.NameStep<UploadTextDataParameter.FinalBuildSteps>, io.nem.xpx.builder.steps.EncodingStep<UploadTextDataParameter.FinalBuildSteps>, io.nem.xpx.builder.steps.ContentTypeStep<UploadTextDataParameter.FinalBuildSteps>, io.nem.xpx.builder.steps.CommonUploadBuildSteps<UploadTextDataParameter.FinalBuildSteps> {
            /**
             * Builds the.
             * 
             * @return {io.nem.xpx.facade.upload.UploadTextDataParameter} the upload text data parameter
             */
            build() : io.nem.xpx.facade.upload.UploadTextDataParameter;
        }

        /**
         * The Class Builder.
         * @extends io.nem.xpx.facade.upload.AbstractUploadParameterBuilder
         * @class
         */
        export class Builder extends io.nem.xpx.facade.upload.AbstractUploadParameterBuilder<io.nem.xpx.builder.steps.TextDataStep<any>, UploadTextDataParameter.FinalBuildSteps> implements io.nem.xpx.builder.steps.TextDataStep<any>, UploadTextDataParameter.FinalBuildSteps {
            /**
             * The instance.
             */
            instance : io.nem.xpx.facade.upload.UploadTextDataParameter;

            public constructor(instance? : any) {
                if(((instance != null && instance instanceof <any>io.nem.xpx.facade.upload.UploadTextDataParameter) || instance === null)) {
                    let __args = Array.prototype.slice.call(arguments);
                    super(instance);
                    if(this.instance===undefined) this.instance = null;
                    if(this.instance===undefined) this.instance = null;
                    (() => {
                        this.instance = instance;
                    })();
                } else if(instance === undefined) {
                    let __args = Array.prototype.slice.call(arguments);
                    super(new io.nem.xpx.facade.upload.UploadTextDataParameter());
                    if(this.instance===undefined) this.instance = null;
                    if(this.instance===undefined) this.instance = null;
                    (() => {
                        this.instance = <io.nem.xpx.facade.upload.UploadTextDataParameter>this.instance;
                    })();
                } else throw new Error('invalid overload');
            }

            /**
             * 
             * @param {string} data
             * @return {*}
             */
            public data(data : string) : UploadTextDataParameter.FinalBuildSteps {
                this.instance.setData(data);
                return this;
            }

            /**
             * 
             * @param {string} contentType
             * @return {*}
             */
            public contentType(contentType : string) : UploadTextDataParameter.FinalBuildSteps {
                this.instance.setContentType(contentType);
                return this;
            }

            /**
             * 
             * @param {string} encoding
             * @return {*}
             */
            public encoding(encoding : string) : UploadTextDataParameter.FinalBuildSteps {
                this.instance.setEncoding(encoding);
                return this;
            }

            /**
             * 
             * @param {string} name
             * @return {*}
             */
            public name(name : string) : UploadTextDataParameter.FinalBuildSteps {
                this.instance.setName(name);
                return this;
            }

            /**
             * 
             * @return {io.nem.xpx.facade.upload.UploadTextDataParameter}
             */
            public build() : io.nem.xpx.facade.upload.UploadTextDataParameter {
                if(this.instance.getEncoding() == null) {
                    this.instance.setEncoding("UTF-8");
                }
                if(this.instance.getContentType() == null) {
                    this.instance.setContentType("text/plain");
                }
                return this.instance;
            }
        }
        Builder["__class"] = "io.nem.xpx.facade.upload.UploadTextDataParameter.Builder";
        Builder["__interfaces"] = ["io.nem.xpx.builder.steps.TextDataStep","io.nem.xpx.builder.steps.KeywordsStep","io.nem.xpx.builder.steps.ContentTypeStep","io.nem.xpx.builder.steps.PrivacyStrategyUploadStep","io.nem.xpx.builder.steps.MosaicsStep","io.nem.xpx.builder.steps.ReceiverPublicKeyStep","io.nem.xpx.builder.steps.NameStep","io.nem.xpx.builder.steps.EncodingStep","io.nem.xpx.builder.steps.MetadataStep","io.nem.xpx.builder.steps.SenderPrivateKeyStep","io.nem.xpx.builder.steps.CommonUploadBuildSteps","io.nem.xpx.facade.upload.UploadTextDataParameter.FinalBuildSteps"];


    }

}
namespace io.nem.xpx.exceptions {
    /**
     * Instantiates a new insufficient amount exception.
     * 
     * @param {Error} exception the exception
     * @class
     * @extends io.nem.xpx.facade.upload.UploadException
     */
    export class InsufficientAmountException extends io.nem.xpx.facade.upload.UploadException {
        /**
         * The Constant serialVersionUID.
         */
        static __io_nem_xpx_exceptions_InsufficientAmountException_serialVersionUID : number = 1;

        public constructor(exception? : any) {
            if(((exception != null && (exception["__classes"] && exception["__classes"].indexOf("java.lang.Exception") >= 0) || exception != null && exception instanceof <any>Error) || exception === null)) {
                let __args = Array.prototype.slice.call(arguments);
                super(exception);
                (<any>Object).setPrototypeOf(this, InsufficientAmountException.prototype);
            } else if(((typeof exception === 'string') || exception === null)) {
                let __args = Array.prototype.slice.call(arguments);
                let message : any = __args[0];
                super(message);
                (<any>Object).setPrototypeOf(this, InsufficientAmountException.prototype);
            } else throw new Error('invalid overload');
        }
    }
    InsufficientAmountException["__class"] = "io.nem.xpx.exceptions.InsufficientAmountException";
    InsufficientAmountException["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.model {
    /**
     * ResourceHashMessageJsonEntity.
     * @class
     * @extends io.nem.xpx.model.NemTransactionInfo
     */
    export class ResourceHashMessageJsonEntity extends io.nem.xpx.model.NemTransactionInfo {
        /**
         * The digest.
         */
        /*private*/ __digest : string = null;

        /**
         * The hash.
         */
        /*private*/ __hash : string = null;

        /**
         * The keywords.
         */
        /*private*/ __keywords : string = null;

        /**
         * The meta data.
         */
        /*private*/ __metaData : string = null;

        /**
         * The name.
         */
        /*private*/ __name : string = null;

        /**
         * The size.
         */
        /*private*/ __size : number = null;

        /**
         * The timestamp.
         */
        /*private*/ __timestamp : number = null;

        /**
         * The type.
         */
        /*private*/ __type : string = null;

        /**
         * Digest.
         * 
         * @param {string} digest the digest
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity} the resource hash message json entity
         */
        public digest(digest : string) : ResourceHashMessageJsonEntity {
            this.__digest = digest;
            return this;
        }

        /**
         * Get digest.
         * 
         * @return {string} digest
         */
        public getDigest() : string {
            return this.__digest;
        }

        /**
         * Sets the digest.
         * 
         * @param {string} digest the new digest
         */
        public setDigest(digest : string) {
            this.__digest = digest;
        }

        /**
         * Hash.
         * 
         * @param {string} hash the hash
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity} the resource hash message json entity
         */
        public hash(hash : string) : ResourceHashMessageJsonEntity {
            this.__hash = hash;
            return this;
        }

        /**
         * Get hash.
         * 
         * @return {string} hash
         */
        public getHash() : string {
            return this.__hash;
        }

        /**
         * Sets the hash.
         * 
         * @param {string} hash the new hash
         */
        public setHash(hash : string) {
            this.__hash = hash;
        }

        /**
         * Keywords.
         * 
         * @param {string} keywords the keywords
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity} the resource hash message json entity
         */
        public keywords(keywords : string) : ResourceHashMessageJsonEntity {
            this.__keywords = keywords;
            return this;
        }

        /**
         * Get keywords.
         * 
         * @return {string} keywords
         */
        public getKeywords() : string {
            return this.__keywords;
        }

        /**
         * Sets the keywords.
         * 
         * @param {string} keywords the new keywords
         */
        public setKeywords(keywords : string) {
            this.__keywords = keywords;
        }

        /**
         * Meta data.
         * 
         * @param {string} metaData the meta data
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity} the resource hash message json entity
         */
        public metaData(metaData : string) : ResourceHashMessageJsonEntity {
            this.__metaData = metaData;
            return this;
        }

        /**
         * Get metaData.
         * 
         * @return {string} metaData
         */
        public getMetaData() : string {
            return this.__metaData;
        }

        /**
         * Sets the meta data.
         * 
         * @param {string} metaData the new meta data
         */
        public setMetaData(metaData : string) {
            this.__metaData = metaData;
        }

        /**
         * Name.
         * 
         * @param {string} name the name
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity} the resource hash message json entity
         */
        public name(name : string) : ResourceHashMessageJsonEntity {
            this.__name = name;
            return this;
        }

        /**
         * Get name.
         * 
         * @return {string} name
         */
        public getName() : string {
            return this.__name;
        }

        /**
         * Sets the name.
         * 
         * @param {string} name the new name
         */
        public setName(name : string) {
            this.__name = name;
        }

        /**
         * Size.
         * 
         * @param {number} size the size
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity} the resource hash message json entity
         */
        public size(size : number) : ResourceHashMessageJsonEntity {
            this.__size = size;
            return this;
        }

        /**
         * Get size.
         * 
         * @return {number} size
         */
        public getSize() : number {
            return this.__size;
        }

        /**
         * Sets the size.
         * 
         * @param {number} size the new size
         */
        public setSize(size : number) {
            this.__size = size;
        }

        /**
         * Timestamp.
         * 
         * @param {number} timestamp the timestamp
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity} the resource hash message json entity
         */
        public timestamp(timestamp : number) : ResourceHashMessageJsonEntity {
            this.__timestamp = timestamp;
            return this;
        }

        /**
         * Get timestamp.
         * 
         * @return {number} timestamp
         */
        public getTimestamp() : number {
            return this.__timestamp;
        }

        /**
         * Sets the timestamp.
         * 
         * @param {number} timestamp the new timestamp
         */
        public setTimestamp(timestamp : number) {
            this.__timestamp = timestamp;
        }

        /**
         * Type.
         * 
         * @param {string} type the type
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity} the resource hash message json entity
         */
        public type(type : string) : ResourceHashMessageJsonEntity {
            this.__type = type;
            return this;
        }

        /**
         * Get type.
         * 
         * @return {string} type
         */
        public getType() : string {
            return this.__type;
        }

        /**
         * Sets the type.
         * 
         * @param {string} type the new type
         */
        public setType(type : string) {
            this.__type = type;
        }

        /**
         * 
         * @param {*} o
         * @return {boolean}
         */
        public equals(o : any) : boolean {
            if(this === o) {
                return true;
            }
            if(o == null || (<any>this.constructor) !== (<any>o.constructor)) {
                return false;
            }
            let resourceHashMessageJsonEntity : ResourceHashMessageJsonEntity = <ResourceHashMessageJsonEntity>o;
            return java.util.Objects.equals(this.__digest, resourceHashMessageJsonEntity.__digest) && java.util.Objects.equals(this.__hash, resourceHashMessageJsonEntity.__hash) && java.util.Objects.equals(this.__keywords, resourceHashMessageJsonEntity.__keywords) && java.util.Objects.equals(this.__metaData, resourceHashMessageJsonEntity.__metaData) && java.util.Objects.equals(this.__name, resourceHashMessageJsonEntity.__name) && java.util.Objects.equals(this.__size, resourceHashMessageJsonEntity.__size) && java.util.Objects.equals(this.__timestamp, resourceHashMessageJsonEntity.__timestamp) && java.util.Objects.equals(this.__type, resourceHashMessageJsonEntity.__type);
        }

        /**
         * 
         * @return {number}
         */
        public hashCode() : number {
            return /* hash */0;
        }

        /**
         * 
         * @return {string}
         */
        public toString() : string {
            let sb : { str: string } = { str: "", toString: function() { return this.str; } };
            /* append */(sb => { sb.str = sb.str.concat(<any>"class ResourceHashMessageJsonEntity {\n"); return sb; })(sb);
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__digest)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    digest: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__hash)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    hash: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__keywords)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    keywords: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__metaData)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    metaData: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__name)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    name: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__size)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    size: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__timestamp)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    timestamp: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"\n"); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>this.toIndentedString(this.__type)); return sb; })(/* append */(sb => { sb.str = sb.str.concat(<any>"    type: "); return sb; })(sb)));
            /* append */(sb => { sb.str = sb.str.concat(<any>"}"); return sb; })(sb);
            return /* toString */sb.str;
        }

        /**
         * Convert the given object to string with each line indented by 4 spaces
         * (except the first line).
         * 
         * @param {*} o the o
         * @return {string} the string
         * @private
         */
        /*private*/ toIndentedString(o : any) : string {
            if(o == null) {
                return "null";
            }
            return /* replace */o.toString().split("\n").join("\n    ");
        }

        constructor() {
            super();
        }
    }
    ResourceHashMessageJsonEntity["__class"] = "io.nem.xpx.model.ResourceHashMessageJsonEntity";
    ResourceHashMessageJsonEntity["__interfaces"] = ["java.io.Serializable"];


}
namespace io.nem.xpx.service.local {
    /**
     * Instantiates a new local search api.
     * 
     * @param {io.nem.xpx.service.NemTransactionApi} nemTransactionApi the nem transaction api
     * @class
     * @extends io.nem.xpx.service.common.PrivateSearchApi
     */
    export class LocalSearchApi extends io.nem.xpx.service.common.PrivateSearchApi implements io.nem.xpx.service.intf.SearchApi {
        /**
         * The nem transaction api.
         */
        /*private*/ __io_nem_xpx_service_local_LocalSearchApi_nemTransactionApi : io.nem.xpx.service.NemTransactionApi;

        public constructor(nemTransactionApi : io.nem.xpx.service.NemTransactionApi) {
            super(nemTransactionApi);
            if(this.__io_nem_xpx_service_local_LocalSearchApi_nemTransactionApi===undefined) this.__io_nem_xpx_service_local_LocalSearchApi_nemTransactionApi = null;
            this.__io_nem_xpx_service_local_LocalSearchApi_nemTransactionApi = nemTransactionApi;
        }

        public searchTransactionWithKeywordUsingGET$java_lang_String$java_lang_String(xPubkey : string, keywords : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            let pbKey : org.nem.core.crypto.PublicKey = org.nem.core.crypto.PublicKey.fromHexString(xPubkey);
            let address : org.nem.core.model.Address = org.nem.core.model.Address.fromPublicKey(pbKey);
            let publicKeyAddress : string = address.toString();
            let listOfTransactionMetadataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = this.__io_nem_xpx_service_local_LocalSearchApi_nemTransactionApi.getAllTransactions$java_lang_String(publicKeyAddress);
            let encryptedMessage : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> = <any>([]);
            let currentHash : string = "";
            for(let index185=0; index185 < listOfTransactionMetadataPair.length; index185++) {
                let tmp = listOfTransactionMetadataPair[index185];
                {
                    currentHash = tmp.getMetaData().getHash().toString();
                    if(tmp.getEntity() != null && tmp.getEntity() instanceof <any>org.nem.core.model.TransferTransaction) {
                        let transferTransaction : org.nem.core.model.TransferTransaction = <org.nem.core.model.TransferTransaction>tmp.getEntity();
                        if(this.checkIfTxnHaveXPXMosaic(transferTransaction)) {
                            try {
                                if(transferTransaction.getMessage().getType() === 1) {
                                    let found : boolean = false;
                                    let resourceMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage = io.nem.xpx.service.model.buffers.ResourceHashMessage.getRootAsResourceHashMessage$java_nio_ByteBuffer(java.nio.ByteBuffer.wrap(org.apache.commons.codec.binary.Base64.decodeBase64(transferTransaction.getMessage().getDecodedPayload())));
                                    let commaSeparatedkeywordsSplit : string[] = keywords.split(",");
                                    for(let index186=0; index186 < commaSeparatedkeywordsSplit.length; index186++) {
                                        let keyword = commaSeparatedkeywordsSplit[index186];
                                        {
                                            if(/* contains */(resourceMessage.keywords().indexOf(keyword) != -1)) {
                                                found = true;
                                                break;
                                            }
                                        }
                                    }
                                    if(found) {
                                        /* add */(encryptedMessage.push(this.toEntity(currentHash, resourceMessage))>0);
                                    }
                                }
                            } catch(e) {
                                continue;
                            };
                        }
                    }
                }
            }
            return encryptedMessage;
        }

        /**
         * 
         * @param {string} xPubkey
         * @param {string} key
         * @param {string} value
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]}
         */
        public searchTransactionWithMetadataUsingGET(xPubkey : string, key : string, value : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            let pbKey : org.nem.core.crypto.PublicKey = org.nem.core.crypto.PublicKey.fromHexString(xPubkey);
            let address : org.nem.core.model.Address = org.nem.core.model.Address.fromPublicKey(pbKey);
            let publicKeyAddress : string = address.toString();
            let listOfTransactionMetadataPair : Array<org.nem.core.model.ncc.TransactionMetaDataPair> = this.__io_nem_xpx_service_local_LocalSearchApi_nemTransactionApi.getAllTransactions$java_lang_String(publicKeyAddress);
            let encryptedMessage : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> = <any>([]);
            for(let index187=0; index187 < listOfTransactionMetadataPair.length; index187++) {
                let tmp = listOfTransactionMetadataPair[index187];
                {
                    let currentHash : string = "";
                    if(tmp.getEntity() != null && tmp.getEntity() instanceof <any>org.nem.core.model.TransferTransaction) {
                        let transferTransaction : org.nem.core.model.TransferTransaction = <org.nem.core.model.TransferTransaction>tmp.getEntity();
                        currentHash = tmp.getMetaData().getHash().toString();
                        if(this.checkIfTxnHaveXPXMosaic(transferTransaction)) {
                            try {
                                if(transferTransaction.getMessage().getType() === 1) {
                                    let found : boolean = false;
                                    let resourceMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage = io.nem.xpx.service.model.buffers.ResourceHashMessage.getRootAsResourceHashMessage$java_nio_ByteBuffer(java.nio.ByteBuffer.wrap(org.apache.commons.codec.binary.Base64.decodeBase64(transferTransaction.getMessage().getDecodedPayload())));
                                    if(resourceMessage.metaData() != null) {
                                        let jsonToMap : any = <any>(io.nem.xpx.utils.JsonUtils.fromJson<any>(resourceMessage.metaData(), "java.util.Map"));
                                        if(/* containsKey */jsonToMap.hasOwnProperty(key) && /* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(/* get */((m,k) => m[k]===undefined?null:m[k])(jsonToMap, key),value))) {
                                            found = true;
                                        }
                                    }
                                    if(found) {
                                        /* add */(encryptedMessage.push(this.toEntity(currentHash, resourceMessage))>0);
                                    }
                                }
                            } catch(e) {
                                org.pmw.tinylog.Logger.info("Error on decoding NEM Transaction Message." + e.message);
                                continue;
                            };
                        }
                    }
                }
            }
            return encryptedMessage;
        }

        /**
         * 
         * @param {string} xPvKey
         * @param {string} xPubkey
         * @param {string} key
         * @param {string} value
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]}
         */
        public searchTransactionWithMetadataKeyValuePair(xPvKey : string, xPubkey : string, key : string, value : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            return super.searchTransactionWithMetadataKeyValuePair(xPvKey, xPubkey, key, value);
        }

        public searchTransactionWithKeywordUsingGET$java_lang_String$java_lang_String$java_lang_String(xPvKey : string, xPubkey : string, keywords : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            return super.searchTransactionWithKeyword(xPvKey, xPubkey, keywords);
        }

        /**
         * 
         * @param {string} xPvKey
         * @param {string} xPubkey
         * @param {string} keywords
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]}
         */
        public searchTransactionWithKeywordUsingGET(xPvKey? : any, xPubkey? : any, keywords? : any) : any {
            if(((typeof xPvKey === 'string') || xPvKey === null) && ((typeof xPubkey === 'string') || xPubkey === null) && ((typeof keywords === 'string') || keywords === null)) {
                return <any>this.searchTransactionWithKeywordUsingGET$java_lang_String$java_lang_String$java_lang_String(xPvKey, xPubkey, keywords);
            } else if(((typeof xPvKey === 'string') || xPvKey === null) && ((typeof xPubkey === 'string') || xPubkey === null) && keywords === undefined) {
                return <any>this.searchTransactionWithKeywordUsingGET$java_lang_String$java_lang_String(xPvKey, xPubkey);
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {string} xPvKey
         * @param {string} xPubkey
         * @param {string} name
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]}
         */
        public searchTransactionWithNameUsingGET(xPvKey : string, xPubkey : string, name : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            return super.searchTransactionWithKeyword(xPvKey, xPubkey, name);
        }
    }
    LocalSearchApi["__class"] = "io.nem.xpx.service.local.LocalSearchApi";
    LocalSearchApi["__interfaces"] = ["io.nem.xpx.service.intf.SearchApi"];


}
namespace io.nem.xpx.service.remote {
    /**
     * Instantiates a new remote search api.
     * s
     * 
     * @param {io.nem.ApiClient} apiClient the api client
     * @param {io.nem.xpx.service.NemTransactionApi} nemTransactionApi the nem transaction api
     * @class
     * @extends io.nem.xpx.service.common.PrivateSearchApi
     */
    export class RemoteSearchApi extends io.nem.xpx.service.common.PrivateSearchApi implements io.nem.xpx.service.intf.SearchApi {
        /**
         * The api client.
         */
        /*private*/ apiClient : io.nem.ApiClient;

        public constructor(apiClient : io.nem.ApiClient, nemTransactionApi : io.nem.xpx.service.NemTransactionApi) {
            super(nemTransactionApi);
            if(this.apiClient===undefined) this.apiClient = null;
            this.apiClient = apiClient;
        }

        /**
         * Gets the api client.
         * 
         * @return {io.nem.ApiClient} the api client
         */
        public getApiClient() : io.nem.ApiClient {
            return this.apiClient;
        }

        /**
         * Build call for searchTransactionWithKeywordUsingGET.
         * 
         * @param {string} xPubkey The Sender or Receiver&#39;s Public Key (required)
         * @param {string} keywords Comma delimited Keyword that will be match to the files available (required)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public searchTransactionWithKeywordUsingGETCall(xPubkey : string, keywords : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = /* replaceAll */"/search/by/keywords/{keywords}".replace(new RegExp("\\{keywords\\}", 'g'),this.apiClient.escapeString(keywords.toString()));
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            let localVarHeaderParams : any = <any>({});
            if(xPubkey != null) /* put */(localVarHeaderParams["x-pubkey"] = this.apiClient.parameterToString(xPubkey));
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["application/json"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteSearchApi.RemoteSearchApi$0(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Search transaction with keyword using GET validate before call.
         * 
         * @param {string} xPubkey the x pubkey
         * @param {string} keywords the keywords
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the com.squareup.okhttp. call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ searchTransactionWithKeywordUsingGETValidateBeforeCall(xPubkey : string, keywords : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(xPubkey == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'xPubkey\' when calling searchTransactionWithKeywordUsingGET(Async)");
            }
            if(keywords == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'keywords\' when calling searchTransactionWithKeywordUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.searchTransactionWithKeywordUsingGETCall(xPubkey, keywords, progressListener, progressRequestListener);
            return call;
        }

        public searchTransactionWithKeywordUsingGET$java_lang_String$java_lang_String(xPubkey : string, keywords : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            let resp : io.nem.ApiResponse<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>> = this.searchTransactionWithKeywordUsingGETWithHttpInfo(xPubkey, keywords);
            return resp.getData();
        }

        /**
         * Search through all the owners documents to find a content that matches the text specified.
         * This endpoint can only be used to look up publicly available resources (PLAIN Message Types).
         * @param {string} xPubkey The Sender or Receiver&#39;s Public Key (required)
         * @param {string} keywords Comma delimited Keyword that will be match to the files available (required)
         * @return {io.nem.ApiResponse} ApiResponse&lt;List&lt;ResourceHashMessageJsonEntity&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public searchTransactionWithKeywordUsingGETWithHttpInfo(xPubkey : string, keywords : string) : io.nem.ApiResponse<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>> {
            let call : com.squareup.okhttp.Call = this.searchTransactionWithKeywordUsingGETValidateBeforeCall(xPubkey, keywords, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Search through all the owners documents to find a content that matches the text specified. (asynchronously)
         * This endpoint can only be used to look up publicly available resources (PLAIN Message Types).
         * @param {string} xPubkey The Sender or Receiver&#39;s Public Key (required)
         * @param {string} keywords Comma delimited Keyword that will be match to the files available (required)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public searchTransactionWithKeywordUsingGETAsync(xPubkey : string, keywords : string, callback : io.nem.ApiCallback<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteSearchApi.RemoteSearchApi$1(this, callback);
                progressRequestListener = new RemoteSearchApi.RemoteSearchApi$2(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.searchTransactionWithKeywordUsingGETValidateBeforeCall(xPubkey, keywords, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        /**
         * Build call for searchTransactionWithMetadataUsingGET.
         * 
         * @param {string} xPubkey The Sender or Receiver&#39;s Public Key (required)
         * @param {string} key Meta key (optional)
         * @param {string} value Meta value (optional)
         * @param {*} progressListener Progress listener
         * @param {*} progressRequestListener Progress request listener
         * @return {com.squareup.okhttp.Call} Call to execute
         * @throws ApiException If fail to serialize the request body object
         */
        public searchTransactionWithMetadataUsingGETCall(xPubkey : string, key : string, value : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            let localVarPostBody : any = null;
            let localVarPath : string = "/search/by/metadata";
            let localVarQueryParams : Array<io.nem.Pair> = <any>([]);
            if(key != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "key", key));
            if(value != null) /* addAll */((l1, l2) => l1.push.apply(l1, l2))(localVarQueryParams, this.apiClient.parameterToPairs("", "value", value));
            let localVarHeaderParams : any = <any>({});
            if(xPubkey != null) /* put */(localVarHeaderParams["x-pubkey"] = this.apiClient.parameterToString(xPubkey));
            let localVarFormParams : any = <any>({});
            let localVarAccepts : string[] = ["application/json"];
            let localVarAccept : string = this.apiClient.selectHeaderAccept(localVarAccepts);
            if(localVarAccept != null) /* put */(localVarHeaderParams["Accept"] = localVarAccept);
            let localVarContentTypes : string[] = ["application/json"];
            let localVarContentType : string = this.apiClient.selectHeaderContentType(localVarContentTypes);
            /* put */(localVarHeaderParams["Content-Type"] = localVarContentType);
            if(progressListener != null) {
                /* add */(this.apiClient.getHttpClient().networkInterceptors().push(new RemoteSearchApi.RemoteSearchApi$3(this, progressListener))>0);
            }
            let localVarAuthNames : string[] = [];
            return this.apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
        }

        /**
         * Search transaction with metadata using GET validate before call.
         * 
         * @param {string} xPubkey the x pubkey
         * @param {string} key the key
         * @param {string} value the value
         * @param {*} progressListener the progress listener
         * @param {*} progressRequestListener the progress request listener
         * @return {com.squareup.okhttp.Call} the com.squareup.okhttp. call
         * @throws ApiException the api exception
         * @private
         */
        /*private*/ searchTransactionWithMetadataUsingGETValidateBeforeCall(xPubkey : string, key : string, value : string, progressListener : io.nem.ProgressResponseBody.ProgressListener, progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener) : com.squareup.okhttp.Call {
            if(xPubkey == null) {
                throw new io.nem.xpx.exceptions.ApiException("Missing the required parameter \'xPubkey\' when calling searchTransactionWithMetadataUsingGET(Async)");
            }
            let call : com.squareup.okhttp.Call = this.searchTransactionWithMetadataUsingGETCall(xPubkey, key, value, progressListener, progressRequestListener);
            return call;
        }

        /**
         * Search through all the owners documents to find a key that matches the specified parameter key
         * This endpoint can only be used to look up publicly available resources (PLAIN Message Types).
         * @param {string} xPubkey The Sender or Receiver&#39;s Public Key (required)
         * @param {string} key Meta key (optional)
         * @param {string} value Meta value (optional)
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]} List&lt;ResourceHashMessageJsonEntity&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public searchTransactionWithMetadataUsingGET(xPubkey : string, key : string, value : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            let resp : io.nem.ApiResponse<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>> = this.searchTransactionWithMetadataUsingGETWithHttpInfo(xPubkey, key, value);
            return resp.getData();
        }

        /**
         * Search through all the owners documents to find a key that matches the specified parameter key
         * This endpoint can only be used to look up publicly available resources (PLAIN Message Types).
         * @param {string} xPubkey The Sender or Receiver&#39;s Public Key (required)
         * @param {string} key Meta key (optional)
         * @param {string} value Meta value (optional)
         * @return {io.nem.ApiResponse} ApiResponse&lt;List&lt;ResourceHashMessageJsonEntity&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         */
        public searchTransactionWithMetadataUsingGETWithHttpInfo(xPubkey : string, key : string, value : string) : io.nem.ApiResponse<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>> {
            let call : com.squareup.okhttp.Call = this.searchTransactionWithMetadataUsingGETValidateBeforeCall(xPubkey, key, value, null, null);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>>()).getType();
            return this.apiClient.execute<any>(call, localVarReturnType);
        }

        /**
         * Search through all the owners documents to find a key that matches the specified parameter key (asynchronously)
         * This endpoint can only be used to look up publicly available resources (PLAIN Message Types).
         * @param {string} xPubkey The Sender or Receiver&#39;s Public Key (required)
         * @param {string} key Meta key (optional)
         * @param {string} value Meta value (optional)
         * @param {*} callback The callback to be executed when the API call finishes
         * @return {com.squareup.okhttp.Call} The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         */
        public searchTransactionWithMetadataUsingGETAsync(xPubkey : string, key : string, value : string, callback : io.nem.ApiCallback<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>>) : com.squareup.okhttp.Call {
            let progressListener : io.nem.ProgressResponseBody.ProgressListener = null;
            let progressRequestListener : io.nem.ProgressRequestBody.ProgressRequestListener = null;
            if(callback != null) {
                progressListener = new RemoteSearchApi.RemoteSearchApi$4(this, callback);
                progressRequestListener = new RemoteSearchApi.RemoteSearchApi$5(this, callback);
            }
            let call : com.squareup.okhttp.Call = this.searchTransactionWithMetadataUsingGETValidateBeforeCall(xPubkey, key, value, progressListener, progressRequestListener);
            let localVarReturnType : java.lang.reflect.Type = ((target:com.google.gson.reflect.TypeToken<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>>) => {
                return target;

            })(new com.google.gson.reflect.TypeToken<Array<io.nem.xpx.model.ResourceHashMessageJsonEntity>>()).getType();
            this.apiClient.executeAsync$com_squareup_okhttp_Call$java_lang_reflect_Type$io_nem_ApiCallback(call, localVarReturnType, callback);
            return call;
        }

        public searchTransactionWithKeywordUsingGET$java_lang_String$java_lang_String$java_lang_String(xPvKey : string, xPubkey : string, keywords : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            return super.searchTransactionWithKeyword(xPvKey, xPubkey, keywords);
        }

        /**
         * 
         * @param {string} xPvKey
         * @param {string} xPubkey
         * @param {string} keywords
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]}
         */
        public searchTransactionWithKeywordUsingGET(xPvKey? : any, xPubkey? : any, keywords? : any) : any {
            if(((typeof xPvKey === 'string') || xPvKey === null) && ((typeof xPubkey === 'string') || xPubkey === null) && ((typeof keywords === 'string') || keywords === null)) {
                return <any>this.searchTransactionWithKeywordUsingGET$java_lang_String$java_lang_String$java_lang_String(xPvKey, xPubkey, keywords);
            } else if(((typeof xPvKey === 'string') || xPvKey === null) && ((typeof xPubkey === 'string') || xPubkey === null) && keywords === undefined) {
                return <any>this.searchTransactionWithKeywordUsingGET$java_lang_String$java_lang_String(xPvKey, xPubkey);
            } else throw new Error('invalid overload');
        }

        /**
         * 
         * @param {string} xPvKey
         * @param {string} xPubkey
         * @param {string} key
         * @param {string} value
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]}
         */
        public searchTransactionWithMetadataKeyValuePair(xPvKey : string, xPubkey : string, key : string, value : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            return super.searchTransactionWithMetadataKeyValuePair(xPvKey, xPubkey, key, value);
        }

        /**
         * 
         * @param {string} xPvKey
         * @param {string} xPubkey
         * @param {string} name
         * @return {io.nem.xpx.model.ResourceHashMessageJsonEntity[]}
         */
        public searchTransactionWithNameUsingGET(xPvKey : string, xPubkey : string, name : string) : Array<io.nem.xpx.model.ResourceHashMessageJsonEntity> {
            return super.searchTransactionWithName(xPvKey, xPubkey, name);
        }
    }
    RemoteSearchApi["__class"] = "io.nem.xpx.service.remote.RemoteSearchApi";
    RemoteSearchApi["__interfaces"] = ["io.nem.xpx.service.intf.SearchApi"];



    export namespace RemoteSearchApi {

        export class RemoteSearchApi$0 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteSearchApi$0["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteSearchApi$1 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteSearchApi$1["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteSearchApi$2 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteSearchApi$2["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];



        export class RemoteSearchApi$3 implements com.squareup.okhttp.Interceptor {
            public __parent: any;
            /**
             * 
             * @param {*} chain
             * @return {com.squareup.okhttp.Response}
             */
            public intercept(chain : com.squareup.okhttp.Interceptor.Chain) : com.squareup.okhttp.Response {
                let originalResponse : com.squareup.okhttp.Response = chain.proceed(chain.request());
                return originalResponse.newBuilder().body(new io.nem.ProgressResponseBody(originalResponse.body(), this.progressListener)).build();
            }

            constructor(__parent: any, private progressListener: any) {
                this.__parent = __parent;
            }
        }
        RemoteSearchApi$3["__interfaces"] = ["com.squareup.okhttp.Interceptor"];



        export class RemoteSearchApi$4 implements io.nem.ProgressResponseBody.ProgressListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesRead
             * @param {number} contentLength
             * @param {boolean} done
             */
            public update(bytesRead : number, contentLength : number, done : boolean) {
                this.callback.onDownloadProgress(bytesRead, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteSearchApi$4["__interfaces"] = ["io.nem.ProgressResponseBody.ProgressListener"];



        export class RemoteSearchApi$5 implements io.nem.ProgressRequestBody.ProgressRequestListener {
            public __parent: any;
            /**
             * 
             * @param {number} bytesWritten
             * @param {number} contentLength
             * @param {boolean} done
             */
            public onRequestProgress(bytesWritten : number, contentLength : number, done : boolean) {
                this.callback.onUploadProgress(bytesWritten, contentLength, done);
            }

            constructor(__parent: any, private callback: any) {
                this.__parent = __parent;
            }
        }
        RemoteSearchApi$5["__interfaces"] = ["io.nem.ProgressRequestBody.ProgressRequestListener"];


    }

}
namespace io.nem.xpx.strategy.privacy {
    /**
     * The Class AbstractPlainMessagePrivacyStrategy.
     * @class
     * @extends io.nem.xpx.strategy.privacy.PrivacyStrategy
     */
    export abstract class AbstractPlainMessagePrivacyStrategy extends io.nem.xpx.strategy.privacy.PrivacyStrategy {
        /**
         * 
         * @return {io.nem.xpx.model.NemMessageType}
         */
        public getNemMessageType() : io.nem.xpx.model.NemMessageType {
            return io.nem.xpx.model.NemMessageType.PLAIN;
        }

        /**
         * 
         * @param {Array} data
         * @return {org.nem.core.model.Message}
         */
        public encodeToMessage(data : number[]) : org.nem.core.model.Message {
            return new org.nem.core.messages.PlainMessage(data);
        }

        /**
         * 
         * @param {org.nem.core.model.TransferTransaction} transaction
         * @return {Array}
         */
        public decodeTransaction(transaction : org.nem.core.model.TransferTransaction) : number[] {
            if(transaction.getMessage().getType() === org.nem.core.model.MessageTypes.SECURE) throw new io.nem.xpx.exceptions.DecodeNemMessageFailureException("Unable to decode secure message with plain privacy strategy");
            return transaction.getMessage().getDecodedPayload();
        }
    }
    AbstractPlainMessagePrivacyStrategy["__class"] = "io.nem.xpx.strategy.privacy.AbstractPlainMessagePrivacyStrategy";

}
namespace io.nem.xpx.strategy.privacy {
    /**
     * Instantiates a new abstract secure message privacy strategy.
     * 
     * @param {string} privateKey the private key
     * @param {string} publicKey the public key
     * @class
     * @extends io.nem.xpx.strategy.privacy.PrivacyStrategy
     */
    export abstract class AbstractSecureMessagePrivacyStrategy extends io.nem.xpx.strategy.privacy.PrivacyStrategy {
        /**
         * The key pair of private key.
         */
        public keyPairOfPrivateKey : org.nem.core.crypto.KeyPair;

        /**
         * The key pair of public key.
         */
        public keyPairOfPublicKey : org.nem.core.crypto.KeyPair;

        /**
         * The account with private key.
         */
        public accountWithPrivateKey : org.nem.core.model.Account;

        /**
         * The account with public key.
         */
        public accountWithPublicKey : org.nem.core.model.Account;

        public constructor(privateKey : string, publicKey : string) {
            super();
            if(this.keyPairOfPrivateKey===undefined) this.keyPairOfPrivateKey = null;
            if(this.keyPairOfPublicKey===undefined) this.keyPairOfPublicKey = null;
            if(this.accountWithPrivateKey===undefined) this.accountWithPrivateKey = null;
            if(this.accountWithPublicKey===undefined) this.accountWithPublicKey = null;
            io.nem.xpx.utils.ParameterValidationUtils.checkParameter(privateKey != null, "private key is required");
            io.nem.xpx.utils.ParameterValidationUtils.checkParameter(publicKey != null, "public key is required");
            this.keyPairOfPrivateKey = new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PrivateKey.fromHexString(privateKey));
            this.keyPairOfPublicKey = new org.nem.core.crypto.KeyPair(org.nem.core.crypto.PublicKey.fromHexString(publicKey));
            this.accountWithPrivateKey = new org.nem.core.model.Account(this.keyPairOfPrivateKey);
            this.accountWithPublicKey = new org.nem.core.model.Account(this.keyPairOfPublicKey);
        }

        /**
         * 
         * @return {io.nem.xpx.model.NemMessageType}
         */
        public getNemMessageType() : io.nem.xpx.model.NemMessageType {
            return io.nem.xpx.model.NemMessageType.SECURE;
        }

        /**
         * 
         * @param {Array} data
         * @return {org.nem.core.model.Message}
         */
        public encodeToMessage(data : number[]) : org.nem.core.model.Message {
            return org.nem.core.messages.SecureMessage.fromDecodedPayload(this.accountWithPrivateKey, this.accountWithPublicKey, data);
        }

        /**
         * 
         * @param {org.nem.core.model.TransferTransaction} transaction
         * @return {Array}
         */
        public decodeTransaction(transaction : org.nem.core.model.TransferTransaction) : number[] {
            if(transaction.getMessage().getType() === org.nem.core.model.MessageTypes.PLAIN) return transaction.getMessage().getDecodedPayload();
            if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(transaction.getSigner().getAddress().getEncoded(),this.accountWithPrivateKey.getAddress().getEncoded()))) {
                return org.nem.core.messages.SecureMessage.fromEncodedPayload(this.accountWithPrivateKey, this.accountWithPublicKey, transaction.getMessage().getEncodedPayload()).getDecodedPayload();
            } else if(/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(transaction.getRecipient().getAddress().getEncoded(),this.accountWithPrivateKey.getAddress().getEncoded()))) {
                return org.nem.core.messages.SecureMessage.fromEncodedPayload(this.accountWithPublicKey, this.accountWithPrivateKey, transaction.getMessage().getEncodedPayload()).getDecodedPayload();
            } else {
                throw new io.nem.xpx.exceptions.DecodeNemMessageFailureException("Private key cannot be used to decode the Nem secured message.");
            }
        }
    }
    AbstractSecureMessagePrivacyStrategy["__class"] = "io.nem.xpx.strategy.privacy.AbstractSecureMessagePrivacyStrategy";

}
namespace io.nem.xpx.facade.connection {
    /**
     * Instantiates a new local fuse peer connection.
     * 
     * @param {org.nem.core.node.NodeEndpoint} nodeEndpoint the node endpoint
     * @param {string} multiAddress the multi address
     * @param {Array} syncGateways list of gateway URLs where uploads will be sync
     * @class
     * @extends io.nem.xpx.facade.connection.AbstractLocalPeerConnection
     */
    export class LocalFusePeerConnection extends io.nem.xpx.facade.connection.AbstractLocalPeerConnection {
        public constructor(nodeEndpoint? : any, multiAddress? : any, ...syncGateways : any[]) {
            if(((nodeEndpoint != null && nodeEndpoint instanceof <any>org.nem.core.node.NodeEndpoint) || nodeEndpoint === null) && ((typeof multiAddress === 'string') || multiAddress === null) && ((syncGateways != null && syncGateways instanceof <any>Array && (syncGateways.length==0 || syncGateways[0] == null ||(typeof syncGateways[0] === 'string'))) || syncGateways === null)) {
                let __args = Array.prototype.slice.call(arguments);
                super(nodeEndpoint, new io.ipfs.api.IPFS(new io.ipfs.multiaddr.MultiAddress(multiAddress)), /* asList */syncGateways.slice(0));
            } else if(((nodeEndpoint != null && nodeEndpoint instanceof <any>org.nem.core.node.NodeEndpoint) || nodeEndpoint === null) && ((typeof multiAddress === 'string') || multiAddress === null) && ((syncGateways != null && (syncGateways instanceof Array)) || syncGateways === null)) {
                let __args = Array.prototype.slice.call(arguments);
                super(nodeEndpoint, new io.ipfs.api.IPFS(new io.ipfs.multiaddr.MultiAddress(multiAddress)), syncGateways);
            } else if(((nodeEndpoint != null && nodeEndpoint instanceof <any>org.nem.core.node.NodeEndpoint) || nodeEndpoint === null) && ((multiAddress != null && multiAddress instanceof <any>Array && (multiAddress.length==0 || multiAddress[0] == null ||(typeof multiAddress[0] === 'string'))) || multiAddress === null) && syncGateways === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let syncGateways : any[] = __args[1];
                super(nodeEndpoint, new io.ipfs.api.IPFS(new io.ipfs.multiaddr.MultiAddress("/ip4/127.0.0.1/tcp/5001")), /* asList */syncGateways.slice(0));
            } else if(((nodeEndpoint != null && nodeEndpoint instanceof <any>org.nem.core.node.NodeEndpoint) || nodeEndpoint === null) && ((multiAddress != null && (multiAddress instanceof Array)) || multiAddress === null) && syncGateways === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let syncGateways : any = __args[1];
                super(nodeEndpoint, new io.ipfs.api.IPFS(new io.ipfs.multiaddr.MultiAddress("/ip4/127.0.0.1/tcp/5001")), syncGateways);
            } else throw new Error('invalid overload');
        }
    }
    LocalFusePeerConnection["__class"] = "io.nem.xpx.facade.connection.LocalFusePeerConnection";

}
namespace io.nem.xpx.facade.connection {
    /**
     * Instantiates a new local http peer connection.
     * 
     * @param {org.nem.core.node.NodeEndpoint} nodeEndpoint the node endpoint
     * @param {io.ipfs.api.IPFS} ipfsConnection the ipfs connection
     * @param {Array} syncGateways list of gateway URLs where uploads will be sync
     * @class
     * @extends io.nem.xpx.facade.connection.AbstractLocalPeerConnection
     */
    export class LocalHttpPeerConnection extends io.nem.xpx.facade.connection.AbstractLocalPeerConnection {
        public constructor(nodeEndpoint? : any, ipfsConnection? : any, ...syncGateways : any[]) {
            if(((nodeEndpoint != null && nodeEndpoint instanceof <any>org.nem.core.node.NodeEndpoint) || nodeEndpoint === null) && ((ipfsConnection != null && ipfsConnection instanceof <any>io.ipfs.api.IPFS) || ipfsConnection === null) && ((syncGateways != null && syncGateways instanceof <any>Array && (syncGateways.length==0 || syncGateways[0] == null ||(typeof syncGateways[0] === 'string'))) || syncGateways === null)) {
                let __args = Array.prototype.slice.call(arguments);
                super(nodeEndpoint, ipfsConnection, /* asList */syncGateways.slice(0));
            } else if(((nodeEndpoint != null && nodeEndpoint instanceof <any>org.nem.core.node.NodeEndpoint) || nodeEndpoint === null) && ((ipfsConnection != null && ipfsConnection instanceof <any>io.ipfs.api.IPFS) || ipfsConnection === null) && ((syncGateways != null && (syncGateways instanceof Array)) || syncGateways === null)) {
                let __args = Array.prototype.slice.call(arguments);
                super(nodeEndpoint, ipfsConnection, syncGateways);
            } else if(((nodeEndpoint != null && nodeEndpoint instanceof <any>org.nem.core.node.NodeEndpoint) || nodeEndpoint === null) && ((typeof ipfsConnection === 'string') || ipfsConnection === null) && ((syncGateways != null && syncGateways instanceof <any>Array && (syncGateways.length==0 || syncGateways[0] == null ||(typeof syncGateways[0] === 'string'))) || syncGateways === null)) {
                let __args = Array.prototype.slice.call(arguments);
                let multiAddress : any = __args[1];
                super(nodeEndpoint, new io.ipfs.api.IPFS(new io.ipfs.multiaddr.MultiAddress(multiAddress)), /* asList */syncGateways.slice(0));
            } else if(((nodeEndpoint != null && nodeEndpoint instanceof <any>org.nem.core.node.NodeEndpoint) || nodeEndpoint === null) && ((typeof ipfsConnection === 'string') || ipfsConnection === null) && ((syncGateways != null && (syncGateways instanceof Array)) || syncGateways === null)) {
                let __args = Array.prototype.slice.call(arguments);
                let multiAddress : any = __args[1];
                super(nodeEndpoint, new io.ipfs.api.IPFS(new io.ipfs.multiaddr.MultiAddress(multiAddress)), syncGateways);
            } else if(((nodeEndpoint != null && nodeEndpoint instanceof <any>org.nem.core.node.NodeEndpoint) || nodeEndpoint === null) && ((ipfsConnection != null && ipfsConnection instanceof <any>Array && (ipfsConnection.length==0 || ipfsConnection[0] == null ||(typeof ipfsConnection[0] === 'string'))) || ipfsConnection === null) && syncGateways === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let syncGateways : any[] = __args[1];
                super(nodeEndpoint, null, /* asList */syncGateways.slice(0));
            } else if(((nodeEndpoint != null && nodeEndpoint instanceof <any>org.nem.core.node.NodeEndpoint) || nodeEndpoint === null) && ((ipfsConnection != null && (ipfsConnection instanceof Array)) || ipfsConnection === null) && syncGateways === undefined) {
                let __args = Array.prototype.slice.call(arguments);
                let syncGateways : any = __args[1];
                super(nodeEndpoint, null, syncGateways);
            } else throw new Error('invalid overload');
        }
    }
    LocalHttpPeerConnection["__class"] = "io.nem.xpx.facade.connection.LocalHttpPeerConnection";

}
namespace io.nem.xpx.facade.multisigupload {
    /**
     * The Class MultisigUploadBinaryParameter.
     * @class
     * @extends io.nem.xpx.facade.upload.UploadBinaryParameter
     */
    export class MultisigUploadBinaryParameter extends io.nem.xpx.facade.upload.UploadBinaryParameter {
        /**
         * The multisig public key.
         */
        /*private*/ multisigPublicKey : string;

        /**
         * Gets the multisig public key.
         * 
         * @return {string} the multisig public key
         */
        public getMultisigPublicKey() : string {
            return this.multisigPublicKey;
        }

        /**
         * Sets the multisig public key.
         * 
         * @param {string} multisigPublicKey the new multisig public key
         */
        public setMultisigPublicKey(multisigPublicKey : string) {
            this.multisigPublicKey = multisigPublicKey;
        }

        /**
         * Creates the multisig param.
         * 
         * @return {*} the multisig public key step
         */
        public static createMultisigParam() : io.nem.xpx.builder.steps.MultisigPublicKeyStep<io.nem.xpx.builder.steps.SenderPrivateKeyStep<io.nem.xpx.builder.steps.ReceiverPublicKeyStep<io.nem.xpx.builder.steps.BinaryDataStep<UploadBinaryParameter.FinalBuildSteps>>>> {
            return new MultisigUploadBinaryParameter.__io_nem_xpx_facade_multisigupload_MultisigUploadBinaryParameter_Builder();
        }

        constructor() {
            super();
            if(this.multisigPublicKey===undefined) this.multisigPublicKey = null;
        }
    }
    MultisigUploadBinaryParameter["__class"] = "io.nem.xpx.facade.multisigupload.MultisigUploadBinaryParameter";
    MultisigUploadBinaryParameter["__interfaces"] = ["java.io.Serializable"];



    export namespace MultisigUploadBinaryParameter {

        /**
         * The Class Builder.
         * @extends io.nem.xpx.facade.upload.UploadBinaryParameter.Builder
         * @class
         */
        export class __io_nem_xpx_facade_multisigupload_MultisigUploadBinaryParameter_Builder extends io.nem.xpx.facade.upload.UploadBinaryParameter.Builder implements io.nem.xpx.builder.steps.MultisigPublicKeyStep<any> {
            /**
             * The instance.
             */
            instance : io.nem.xpx.facade.multisigupload.MultisigUploadBinaryParameter;

            constructor() {
                super(new io.nem.xpx.facade.multisigupload.MultisigUploadBinaryParameter());
                if(this.instance===undefined) this.instance = null;
                this.instance = <io.nem.xpx.facade.multisigupload.MultisigUploadBinaryParameter>this.instance;
            }

            /**
             * 
             * @param {string} multisigPublicKeyStep
             * @return {*}
             */
            public multisigPublicKeyStep(multisigPublicKeyStep : string) : io.nem.xpx.builder.steps.SenderPrivateKeyStep<any> {
                this.instance.setMultisigPublicKey(multisigPublicKeyStep);
                return this;
            }

            /**
             * 
             * @return {io.nem.xpx.facade.multisigupload.MultisigUploadBinaryParameter}
             */
            public build() : io.nem.xpx.facade.multisigupload.MultisigUploadBinaryParameter {
                if(io.nem.xpx.utils.StringUtils.isEmpty(this.instance.getContentType())) this.instance.setContentType(io.nem.xpx.utils.ContentTypeUtils.detectContentType$byte_A(this.instance.getData()));
                return this.instance;
            }
        }
        __io_nem_xpx_facade_multisigupload_MultisigUploadBinaryParameter_Builder["__class"] = "io.nem.xpx.facade.multisigupload.MultisigUploadBinaryParameter.Builder";
        __io_nem_xpx_facade_multisigupload_MultisigUploadBinaryParameter_Builder["__interfaces"] = ["io.nem.xpx.builder.steps.KeywordsStep","io.nem.xpx.builder.steps.ContentTypeStep","io.nem.xpx.builder.steps.PrivacyStrategyUploadStep","io.nem.xpx.builder.steps.MosaicsStep","io.nem.xpx.builder.steps.ReceiverPublicKeyStep","io.nem.xpx.builder.steps.NameStep","io.nem.xpx.builder.steps.MetadataStep","io.nem.xpx.builder.steps.SenderPrivateKeyStep","io.nem.xpx.builder.steps.CommonUploadBuildSteps","io.nem.xpx.facade.upload.UploadBinaryParameter.FinalBuildSteps","io.nem.xpx.builder.steps.MultisigPublicKeyStep","io.nem.xpx.builder.steps.BinaryDataStep"];


    }

}
namespace io.nem.xpx.facade.multisigupload {
    /**
     * The Class MultisigUploadFileParameter.
     * @class
     * @extends io.nem.xpx.facade.upload.UploadFileParameter
     */
    export class MultisigUploadFileParameter extends io.nem.xpx.facade.upload.UploadFileParameter {
        /**
         * The multisig public key.
         */
        /*private*/ multisigPublicKey : string;

        /**
         * Gets the multisig public key.
         * 
         * @return {string} the multisig public key
         */
        public getMultisigPublicKey() : string {
            return this.multisigPublicKey;
        }

        /**
         * Sets the multisig public key.
         * 
         * @param {string} multisigPublicKey the new multisig public key
         */
        public setMultisigPublicKey(multisigPublicKey : string) {
            this.multisigPublicKey = multisigPublicKey;
        }

        /**
         * Creates the multisig param.
         * 
         * @return {*} the multisig public key step
         */
        public static createMultisigParam() : io.nem.xpx.builder.steps.MultisigPublicKeyStep<io.nem.xpx.builder.steps.SenderPrivateKeyStep<io.nem.xpx.builder.steps.ReceiverPublicKeyStep<io.nem.xpx.builder.steps.FileStep<UploadFileParameter.FinalBuildSteps>>>> {
            return new MultisigUploadFileParameter.__io_nem_xpx_facade_multisigupload_MultisigUploadFileParameter_Builder();
        }

        constructor() {
            super();
            if(this.multisigPublicKey===undefined) this.multisigPublicKey = null;
        }
    }
    MultisigUploadFileParameter["__class"] = "io.nem.xpx.facade.multisigupload.MultisigUploadFileParameter";
    MultisigUploadFileParameter["__interfaces"] = ["java.io.Serializable"];



    export namespace MultisigUploadFileParameter {

        /**
         * The Class Builder.
         * @extends io.nem.xpx.facade.upload.UploadFileParameter.Builder
         * @class
         */
        export class __io_nem_xpx_facade_multisigupload_MultisigUploadFileParameter_Builder extends io.nem.xpx.facade.upload.UploadFileParameter.Builder implements io.nem.xpx.builder.steps.MultisigPublicKeyStep<any> {
            /**
             * The instance.
             */
            instance : io.nem.xpx.facade.multisigupload.MultisigUploadFileParameter;

            constructor() {
                super(new io.nem.xpx.facade.multisigupload.MultisigUploadFileParameter());
                if(this.instance===undefined) this.instance = null;
                this.instance = <io.nem.xpx.facade.multisigupload.MultisigUploadFileParameter>this.instance;
            }

            /**
             * 
             * @param {string} multisigPublicKeyStep
             * @return {*}
             */
            public multisigPublicKeyStep(multisigPublicKeyStep : string) : io.nem.xpx.builder.steps.SenderPrivateKeyStep<any> {
                this.instance.setMultisigPublicKey(multisigPublicKeyStep);
                return this;
            }

            /**
             * 
             * @return {io.nem.xpx.facade.multisigupload.MultisigUploadFileParameter}
             */
            public build() : io.nem.xpx.facade.multisigupload.MultisigUploadFileParameter {
                if(io.nem.xpx.utils.StringUtils.isEmpty(this.instance.getName())) this.instance.setName(this.instance.getFile().getName());
                if(io.nem.xpx.utils.StringUtils.isEmpty(this.instance.getContentType())) this.instance.setContentType(io.nem.xpx.utils.ContentTypeUtils.detectContentType$byte_A(org.apache.commons.io.FileUtils.readFileToByteArray(this.instance.getFile())));
                return this.instance;
            }
        }
        __io_nem_xpx_facade_multisigupload_MultisigUploadFileParameter_Builder["__class"] = "io.nem.xpx.facade.multisigupload.MultisigUploadFileParameter.Builder";
        __io_nem_xpx_facade_multisigupload_MultisigUploadFileParameter_Builder["__interfaces"] = ["io.nem.xpx.facade.upload.UploadFileParameter.FinalBuildSteps","io.nem.xpx.builder.steps.KeywordsStep","io.nem.xpx.builder.steps.ContentTypeStep","io.nem.xpx.builder.steps.PrivacyStrategyUploadStep","io.nem.xpx.builder.steps.MosaicsStep","io.nem.xpx.builder.steps.FileNameStep","io.nem.xpx.builder.steps.ReceiverPublicKeyStep","io.nem.xpx.builder.steps.FileStep","io.nem.xpx.builder.steps.MetadataStep","io.nem.xpx.builder.steps.SenderPrivateKeyStep","io.nem.xpx.builder.steps.CommonUploadBuildSteps","io.nem.xpx.builder.steps.MultisigPublicKeyStep"];


    }

}
namespace io.nem.xpx.facade.multisigupload {
    /**
     * The Class MultisigUploadTextDataParameter.
     * @class
     * @extends io.nem.xpx.facade.upload.UploadTextDataParameter
     */
    export class MultisigUploadTextDataParameter extends io.nem.xpx.facade.upload.UploadTextDataParameter {
        /**
         * The multisig public key.
         */
        /*private*/ multisigPublicKey : string;

        /**
         * Gets the multisig public key.
         * 
         * @return {string} the multisig public key
         */
        public getMultisigPublicKey() : string {
            return this.multisigPublicKey;
        }

        /**
         * Sets the multisig public key.
         * 
         * @param {string} multisigPublicKey the new multisig public key
         */
        public setMultisigPublicKey(multisigPublicKey : string) {
            this.multisigPublicKey = multisigPublicKey;
        }

        /**
         * Creates the multisig param.
         * 
         * @return {*} the multisig public key step
         */
        public static createMultisigParam() : io.nem.xpx.builder.steps.MultisigPublicKeyStep<io.nem.xpx.builder.steps.SenderPrivateKeyStep<io.nem.xpx.builder.steps.ReceiverPublicKeyStep<io.nem.xpx.builder.steps.TextDataStep<UploadTextDataParameter.FinalBuildSteps>>>> {
            return new MultisigUploadTextDataParameter.__io_nem_xpx_facade_multisigupload_MultisigUploadTextDataParameter_Builder();
        }

        constructor() {
            super();
            if(this.multisigPublicKey===undefined) this.multisigPublicKey = null;
        }
    }
    MultisigUploadTextDataParameter["__class"] = "io.nem.xpx.facade.multisigupload.MultisigUploadTextDataParameter";
    MultisigUploadTextDataParameter["__interfaces"] = ["java.io.Serializable"];



    export namespace MultisigUploadTextDataParameter {

        /**
         * The Class Builder.
         * @extends io.nem.xpx.facade.upload.UploadTextDataParameter.Builder
         * @class
         */
        export class __io_nem_xpx_facade_multisigupload_MultisigUploadTextDataParameter_Builder extends io.nem.xpx.facade.upload.UploadTextDataParameter.Builder implements io.nem.xpx.builder.steps.MultisigPublicKeyStep<any> {
            /**
             * The instance.
             */
            instance : io.nem.xpx.facade.multisigupload.MultisigUploadTextDataParameter;

            constructor() {
                super(new io.nem.xpx.facade.multisigupload.MultisigUploadTextDataParameter());
                if(this.instance===undefined) this.instance = null;
                this.instance = <io.nem.xpx.facade.multisigupload.MultisigUploadTextDataParameter>this.instance;
            }

            /**
             * 
             * @param {string} multisigPublicKeyStep
             * @return {*}
             */
            public multisigPublicKeyStep(multisigPublicKeyStep : string) : io.nem.xpx.builder.steps.SenderPrivateKeyStep<any> {
                this.instance.setMultisigPublicKey(multisigPublicKeyStep);
                return this;
            }

            /**
             * 
             * @return {io.nem.xpx.facade.multisigupload.MultisigUploadTextDataParameter}
             */
            public build() : io.nem.xpx.facade.multisigupload.MultisigUploadTextDataParameter {
                if(io.nem.xpx.utils.StringUtils.isEmpty(this.instance.getContentType())) this.instance.setContentType(io.nem.xpx.utils.ContentTypeUtils.detectContentType$java_lang_String(this.instance.getData()));
                return this.instance;
            }
        }
        __io_nem_xpx_facade_multisigupload_MultisigUploadTextDataParameter_Builder["__class"] = "io.nem.xpx.facade.multisigupload.MultisigUploadTextDataParameter.Builder";
        __io_nem_xpx_facade_multisigupload_MultisigUploadTextDataParameter_Builder["__interfaces"] = ["io.nem.xpx.builder.steps.TextDataStep","io.nem.xpx.builder.steps.ContentTypeStep","io.nem.xpx.builder.steps.PrivacyStrategyUploadStep","io.nem.xpx.builder.steps.MosaicsStep","io.nem.xpx.builder.steps.ReceiverPublicKeyStep","io.nem.xpx.builder.steps.CommonUploadBuildSteps","io.nem.xpx.builder.steps.KeywordsStep","io.nem.xpx.builder.steps.NameStep","io.nem.xpx.builder.steps.EncodingStep","io.nem.xpx.builder.steps.MetadataStep","io.nem.xpx.builder.steps.SenderPrivateKeyStep","io.nem.xpx.builder.steps.MultisigPublicKeyStep","io.nem.xpx.facade.upload.UploadTextDataParameter.FinalBuildSteps"];


    }

}
namespace io.nem.xpx.strategy.privacy {
    /**
     * The Class PlainPrivacyStrategy.
     * @class
     * @extends io.nem.xpx.strategy.privacy.AbstractPlainMessagePrivacyStrategy
     */
    export class PlainPrivacyStrategy extends io.nem.xpx.strategy.privacy.AbstractPlainMessagePrivacyStrategy {
        /**
         * 
         * @param {Array} data
         * @return {Array}
         */
        public encrypt(data : number[]) : number[] {
            return data;
        }

        /**
         * 
         * @param {Array} data
         * @param {org.nem.core.model.TransferTransaction} transaction
         * @param {io.nem.xpx.service.model.buffers.ResourceHashMessage} hashMessage
         * @return {Array}
         */
        public decrypt(data : number[], transaction : org.nem.core.model.TransferTransaction, hashMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage) : number[] {
            return data;
        }
    }
    PlainPrivacyStrategy["__class"] = "io.nem.xpx.strategy.privacy.PlainPrivacyStrategy";

}
namespace io.nem.xpx.strategy.privacy {
    /**
     * Instantiates a new secured with password privacy strategy.
     * 
     * @param {io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption} encryptor the encryptor
     * @param {string} password the password
     * @class
     * @extends io.nem.xpx.strategy.privacy.AbstractPlainMessagePrivacyStrategy
     */
    export class SecuredWithPasswordPrivacyStrategy extends io.nem.xpx.strategy.privacy.AbstractPlainMessagePrivacyStrategy {
        /**
         * The Constant MINIMUM_PASSWORD_LENGTH.
         */
        static MINIMUM_PASSWORD_LENGTH : number = 50;

        /**
         * The encryptor.
         */
        /*private*/ encryptor : io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption;

        /**
         * The password.
         */
        /*private*/ password : string[];

        public constructor(encryptor : io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption, password : string) {
            super();
            if(this.encryptor===undefined) this.encryptor = null;
            if(this.password===undefined) this.password = null;
            io.nem.xpx.utils.ParameterValidationUtils.checkParameter(password != null, "password is required");
            io.nem.xpx.utils.ParameterValidationUtils.checkParameter(password.length >= SecuredWithPasswordPrivacyStrategy.MINIMUM_PASSWORD_LENGTH, "minimum length for password is 50");
            this.encryptor = encryptor;
            this.password = /* toCharArray */(password).split('');
        }

        /**
         * 
         * @param {Array} data
         * @return {Array}
         */
        public encrypt(data : number[]) : number[] {
            try {
                return this.encryptor.encrypt(data, this.password);
            } catch(e) {
                throw new io.nem.xpx.exceptions.EncryptionFailureException("Exception encountered encrypting data", e);
            };
        }

        /**
         * 
         * @param {Array} data
         * @param {org.nem.core.model.TransferTransaction} transaction
         * @param {io.nem.xpx.service.model.buffers.ResourceHashMessage} hashMessage
         * @return {Array}
         */
        public decrypt(data : number[], transaction : org.nem.core.model.TransferTransaction, hashMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage) : number[] {
            try {
                return this.encryptor.decrypt$byte_A$char_A(data, this.password);
            } catch(e) {
                throw new io.nem.xpx.exceptions.EncryptionFailureException("Exception encountered decrypting data", e);
            };
        }
    }
    SecuredWithPasswordPrivacyStrategy["__class"] = "io.nem.xpx.strategy.privacy.SecuredWithPasswordPrivacyStrategy";

}
namespace io.nem.xpx.strategy.privacy {
    export class SecuredWithShamirSecretSharingPrivacyStrategy extends io.nem.xpx.strategy.privacy.AbstractPlainMessagePrivacyStrategy {
        /*private*/ secret : string[];

        /*private*/ encryptor : io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption;

        public constructor(encryptor : io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption, secretTotalPartCount : number, secretMinimumPartCountToBuild : number, secretParts : any) {
            super();
            if(this.secret===undefined) this.secret = null;
            if(this.encryptor===undefined) this.encryptor = null;
            io.nem.xpx.utils.ParameterValidationUtils.checkParameter(secretTotalPartCount > 0, "secretTotalPartCount should be a positive number");
            io.nem.xpx.utils.ParameterValidationUtils.checkParameter(secretMinimumPartCountToBuild > 0 && secretMinimumPartCountToBuild <= secretTotalPartCount, "secretMinimumPartCountToBuild should be a positive number less than or equal to secretTotalPartCount");
            io.nem.xpx.utils.ParameterValidationUtils.checkParameter(secretParts != null, "secretParts is required");
            io.nem.xpx.utils.ParameterValidationUtils.checkParameter(/* size */((m) => { if(m.entries==null) m.entries=[]; return m.entries.length; })(<any>secretParts) >= secretMinimumPartCountToBuild, "secretParts should meet minimum part count as defined by secretMinimumPartCountToBuild");
            this.secret = /* toCharArray */(String.fromCharCode.apply(null, com.codahale.shamir.Scheme.of(secretTotalPartCount, secretMinimumPartCountToBuild).join(secretParts))).split('');
            this.encryptor = encryptor;
        }

        /**
         * 
         * @param {Array} data
         * @return {Array}
         */
        public encrypt(data : number[]) : number[] {
            try {
                return this.encryptor.encrypt(data, this.secret);
            } catch(e) {
                throw new io.nem.xpx.exceptions.EncryptionFailureException("Exception encountered encrypting data", e);
            };
        }

        /**
         * 
         * @param {Array} data
         * @param {org.nem.core.model.TransferTransaction} transaction
         * @param {io.nem.xpx.service.model.buffers.ResourceHashMessage} hashMessage
         * @return {Array}
         */
        public decrypt(data : number[], transaction : org.nem.core.model.TransferTransaction, hashMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage) : number[] {
            try {
                return this.encryptor.decrypt$byte_A$char_A(data, this.secret);
            } catch(e) {
                throw new io.nem.xpx.exceptions.EncryptionFailureException("Exception encountered decrypting data", e);
            };
        }
    }
    SecuredWithShamirSecretSharingPrivacyStrategy["__class"] = "io.nem.xpx.strategy.privacy.SecuredWithShamirSecretSharingPrivacyStrategy";


    export namespace SecuredWithShamirSecretSharingPrivacyStrategy {

        export class SecretPart {
            public index : number;

            public __secretPart : number[];

            public constructor(index : number, secretPart : number[]) {
                if(this.index===undefined) this.index = 0;
                if(this.__secretPart===undefined) this.__secretPart = null;
                this.index = index;
                this.__secretPart = secretPart;
            }

            public static secretPart(index : number, secretPart : number[]) : SecuredWithShamirSecretSharingPrivacyStrategy.SecretPart {
                return new SecuredWithShamirSecretSharingPrivacyStrategy.SecretPart(index, secretPart);
            }
        }
        SecretPart["__class"] = "io.nem.xpx.strategy.privacy.SecuredWithShamirSecretSharingPrivacyStrategy.SecretPart";

    }

}
namespace io.nem.xpx.strategy.privacy {
    /**
     * Instantiates a new secured with nem keys privacy strategy.
     * 
     * @param {string} privateKey the private key
     * @param {string} publicKey the public key
     * @class
     * @extends io.nem.xpx.strategy.privacy.AbstractSecureMessagePrivacyStrategy
     */
    export class SecuredWithNemKeysPrivacyStrategy extends io.nem.xpx.strategy.privacy.AbstractSecureMessagePrivacyStrategy {
        public constructor(privateKey : string, publicKey : string) {
            super(privateKey, publicKey);
        }

        /**
         * 
         * @param {Array} data
         * @return {Array}
         */
        public encrypt(data : number[]) : number[] {
            return org.nem.core.crypto.CryptoEngines.defaultEngine().createBlockCipher(this.keyPairOfPrivateKey, this.keyPairOfPublicKey).encrypt(data);
        }

        /**
         * 
         * @param {Array} data
         * @param {org.nem.core.model.TransferTransaction} transaction
         * @param {io.nem.xpx.service.model.buffers.ResourceHashMessage} hashMessage
         * @return {Array}
         */
        public decrypt(data : number[], transaction : org.nem.core.model.TransferTransaction, hashMessage : io.nem.xpx.service.model.buffers.ResourceHashMessage) : number[] {
            if(transaction != null && !/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(transaction.getSigner().getAddress().getEncoded(),this.accountWithPrivateKey.getAddress().getEncoded())) && !/* equals */(<any>((o1: any, o2: any) => { if(o1 && o1.equals) { return o1.equals(o2); } else { return o1 === o2; } })(transaction.getRecipient().getAddress().getEncoded(),this.accountWithPrivateKey.getAddress().getEncoded()))) {
                throw new io.nem.xpx.exceptions.DecryptionFailureException("Decrypt of data is unsuccessful");
            }
            return org.nem.core.crypto.CryptoEngines.defaultEngine().createBlockCipher(this.keyPairOfPublicKey, this.keyPairOfPrivateKey).decrypt(data);
        }
    }
    SecuredWithNemKeysPrivacyStrategy["__class"] = "io.nem.xpx.strategy.privacy.SecuredWithNemKeysPrivacyStrategy";

}


io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption.FIXED_NONCE_$LI$();

io.nem.xpx.adapters.cipher.BinaryPBKDF2CipherEncryption.SALT_$LI$();

io.nem.xpx.utils.ContentTypeUtils.TIKA_$LI$();

io.nem.xpx.model.XpxSdkGlobalConstants.TIME_PROVIDER_$LI$();

io.nem.xpx.factory.ConnectionFactory.CLIENT_$LI$();

io.nem.ApiClient.ANDROID_SDK_VERSION_$LI$();

io.nem.ApiClient.IS_ANDROID_$LI$();

io.nem.ApiClient.JAVA_VERSION_$LI$();

io.nem.ApiClient.__static_initialize();

io.nem.xpx.websockets.ConfirmedTransactionWebSocketClient.main(null);
